{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/IAccessControl.sol)\n\npragma solidity >=0.8.4;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\nimport {Create2} from \"../utils/Create2.sol\";\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[ERC-1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    error CloneArgumentsTooLong();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        return clone(implementation, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-clone-address-}[clone], but with a `value` parameter to send native currency\n     * to the new contract.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function clone(address implementation, uint256 value) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(value, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple times will revert, since\n     * the clones cannot be deployed twice at the same address.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        return cloneDeterministic(implementation, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministic-address-bytes32-}[cloneDeterministic], but with\n     * a `value` parameter to send native currency to the new contract.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(value, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := and(keccak256(add(ptr, 0x43), 0x55), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\n     * access the arguments within the implementation, use {fetchCloneArgs}.\n     *\n     * This function uses the create opcode, which should never revert.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     */\n    function cloneWithImmutableArgs(address implementation, bytes memory args) internal returns (address instance) {\n        return cloneWithImmutableArgs(implementation, args, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneWithImmutableArgs-address-bytes-}[cloneWithImmutableArgs], but with a `value`\n     * parameter to send native currency to the new contract.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        assembly (\"memory-safe\") {\n            instance := create(value, add(bytecode, 0x20), mload(bytecode))\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\n     * access the arguments within the implementation, use {fetchCloneArgs}.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy the clone. Using the same\n     * `implementation`, `args` and `salt` multiple times will revert, since the clones cannot be deployed twice\n     * at the same address.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     */\n    function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        return cloneDeterministicWithImmutableArgs(implementation, args, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministicWithImmutableArgs-address-bytes-bytes32-}[cloneDeterministicWithImmutableArgs],\n     * but with a `value` parameter to send native currency to the new contract.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.deploy(value, salt, bytecode);\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\n     */\n    function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.computeAddress(salt, keccak256(bytecode), deployer);\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\n     */\n    function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddressWithImmutableArgs(implementation, args, salt, address(this));\n    }\n\n    /**\n     * @dev Get the immutable args attached to a clone.\n     *\n     * - If `instance` is a clone that was deployed using `clone` or `cloneDeterministic`, this\n     *   function will return an empty array.\n     * - If `instance` is a clone that was deployed using `cloneWithImmutableArgs` or\n     *   `cloneDeterministicWithImmutableArgs`, this function will return the args array used at\n     *   creation.\n     * - If `instance` is NOT a clone deployed using this library, the behavior is undefined. This\n     *   function should only be used to check addresses that are known to be clones.\n     */\n    function fetchCloneArgs(address instance) internal view returns (bytes memory) {\n        bytes memory result = new bytes(instance.code.length - 45); // revert if length is too short\n        assembly (\"memory-safe\") {\n            extcodecopy(instance, add(result, 32), 45, mload(result))\n        }\n        return result;\n    }\n\n    /**\n     * @dev Helper that prepares the initcode of the proxy with immutable args.\n     *\n     * An assembly variant of this function requires copying the `args` array, which can be efficiently done using\n     * `mcopy`. Unfortunately, that opcode is not available before cancun. A pure solidity implementation using\n     * abi.encodePacked is more expensive but also more portable and easier to review.\n     *\n     * NOTE: https://eips.ethereum.org/EIPS/eip-170[EIP-170] limits the length of the contract code to 24576 bytes.\n     * With the proxy code taking 45 bytes, that limits the length of the immutable args to 24531 bytes.\n     */\n    function _cloneCodeWithImmutableArgs(\n        address implementation,\n        bytes memory args\n    ) private pure returns (bytes memory) {\n        if (args.length > 24531) revert CloneArgumentsTooLong();\n        return\n            abi.encodePacked(\n                hex\"61\",\n                uint16(args.length + 45),\n                hex\"3d81600a3d39f3363d3d373d3d3d363d73\",\n                implementation,\n                hex\"5af43d82803e903d91602b57fd5bf3\",\n                args\n            );\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155} from \"./IERC1155.sol\";\nimport {IERC1155MetadataURI} from \"./extensions/IERC1155MetadataURI.sol\";\nimport {ERC1155Utils} from \"./utils/ERC1155Utils.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {Arrays} from \"../../utils/Arrays.sol\";\nimport {IERC1155Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n */\nabstract contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI, IERC1155Errors {\n    using Arrays for uint256[];\n    using Arrays for address[];\n\n    mapping(uint256 id => mapping(address account => uint256)) private _balances;\n\n    mapping(address account => mapping(address operator => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the ERC].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256 /* id */) public view virtual returns (string memory) {\n        return _uri;\n    }\n\n    /// @inheritdoc IERC1155\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual returns (uint256[] memory) {\n        if (accounts.length != ids.length) {\n            revert ERC1155InvalidArrayLength(ids.length, accounts.length);\n        }\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));\n        }\n\n        return batchBalances;\n    }\n\n    /// @inheritdoc IERC1155\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /// @inheritdoc IERC1155\n    function isApprovedForAll(address account, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /// @inheritdoc IERC1155\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual {\n        address sender = _msgSender();\n        if (from != sender && !isApprovedForAll(from, sender)) {\n            revert ERC1155MissingApprovalForAll(sender, from);\n        }\n        _safeTransferFrom(from, to, id, value, data);\n    }\n\n    /// @inheritdoc IERC1155\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual {\n        address sender = _msgSender();\n        if (from != sender && !isApprovedForAll(from, sender)) {\n            revert ERC1155MissingApprovalForAll(sender, from);\n        }\n        _safeBatchTransferFrom(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from`\n     * (or `to`) is the zero address.\n     *\n     * Emits a {TransferSingle} event if the arrays contain one element, and {TransferBatch} otherwise.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement either {IERC1155Receiver-onERC1155Received}\n     *   or {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     *\n     * NOTE: The ERC-1155 acceptance check is not performed in this function. See {_updateWithAcceptanceCheck} instead.\n     */\n    function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual {\n        if (ids.length != values.length) {\n            revert ERC1155InvalidArrayLength(ids.length, values.length);\n        }\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids.unsafeMemoryAccess(i);\n            uint256 value = values.unsafeMemoryAccess(i);\n\n            if (from != address(0)) {\n                uint256 fromBalance = _balances[id][from];\n                if (fromBalance < value) {\n                    revert ERC1155InsufficientBalance(from, fromBalance, value, id);\n                }\n                unchecked {\n                    // Overflow not possible: value <= fromBalance\n                    _balances[id][from] = fromBalance - value;\n                }\n            }\n\n            if (to != address(0)) {\n                _balances[id][to] += value;\n            }\n        }\n\n        if (ids.length == 1) {\n            uint256 id = ids.unsafeMemoryAccess(0);\n            uint256 value = values.unsafeMemoryAccess(0);\n            emit TransferSingle(operator, from, to, id, value);\n        } else {\n            emit TransferBatch(operator, from, to, ids, values);\n        }\n    }\n\n    /**\n     * @dev Version of {_update} that performs the token acceptance check by calling\n     * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it\n     * contains code (eg. is a smart contract at the moment of execution).\n     *\n     * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any\n     * update to the contract state after this function would break the check-effect-interaction pattern. Consider\n     * overriding {_update} instead.\n     */\n    function _updateWithAcceptanceCheck(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal virtual {\n        _update(from, to, ids, values);\n        if (to != address(0)) {\n            address operator = _msgSender();\n            if (ids.length == 1) {\n                uint256 id = ids.unsafeMemoryAccess(0);\n                uint256 value = values.unsafeMemoryAccess(0);\n                ERC1155Utils.checkOnERC1155Received(operator, from, to, id, value, data);\n            } else {\n                ERC1155Utils.checkOnERC1155BatchReceived(operator, from, to, ids, values, data);\n            }\n        }\n    }\n\n    /**\n     * @dev Transfers a `value` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the ERC].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the values in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens of type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens of type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     */\n    function _burn(address from, uint256 id, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     * - `ids` and `values` must have the same length.\n     */\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC1155InvalidOperator(address(0));\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Creates an array in memory with only one value for each of the elements provided.\n     */\n    function _asSingletonArrays(\n        uint256 element1,\n        uint256 element2\n    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {\n        assembly (\"memory-safe\") {\n            // Load the free memory pointer\n            array1 := mload(0x40)\n            // Set array length to 1\n            mstore(array1, 1)\n            // Store the single element at the next word after the length (where content starts)\n            mstore(add(array1, 0x20), element1)\n\n            // Repeat for next array locating it right after the first array\n            array2 := add(array1, 0x40)\n            mstore(array2, 1)\n            mstore(add(array2, 0x20), element2)\n\n            // Update the free memory pointer by pointing after the second array\n            mstore(0x40, add(array2, 0x40))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC1155} from \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[ERC].\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC-1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC-1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/utils/ERC1155Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155Receiver} from \"../IERC1155Receiver.sol\";\nimport {IERC1155Errors} from \"../../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Library that provide common ERC-1155 utility functions.\n *\n * See https://eips.ethereum.org/EIPS/eip-1155[ERC-1155].\n *\n * _Available since v5.1._\n */\nlibrary ERC1155Utils {\n    /**\n     * @dev Performs an acceptance check for the provided `operator` by calling {IERC1155Receiver-onERC1155Received}\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\n     *\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\n     * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept\n     * the transfer.\n     */\n    function checkOnERC1155Received(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    // Tokens rejected\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-IERC1155Receiver implementer\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                } else {\n                    assembly (\"memory-safe\") {\n                        revert(add(reason, 0x20), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Performs a batch acceptance check for the provided `operator` by calling {IERC1155Receiver-onERC1155BatchReceived}\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\n     *\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\n     * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept\n     * the transfer.\n     */\n    function checkOnERC1155BatchReceived(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    // Tokens rejected\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-IERC1155Receiver implementer\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                } else {\n                    assembly (\"memory-safe\") {\n                        revert(add(reason, 0x20), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Arrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Arrays.sol)\n// This file was procedurally generated from scripts/generate/templates/Arrays.js.\n\npragma solidity ^0.8.20;\n\nimport {Comparators} from \"./Comparators.sol\";\nimport {SlotDerivation} from \"./SlotDerivation.sol\";\nimport {StorageSlot} from \"./StorageSlot.sol\";\nimport {Math} from \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    using SlotDerivation for bytes32;\n    using StorageSlot for bytes32;\n\n    /**\n     * @dev Sort an array of uint256 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        uint256[] memory array,\n        function(uint256, uint256) pure returns (bool) comp\n    ) internal pure returns (uint256[] memory) {\n        _quickSort(_begin(array), _end(array), comp);\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of uint256 in increasing order.\n     */\n    function sort(uint256[] memory array) internal pure returns (uint256[] memory) {\n        sort(array, Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of address (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        address[] memory array,\n        function(address, address) pure returns (bool) comp\n    ) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of address in increasing order.\n     */\n    function sort(address[] memory array) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of bytes32 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        bytes32[] memory array,\n        function(bytes32, bytes32) pure returns (bool) comp\n    ) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of bytes32 in increasing order.\n     */\n    function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Performs a quick sort of a segment of memory. The segment sorted starts at `begin` (inclusive), and stops\n     * at end (exclusive). Sorting follows the `comp` comparator.\n     *\n     * Invariant: `begin <= end`. This is the case when initially called by {sort} and is preserved in subcalls.\n     *\n     * IMPORTANT: Memory locations between `begin` and `end` are not validated/zeroed. This function should\n     * be used only if the limits are within a memory array.\n     */\n    function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private pure {\n        unchecked {\n            if (end - begin < 0x40) return;\n\n            // Use first element as pivot\n            uint256 pivot = _mload(begin);\n            // Position where the pivot should be at the end of the loop\n            uint256 pos = begin;\n\n            for (uint256 it = begin + 0x20; it < end; it += 0x20) {\n                if (comp(_mload(it), pivot)) {\n                    // If the value stored at the iterator's position comes before the pivot, we increment the\n                    // position of the pivot and move the value there.\n                    pos += 0x20;\n                    _swap(pos, it);\n                }\n            }\n\n            _swap(begin, pos); // Swap pivot into place\n            _quickSort(begin, pos, comp); // Sort the left side of the pivot\n            _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first element of `array`.\n     */\n    function _begin(uint256[] memory array) private pure returns (uint256 ptr) {\n        assembly (\"memory-safe\") {\n            ptr := add(array, 0x20)\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first memory word (32bytes) after `array`. This is the memory word\n     * that comes just after the last element of the array.\n     */\n    function _end(uint256[] memory array) private pure returns (uint256 ptr) {\n        unchecked {\n            return _begin(array) + array.length * 0x20;\n        }\n    }\n\n    /**\n     * @dev Load memory word (as a uint256) at location `ptr`.\n     */\n    function _mload(uint256 ptr) private pure returns (uint256 value) {\n        assembly {\n            value := mload(ptr)\n        }\n    }\n\n    /**\n     * @dev Swaps the elements memory location `ptr1` and `ptr2`.\n     */\n    function _swap(uint256 ptr1, uint256 ptr2) private pure {\n        assembly {\n            let value1 := mload(ptr1)\n            let value2 := mload(ptr2)\n            mstore(ptr1, value2)\n            mstore(ptr2, value1)\n        }\n    }\n\n    /// @dev Helper: low level cast address memory array to uint256 memory array\n    function _castToUint256Array(address[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 memory array to uint256 memory array\n    function _castToUint256Array(bytes32[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast address comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(address, address) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(bytes32, bytes32) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * NOTE: The `array` is expected to be sorted in ascending order, and to\n     * contain no repeated elements.\n     *\n     * IMPORTANT: Deprecated. This implementation behaves as {lowerBound} but lacks\n     * support for repeated elements in the array. The {lowerBound} function should\n     * be used instead.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value greater or equal than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/lower_bound[lower_bound].\n     */\n    function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value strictly greater than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/upper_bound[upper_bound].\n     */\n    function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {lowerBound}, but with an array in memory.\n     */\n    function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {upperBound}, but with an array in memory.\n     */\n    function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getUint256Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes[] storage arr, uint256 pos) internal pure returns (StorageSlot.BytesSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getBytesSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(string[] storage arr, uint256 pos) internal pure returns (StorageSlot.StringSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getStringSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(bytes[] memory arr, uint256 pos) internal pure returns (bytes memory res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(string[] memory arr, uint256 pos) internal pure returns (string memory res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(address[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(bytes32[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(uint256[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(bytes[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(string[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Comparators.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Comparators.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to compare values.\n *\n * _Available since v5.1._\n */\nlibrary Comparators {\n    function lt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a < b;\n    }\n\n    function gt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a > b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Create2.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev There's no code to deploy.\n     */\n    error Create2EmptyBytecode();\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        assembly (\"memory-safe\") {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n            // if no address was created, and returndata is not empty, bubble revert\n            if and(iszero(addr), not(iszero(returndatasize()))) {\n                let p := mload(0x40)\n                returndatacopy(p, 0, returndatasize())\n                revert(p, returndatasize())\n            }\n        }\n        if (addr == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := and(keccak256(start, 85), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/SlotDerivation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/SlotDerivation.sol)\n// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots\n * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by\n * the solidity language / compiler.\n *\n * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].\n *\n * Example usage:\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using StorageSlot for bytes32;\n *     using SlotDerivation for bytes32;\n *\n *     // Declare a namespace\n *     string private constant _NAMESPACE = \"<namespace>\"; // eg. OpenZeppelin.Slot\n *\n *     function setValueInNamespace(uint256 key, address newValue) internal {\n *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;\n *     }\n *\n *     function getValueInNamespace(uint256 key) internal view returns (address) {\n *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {StorageSlot}.\n *\n * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking\n * upgrade safety will ignore the slots accessed through this library.\n *\n * _Available since v5.1._\n */\nlibrary SlotDerivation {\n    /**\n     * @dev Derive an ERC-7201 slot from a string (namespace).\n     */\n    function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))\n            slot := and(keccak256(0x00, 0x20), not(0xff))\n        }\n    }\n\n    /**\n     * @dev Add an offset to a slot to get the n-th element of a structure or an array.\n     */\n    function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {\n        unchecked {\n            return bytes32(uint256(slot) + pos);\n        }\n    }\n\n    /**\n     * @dev Derive the location of the first element in an array from the slot where the length is stored.\n     */\n    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, slot)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, and(key, shr(96, not(0))))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, iszero(iszero(key)))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\n        (1 << 0x08) | // backspace\n            (1 << 0x09) | // tab\n            (1 << 0x0a) | // newline\n            (1 << 0x0c) | // form feed\n            (1 << 0x0d) | // carriage return\n            (1 << 0x22) | // double quote\n            (1 << 0x5c); // backslash\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(add(buffer, 0x20), length)\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress-string} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\n     *\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\n     *\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\n     * characters that are not in this range, but other tooling may provide different results.\n     */\n    function escapeJSON(string memory input) internal pure returns (string memory) {\n        bytes memory buffer = bytes(input);\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\n        uint256 outputLength = 0;\n\n        for (uint256 i; i < buffer.length; ++i) {\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\n                output[outputLength++] = \"\\\\\";\n                if (char == 0x08) output[outputLength++] = \"b\";\n                else if (char == 0x09) output[outputLength++] = \"t\";\n                else if (char == 0x0a) output[outputLength++] = \"n\";\n                else if (char == 0x0c) output[outputLength++] = \"f\";\n                else if (char == 0x0d) output[outputLength++] = \"r\";\n                else if (char == 0x5c) output[outputLength++] = \"\\\\\";\n                else if (char == 0x22) {\n                    // solhint-disable-next-line quotes\n                    output[outputLength++] = '\"';\n                }\n            } else {\n                output[outputLength++] = char;\n            }\n        }\n        // write the actual length and deallocate unused memory\n        assembly (\"memory-safe\") {\n            mstore(output, outputLength)\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\n        }\n\n        return string(output);\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }\n}\n"
    },
    "contracts/ConditionalMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"./ETCSwapV3Integration.sol\";\nimport \"./TieredRoleManager.sol\";\nimport \"./CTF1155.sol\";\n\n/**\n * @title ConditionalMarketFactory\n * @notice Automated deployment of pass-fail market pairs using Gnosis CTF standards\n * @dev Creates conditional prediction markets for proposals with role-based access control\n * \n * For a practical walkthrough of how this contract works, see:\n * docs/user-guide/conditional-market-rain-example.md\n * \n * TRADING INTEGRATION:\n * This contract now integrates with ETC Swap v3 contracts for production-ready DEX trading.\n * The integration uses ETCSwapV3Integration contract for:\n * - Pool creation and initialization\n * - Liquidity provision and management\n * - Token swapping with slippage protection\n * \n * Integration approach:\n * 1. ConditionalMarketFactory creates PASS/FAIL token pairs\n * 2. ETCSwapV3Integration creates pools for PASS/collateral and FAIL/collateral trading pairs\n * 3. Liquidity is provided to ETC Swap pools through the integration layer\n * 4. Users trade through ETC Swap's battle-tested DEX infrastructure\n * 5. ConditionalMarketFactory handles final settlement based on oracle outcomes\n * \n * Trading modes:\n * - ETCSwap mode: Full decentralized trading via Uniswap v3 pools\n * - Fallback mode: Simplified LMSR for testing and backwards compatibility\n * \n * RBAC INTEGRATION:\n * - Market creation requires MARKET_MAKER_ROLE\n * - Admin functions require OPERATIONS_ADMIN_ROLE\n * - Tier limits enforced on market creation and trading\n */\ncontract ConditionalMarketFactory is Ownable, ReentrancyGuard, IERC1155Receiver {\n    using SafeERC20 for IERC20;\n    \n    /**\n     * @notice Enum defining different types of binary outcomes for prediction markets\n     * @dev Each bet type represents a different way to frame binary predictions\n     */\n    enum BetType {\n        YesNo,          // Standard Yes / No outcome\n        PassFail,       // Pass / Fail outcome (default for governance)\n        AboveBelow,     // Above / Below a threshold\n        HigherLower,    // Higher / Lower than reference\n        InOut,          // In / Out of range\n        OverUnder,      // Over / Under a value\n        ForAgainst,     // For / Against a proposal\n        TrueFalse,      // True / False statement\n        WinLose,        // Win / Lose outcome\n        UpDown          // Up / Down movement\n    }\n\n    struct Market {\n        uint256 proposalId;\n        address passToken;\n        address failToken;\n        address collateralToken;\n        uint256 tradingEndTime;\n        uint256 liquidityParameter; // Beta parameter for LMSR\n        uint256 totalLiquidity;\n        bool resolved;\n        uint256 passValue;\n        uint256 failValue;\n        MarketStatus status;\n        BetType betType;\n        bool useCTF;               // Whether this market uses CTF1155\n        bytes32 conditionId;       // CTF condition ID (if using CTF)\n        bytes32 questionId;        // CTF question ID (if using CTF)\n        uint256 passPositionId;    // CTF position ID for pass outcome\n        uint256 failPositionId;    // CTF position ID for fail outcome\n    }\n\n    enum MarketStatus {\n        Active,\n        TradingEnded,\n        Resolved,\n        Cancelled\n    }\n\n    // Market ID => Market\n    mapping(uint256 => Market) public markets;\n    \n    // Proposal ID => Market ID (marketId + 1 to avoid 0 confusion)\n    mapping(uint256 => uint256) private _proposalToMarketPlusOne;\n    \n    // Market status tracking for efficient querying\n    mapping(MarketStatus => uint256[]) private marketsByStatus;\n    \n    // Time-based indexing (day => market IDs)\n    mapping(uint256 => uint256[]) private marketsByDay;\n    \n    uint256 public marketCount;\n    uint256 public constant DEFAULT_TRADING_PERIOD = 10 days;\n    uint256 public constant MIN_TRADING_PERIOD = 7 days;\n    uint256 public constant MAX_TRADING_PERIOD = 21 days;\n    uint256 public constant MAX_BATCH_SIZE = 50;\n\n    bool private _initialized;\n    \n    // ETCSwap v3 integration\n    ETCSwapV3Integration public etcSwapIntegration;\n    bool public useETCSwap;\n    \n    // Role-based access control\n    TieredRoleManager public roleManager;\n    \n    // CTF1155 integration - now required for all markets\n    CTF1155 public ctf1155;\n    \n    // Default initial price for pools (0.5 = equal probability)\n    uint160 public constant DEFAULT_INITIAL_SQRT_PRICE = 79228162514264337593543950336; // sqrt(0.5) in Q64.96\n\n    // Enhanced events for better indexing and market discovery\n    event MarketCreated(\n        uint256 indexed marketId,\n        uint256 indexed proposalId,\n        address indexed collateralToken,\n        address passToken,\n        address failToken,\n        uint256 tradingEndTime,\n        uint256 liquidityParameter,\n        uint256 createdAt,\n        address creator,\n        BetType betType\n    );\n    \n    event TokensPurchased(\n        uint256 indexed marketId,\n        address indexed buyer,\n        bool indexed buyPass,\n        uint256 collateralAmount,\n        uint256 tokenAmount\n    );\n    \n    event TokensSold(\n        uint256 indexed marketId,\n        address indexed seller,\n        bool indexed sellPass,\n        uint256 tokenAmount,\n        uint256 collateralAmount\n    );\n    \n    event MarketStatusChanged(\n        uint256 indexed marketId,\n        MarketStatus indexed previousStatus,\n        MarketStatus indexed newStatus,\n        uint256 changedAt\n    );\n    \n    event MarketResolved(\n        uint256 indexed marketId,\n        uint256 indexed proposalId,\n        uint256 passValue,\n        uint256 failValue,\n        bool indexed approved,\n        uint256 resolvedAt\n    );\n    \n    event MarketCancelled(\n        uint256 indexed marketId,\n        uint256 indexed proposalId,\n        string reason,\n        uint256 cancelledAt\n    );\n    \n    event BatchMarketsCreated(\n        uint256[] marketIds,\n        uint256 batchTimestamp,\n        uint256 totalMarketsCreated\n    );\n    \n    event BatchMarketsResolved(\n        uint256[] marketIds,\n        uint256 batchTimestamp,\n        uint256 totalMarketsResolved\n    );\n    \n    event ETCSwapIntegrationUpdated(address indexed integration, bool enabled);\n    \n    event ETCSwapPoolsCreated(\n        uint256 indexed marketId,\n        address indexed passPool,\n        address indexed failPool\n    );\n    \n    event CTF1155Updated(address indexed ctf1155);\n    \n    event CTFMarketCreated(\n        uint256 indexed marketId,\n        bytes32 indexed conditionId,\n        uint256 passPositionId,\n        uint256 failPositionId\n    );\n\n    constructor() Ownable(msg.sender) {}\n    \n    /**\n     * @notice Set the role manager contract\n     * @param _roleManager Address of TieredRoleManager contract\n     */\n    function setRoleManager(address _roleManager) external onlyOwner {\n        require(_roleManager != address(0), \"Invalid role manager address\");\n        require(address(roleManager) == address(0), \"Role manager already set\");\n        roleManager = TieredRoleManager(_roleManager);\n    }\n    \n    /**\n     * @notice Modifier to check if user has MARKET_MAKER_ROLE\n     */\n    modifier onlyMarketMaker() {\n        require(address(roleManager) != address(0), \"Role manager not set\");\n        require(roleManager.hasRole(roleManager.MARKET_MAKER_ROLE(), msg.sender), \"Requires MARKET_MAKER_ROLE\");\n        _;\n    }\n    \n    /**\n     * @notice Modifier to check market creation limits for tiered members\n     */\n    modifier checkMarketCreationLimit() {\n        if (address(roleManager) != address(0) && roleManager.hasRole(roleManager.MARKET_MAKER_ROLE(), msg.sender)) {\n            require(roleManager.checkMarketCreationLimitFor(msg.sender, roleManager.MARKET_MAKER_ROLE()), \"Market creation limit exceeded\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Get outcome labels for a specific bet type\n     * @param betType The type of bet\n     * @return positiveOutcome Label for the positive outcome token\n     * @return negativeOutcome Label for the negative outcome token\n     */\n    function getOutcomeLabels(BetType betType) public pure returns (string memory positiveOutcome, string memory negativeOutcome) {\n        if (betType == BetType.YesNo) {\n            return (\"YES\", \"NO\");\n        } else if (betType == BetType.PassFail) {\n            return (\"PASS\", \"FAIL\");\n        } else if (betType == BetType.AboveBelow) {\n            return (\"ABOVE\", \"BELOW\");\n        } else if (betType == BetType.HigherLower) {\n            return (\"HIGHER\", \"LOWER\");\n        } else if (betType == BetType.InOut) {\n            return (\"IN\", \"OUT\");\n        } else if (betType == BetType.OverUnder) {\n            return (\"OVER\", \"UNDER\");\n        } else if (betType == BetType.ForAgainst) {\n            return (\"FOR\", \"AGAINST\");\n        } else if (betType == BetType.TrueFalse) {\n            return (\"TRUE\", \"FALSE\");\n        } else if (betType == BetType.WinLose) {\n            return (\"WIN\", \"LOSE\");\n        } else if (betType == BetType.UpDown) {\n            return (\"UP\", \"DOWN\");\n        }\n        return (\"PASS\", \"FAIL\"); // Default fallback\n    }\n\n    /**\n     * @notice Initialize the contract (used for clones)\n     * @param initialOwner Address of the initial owner\n     */\n    function initialize(address initialOwner) external {\n        require(!_initialized, \"Already initialized\");\n        require(initialOwner != address(0), \"Invalid owner\");\n        _initialized = true;\n        _transferOwnership(initialOwner);\n    }\n    \n    /**\n     * @notice Set ETCSwap v3 integration contract\n     * @param _integration Address of ETCSwapV3Integration contract\n     * @param _enabled Whether to enable ETCSwap trading\n     */\n    function setETCSwapIntegration(address _integration, bool _enabled) external onlyOwner {\n        require(_integration != address(0), \"Invalid integration address\");\n        etcSwapIntegration = ETCSwapV3Integration(_integration);\n        useETCSwap = _enabled;\n        emit ETCSwapIntegrationUpdated(_integration, _enabled);\n    }\n    \n    /**\n     * @notice Set CTF1155 contract (required for market creation)\n     * @param _ctf1155 Address of CTF1155 contract\n     */\n    function setCTF1155(address _ctf1155) external onlyOwner {\n        require(_ctf1155 != address(0), \"Invalid CTF1155 address\");\n        ctf1155 = CTF1155(_ctf1155);\n        emit CTF1155Updated(_ctf1155);\n    }\n    \n    /**\n     * @notice Create ETCSwap pools for an existing market\n     * @param marketId ID of the market\n     * @param initialSqrtPriceX96 Initial price for pools (Q64.96 format)\n     * @param fee Fee tier to use (500, 3000, or 10000)\n     */\n    function createETCSwapPools(\n        uint256 marketId,\n        uint160 initialSqrtPriceX96,\n        uint24 fee\n    ) external onlyOwner {\n        require(marketId < marketCount, \"Invalid market ID\");\n        require(address(etcSwapIntegration) != address(0), \"ETCSwap integration not set\");\n        \n        Market storage market = markets[marketId];\n        \n        (address passPool, address failPool) = etcSwapIntegration.createMarketPools(\n            marketId,\n            market.passToken,\n            market.failToken,\n            market.collateralToken,\n            fee,\n            initialSqrtPriceX96\n        );\n        \n        emit ETCSwapPoolsCreated(marketId, passPool, failPool);\n    }\n\n    /**\n     * @notice Deploy a market pair for a proposal using CTF1155\n     * @param proposalId ID of the proposal\n     * @param collateralToken Address of collateral token (must be ERC20, not address(0))\n     * @param liquidityAmount Initial liquidity amount\n     * @param liquidityParameter Beta parameter for LMSR (higher = more liquidity)\n     * @param tradingPeriod Trading period in seconds\n     * @param betType Type of binary bet (YesNo, PassFail, AboveBelow, etc.)\n     * @return marketId ID of the created market\n     */\n    function deployMarketPair(\n        uint256 proposalId,\n        address collateralToken,\n        uint256 liquidityAmount,\n        uint256 liquidityParameter,\n        uint256 tradingPeriod,\n        BetType betType\n    ) external checkMarketCreationLimit returns (uint256 marketId) {\n        // Allow either owner or market maker role\n        require(\n            msg.sender == owner() || \n            (address(roleManager) != address(0) && roleManager.hasRole(roleManager.MARKET_MAKER_ROLE(), msg.sender)),\n            \"Requires owner or MARKET_MAKER_ROLE\"\n        );\n        require(_proposalToMarketPlusOne[proposalId] == 0, \"Market already exists\");\n        require(tradingPeriod >= MIN_TRADING_PERIOD && tradingPeriod <= MAX_TRADING_PERIOD, \"Invalid trading period\");\n        require(address(ctf1155) != address(0), \"CTF1155 not set\");\n        require(collateralToken != address(0), \"CTF requires ERC20 collateral\");\n\n        marketId = marketCount++;\n\n        // Generate unique question ID for this market\n        bytes32 questionId = keccak256(abi.encodePacked(\"market\", marketId, proposalId, block.timestamp));\n        \n        // Prepare condition with 2 outcomes (binary)\n        bytes32 conditionId = ctf1155.prepareCondition(address(this), questionId, 2);\n        \n        // Calculate position IDs for pass (index 1) and fail (index 2) outcomes\n        bytes32 passCollectionId = ctf1155.getCollectionId(bytes32(0), conditionId, 1);\n        bytes32 failCollectionId = ctf1155.getCollectionId(bytes32(0), conditionId, 2);\n        \n        uint256 passPositionId = ctf1155.getPositionId(IERC20(collateralToken), passCollectionId);\n        uint256 failPositionId = ctf1155.getPositionId(IERC20(collateralToken), failCollectionId);\n        \n        // Store CTF1155 address in passToken and failToken for compatibility\n        address ctfAddress = address(ctf1155);\n\n        markets[marketId] = Market({\n            proposalId: proposalId,\n            passToken: ctfAddress,\n            failToken: ctfAddress,\n            collateralToken: collateralToken,\n            tradingEndTime: block.timestamp + tradingPeriod,\n            liquidityParameter: liquidityParameter,\n            totalLiquidity: liquidityAmount,\n            resolved: false,\n            passValue: 0,\n            failValue: 0,\n            status: MarketStatus.Active,\n            betType: betType,\n            useCTF: true,\n            conditionId: conditionId,\n            questionId: questionId,\n            passPositionId: passPositionId,\n            failPositionId: failPositionId\n        });\n\n        _proposalToMarketPlusOne[proposalId] = marketId + 1;\n        \n        // Update indexes\n        _updateMarketIndex(marketId, MarketStatus.Active);\n\n        emit MarketCreated(\n            marketId,\n            proposalId,\n            collateralToken,\n            ctfAddress,\n            ctfAddress,\n            markets[marketId].tradingEndTime,\n            liquidityParameter,\n            block.timestamp,\n            msg.sender,\n            betType\n        );\n        \n        emit CTFMarketCreated(marketId, conditionId, passPositionId, failPositionId);\n    }\n    \n    /**\n     * @notice Batch deploy multiple market pairs for efficiency\n     * @param params Array of market creation parameters\n     * @return marketIds Array of created market IDs\n     */\n    function batchDeployMarkets(\n        MarketCreationParams[] calldata params\n    ) external checkMarketCreationLimit returns (uint256[] memory marketIds) {\n        // Allow either owner or market maker role\n        require(\n            msg.sender == owner() || \n            (address(roleManager) != address(0) && roleManager.hasRole(roleManager.MARKET_MAKER_ROLE(), msg.sender)),\n            \"Requires owner or MARKET_MAKER_ROLE\"\n        );\n        require(params.length > 0, \"Empty batch\");\n        require(params.length <= MAX_BATCH_SIZE, \"Batch too large\");\n        \n        marketIds = new uint256[](params.length);\n        \n        for (uint256 i = 0; i < params.length; ) {\n            require(_proposalToMarketPlusOne[params[i].proposalId] == 0, \"Market already exists\");\n            require(\n                params[i].tradingPeriod >= MIN_TRADING_PERIOD && \n                params[i].tradingPeriod <= MAX_TRADING_PERIOD,\n                \"Invalid trading period\"\n            );\n            require(address(ctf1155) != address(0), \"CTF1155 not set\");\n            require(params[i].collateralToken != address(0), \"CTF requires ERC20 collateral\");\n            \n            uint256 marketId = marketCount++;\n            marketIds[i] = marketId;\n            \n            // Generate unique question ID for this market\n            bytes32 questionId = keccak256(abi.encodePacked(\"market\", marketId, params[i].proposalId, block.timestamp, i));\n            \n            // Prepare condition with 2 outcomes (binary)\n            bytes32 conditionId = ctf1155.prepareCondition(address(this), questionId, 2);\n            \n            // Calculate position IDs for pass (index 1) and fail (index 2) outcomes\n            bytes32 passCollectionId = ctf1155.getCollectionId(bytes32(0), conditionId, 1);\n            bytes32 failCollectionId = ctf1155.getCollectionId(bytes32(0), conditionId, 2);\n            \n            uint256 passPositionId = ctf1155.getPositionId(IERC20(params[i].collateralToken), passCollectionId);\n            uint256 failPositionId = ctf1155.getPositionId(IERC20(params[i].collateralToken), failCollectionId);\n            \n            // Store CTF1155 address in passToken and failToken for compatibility\n            address ctfAddress = address(ctf1155);\n            \n            markets[marketId] = Market({\n                proposalId: params[i].proposalId,\n                passToken: ctfAddress,\n                failToken: ctfAddress,\n                collateralToken: params[i].collateralToken,\n                tradingEndTime: block.timestamp + params[i].tradingPeriod,\n                liquidityParameter: params[i].liquidityParameter,\n                totalLiquidity: params[i].liquidityAmount,\n                resolved: false,\n                passValue: 0,\n                failValue: 0,\n                status: MarketStatus.Active,\n                betType: params[i].betType,\n                useCTF: true,\n                conditionId: conditionId,\n                questionId: questionId,\n                passPositionId: passPositionId,\n                failPositionId: failPositionId\n            });\n            \n            _proposalToMarketPlusOne[params[i].proposalId] = marketId + 1;\n            \n            // Update indexes\n            _updateMarketIndex(marketId, MarketStatus.Active);\n            \n            emit MarketCreated(\n                marketId,\n                params[i].proposalId,\n                params[i].collateralToken,\n                ctfAddress,\n                ctfAddress,\n                markets[marketId].tradingEndTime,\n                params[i].liquidityParameter,\n                block.timestamp,\n                msg.sender,\n                params[i].betType\n            );\n            \n            emit CTFMarketCreated(marketId, conditionId, passPositionId, failPositionId);\n            \n            unchecked { ++i; }\n        }\n        \n        emit BatchMarketsCreated(marketIds, block.timestamp, params.length);\n    }\n\n    /**\n     * @notice Buy outcome tokens via ETCSwap or fallback LMSR\n     * @dev Integrates with ETC Swap v3 when enabled, falls back to simplified LMSR for testing\n     * @param marketId ID of the market\n     * @param buyPass True to buy PASS tokens, false for FAIL tokens\n     * @param amount Amount of collateral to spend\n     * @return tokenAmount Amount of outcome tokens received\n     */\n    function buyTokens(\n        uint256 marketId,\n        bool buyPass,\n        uint256 amount\n    ) external payable nonReentrant returns (uint256 tokenAmount) {\n        require(marketId < marketCount, \"Invalid market ID\");\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.Active, \"Market not active\");\n        require(block.timestamp < market.tradingEndTime, \"Trading period ended\");\n        require(amount > 0, \"Amount must be positive\");\n\n        if (useETCSwap && address(etcSwapIntegration) != address(0)) {\n            // Use ETCSwap v3 for actual DEX trading with ERC20 collateral\n            address outcomeToken = buyPass ? market.passToken : market.failToken;\n            \n            // When using ETCSwap, collateral must be an ERC20 token\n            require(market.collateralToken != address(0), \"ETCSwap requires ERC20 collateral\");\n            require(msg.value == 0, \"Send collateral tokens, not ETH\");\n            \n            // Transfer collateral from buyer to this contract\n            IERC20(market.collateralToken).safeTransferFrom(msg.sender, address(this), amount);\n            \n            // Approve ETCSwap integration to spend collateral\n            IERC20(market.collateralToken).approve(address(etcSwapIntegration), amount);\n            \n            // Calculate minimum output with slippage protection\n            // Use quoter to estimate output and apply default slippage tolerance\n            try etcSwapIntegration.quoteBuyTokens(marketId, buyPass, amount) returns (uint256 estimatedOutput) {\n                // Apply more conservative slippage tolerance (10% for testing with mocks)\n                uint256 minTokenAmount = etcSwapIntegration.calculateMinOutput(estimatedOutput, 1000);\n                \n                // Execute swap with slippage protection\n                ETCSwapV3Integration.SwapResult memory result = etcSwapIntegration.buyTokens(\n                    marketId,\n                    market.collateralToken,\n                    outcomeToken,\n                    amount,\n                    minTokenAmount,\n                    block.timestamp + 300 // 5 minute deadline\n                );\n                \n                tokenAmount = result.amountOut;\n                \n                // Transfer purchased tokens from this contract to the buyer\n                // (ETCSwap sends tokens to this contract, we forward to buyer)\n                IERC20(outcomeToken).safeTransfer(msg.sender, tokenAmount);\n            } catch {\n                // If quote fails, use conservative minimum (allow up to 20% slippage for edge cases)\n                uint256 minTokenAmount = (amount * 80) / 100;\n                \n                ETCSwapV3Integration.SwapResult memory result = etcSwapIntegration.buyTokens(\n                    marketId,\n                    market.collateralToken,\n                    outcomeToken,\n                    amount,\n                    minTokenAmount,\n                    block.timestamp + 300\n                );\n                \n                tokenAmount = result.amountOut;\n                \n                // Transfer purchased tokens from this contract to the buyer\n                IERC20(outcomeToken).safeTransfer(msg.sender, tokenAmount);\n            }\n        } else {\n            // Fallback: Use CTF1155 to split collateral into position tokens\n            // With CTF1155, all markets require ERC20 collateral\n            require(market.collateralToken != address(0), \"CTF requires ERC20 collateral\");\n            require(msg.value == 0, \"Send collateral tokens, not ETH\");\n            \n            // Transfer collateral from buyer to this contract\n            IERC20(market.collateralToken).safeTransferFrom(msg.sender, address(this), amount);\n            \n            // Approve CTF1155 to spend collateral\n            IERC20(market.collateralToken).approve(address(ctf1155), amount);\n            \n            // Split collateral into BOTH position tokens (binary market)\n            // CTF1155 requires partition with at least 2 elements\n            // For binary conditions: index set 1 = outcome 0, index set 2 = outcome 1\n            uint256[] memory partition = new uint256[](2);\n            partition[0] = 1; // PASS outcome index set\n            partition[1] = 2; // FAIL outcome index set\n            \n            ctf1155.splitPosition(\n                IERC20(market.collateralToken),\n                bytes32(0), // parentCollectionId (root level)\n                market.conditionId,\n                partition,\n                amount\n            );\n            \n            // Calculate output tokens (1:1 with collateral for split)\n            tokenAmount = amount;\n            \n            // Transfer the requested position tokens to buyer\n            // CTF splits to this contract, so we transfer the desired position to buyer\n            ctf1155.safeTransferFrom(\n                address(this),\n                msg.sender,\n                buyPass ? market.passPositionId : market.failPositionId,\n                tokenAmount,\n                \"\"\n            );\n            \n            // Store the other position tokens in this contract for later merging/redemption\n            // (They stay in this contract's balance)\n            \n            // Update market liquidity\n            market.totalLiquidity += amount;\n        }\n        \n        emit TokensPurchased(marketId, msg.sender, buyPass, amount, tokenAmount);\n    }\n    \n    /**\n     * @notice Sell outcome tokens via ETCSwap or fallback LMSR\n     * @dev Integrates with ETC Swap v3 when enabled, falls back to simplified LMSR for testing\n     * @param marketId ID of the market\n     * @param sellPass True to sell PASS tokens, false for FAIL tokens\n     * @param tokenAmount Amount of tokens to sell\n     * @return collateralAmount Amount of collateral received\n     */\n    function sellTokens(\n        uint256 marketId,\n        bool sellPass,\n        uint256 tokenAmount\n    ) external nonReentrant returns (uint256 collateralAmount) {\n        require(marketId < marketCount, \"Invalid market ID\");\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.Active, \"Market not active\");\n        require(block.timestamp < market.tradingEndTime, \"Trading period ended\");\n        require(tokenAmount > 0, \"Amount must be positive\");\n\n        if (useETCSwap && address(etcSwapIntegration) != address(0)) {\n            // Use ETCSwap v3 for actual DEX trading with ERC20 collateral\n            address outcomeToken = sellPass ? market.passToken : market.failToken;\n            \n            // When using ETCSwap, collateral must be an ERC20 token\n            require(market.collateralToken != address(0), \"ETCSwap requires ERC20 collateral\");\n            \n            // Transfer tokens from seller to this contract\n            IERC20(outcomeToken).safeTransferFrom(msg.sender, address(this), tokenAmount);\n            \n            // Approve ETCSwap integration to spend outcome tokens\n            IERC20(outcomeToken).approve(address(etcSwapIntegration), tokenAmount);\n            \n            // Calculate minimum output with slippage protection\n            // Use quoter to estimate output and apply default slippage tolerance\n            try etcSwapIntegration.quoteSellTokens(marketId, sellPass, tokenAmount) returns (uint256 estimatedOutput) {\n                // Apply more conservative slippage tolerance (10% for testing with mocks)\n                uint256 minCollateralAmount = etcSwapIntegration.calculateMinOutput(estimatedOutput, 1000);\n                \n                // Execute swap with slippage protection\n                ETCSwapV3Integration.SwapResult memory result = etcSwapIntegration.sellTokens(\n                    marketId,\n                    outcomeToken,\n                    market.collateralToken,\n                    tokenAmount,\n                    minCollateralAmount,\n                    block.timestamp + 300 // 5 minute deadline\n                );\n                \n                collateralAmount = result.amountOut;\n            } catch {\n                // If quote fails, use conservative minimum (allow up to 20% slippage for edge cases)\n                uint256 minCollateralAmount = (tokenAmount * 80) / 100;\n                \n                ETCSwapV3Integration.SwapResult memory result = etcSwapIntegration.sellTokens(\n                    marketId,\n                    outcomeToken,\n                    market.collateralToken,\n                    tokenAmount,\n                    minCollateralAmount,\n                    block.timestamp + 300\n                );\n                \n                collateralAmount = result.amountOut;\n            }\n            \n            // Transfer collateral to seller\n            IERC20(market.collateralToken).safeTransfer(msg.sender, collateralAmount);\n        } else {\n            // Fallback: Use CTF1155 to merge position tokens back to collateral\n            // With CTF1155, all markets require ERC20 collateral\n            require(market.collateralToken != address(0), \"CTF requires ERC20 collateral\");\n            \n            // For selling, user must have BOTH position tokens to merge back to collateral\n            // This is a simplified version - in production, you'd implement a proper AMM\n            // For now, we require the contract to hold the opposite position\n            uint256 oppositePositionId = sellPass ? market.failPositionId : market.passPositionId;\n            uint256 oppositeBalance = ctf1155.balanceOf(address(this), oppositePositionId);\n            \n            require(oppositeBalance >= tokenAmount, \"Insufficient opposite position for merge\");\n            \n            // Transfer the position tokens being sold from user to this contract\n            ctf1155.safeTransferFrom(\n                msg.sender,\n                address(this),\n                sellPass ? market.passPositionId : market.failPositionId,\n                tokenAmount,\n                \"\"\n            );\n            \n            // Merge both positions back to collateral\n            // CTF1155 requires partition with at least 2 elements\n            // For binary conditions: index set 1 = outcome 0, index set 2 = outcome 1\n            uint256[] memory partition = new uint256[](2);\n            partition[0] = 1; // PASS outcome index set\n            partition[1] = 2; // FAIL outcome index set\n            \n            ctf1155.mergePositions(\n                IERC20(market.collateralToken),\n                bytes32(0), // parentCollectionId (root level)\n                market.conditionId,\n                partition,\n                tokenAmount\n            );\n            \n            // Calculate collateral amount (1:1 for merge)\n            collateralAmount = tokenAmount;\n            \n            // Transfer collateral back to seller\n            IERC20(market.collateralToken).safeTransfer(msg.sender, collateralAmount);\n            \n            // Update market liquidity\n            require(collateralAmount <= market.totalLiquidity, \"Insufficient liquidity\");\n            market.totalLiquidity -= collateralAmount;\n        }\n        \n        emit TokensSold(marketId, msg.sender, sellPass, tokenAmount, collateralAmount);\n    }\n\n    /**\n     * @notice End trading for a market\n     * @param marketId ID of the market\n     */\n    function endTrading(uint256 marketId) external onlyOwner {\n        require(marketId < marketCount, \"Invalid market ID\");\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.Active, \"Market not active\");\n        require(block.timestamp >= market.tradingEndTime, \"Trading period not ended\");\n\n        MarketStatus oldStatus = market.status;\n        market.status = MarketStatus.TradingEnded;\n        _updateMarketIndex(marketId, MarketStatus.TradingEnded);\n        \n        emit MarketStatusChanged(marketId, oldStatus, MarketStatus.TradingEnded, block.timestamp);\n    }\n\n    /**\n     * @notice Resolve a market with welfare metric values and report to CTF1155\n     * @param marketId ID of the market\n     * @param passValue Welfare metric value if proposal passes\n     * @param failValue Welfare metric value if proposal fails\n     */\n    function resolveMarket(\n        uint256 marketId,\n        uint256 passValue,\n        uint256 failValue\n    ) external onlyOwner nonReentrant {\n        require(marketId < marketCount, \"Invalid market ID\");\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.TradingEnded, \"Trading not ended\");\n        require(!market.resolved, \"Already resolved\");\n\n        market.resolved = true;\n        market.passValue = passValue;\n        market.failValue = failValue;\n        MarketStatus oldStatus = market.status;\n        market.status = MarketStatus.Resolved;\n        _updateMarketIndex(marketId, MarketStatus.Resolved);\n        \n        // Report payouts to CTF1155\n        if (market.useCTF) {\n            // Calculate payout numerators based on welfare metric values\n            uint256[] memory payouts = new uint256[](2);\n            \n            // Determine winner and set payouts\n            if (passValue > failValue) {\n                // Pass wins - full payout to pass (index 0), zero to fail (index 1)\n                payouts[0] = 1;\n                payouts[1] = 0;\n            } else if (failValue > passValue) {\n                // Fail wins - zero to pass (index 0), full payout to fail (index 1)\n                payouts[0] = 0;\n                payouts[1] = 1;\n            } else {\n                // Tie - equal payout to both\n                payouts[0] = 1;\n                payouts[1] = 1;\n            }\n            \n            // Report payouts to CTF1155 as the oracle (this contract)\n            ctf1155.reportPayouts(market.questionId, payouts);\n        }\n\n        emit MarketResolved(\n            marketId,\n            market.proposalId,\n            passValue,\n            failValue,\n            passValue > failValue,\n            block.timestamp\n        );\n        emit MarketStatusChanged(marketId, oldStatus, MarketStatus.Resolved, block.timestamp);\n    }\n    \n    /**\n     * @notice Batch resolve multiple markets for efficiency\n     * @param params Array of market resolution parameters\n     * @return results Array indicating success/failure for each resolution\n     */\n    function batchResolveMarkets(\n        MarketResolutionParams[] calldata params\n    ) external onlyOwner nonReentrant returns (bool[] memory results) {\n        require(params.length > 0, \"Empty batch\");\n        require(params.length <= MAX_BATCH_SIZE, \"Batch too large\");\n        \n        results = new bool[](params.length);\n        uint256[] memory resolvedIds = new uint256[](params.length);\n        uint256 successCount = 0;\n        \n        for (uint256 i = 0; i < params.length; ) {\n            uint256 marketId = params[i].marketId;\n            \n            // Validate market\n            if (marketId >= marketCount) {\n                results[i] = false;\n                unchecked { ++i; }\n                continue;\n            }\n            \n            Market storage market = markets[marketId];\n            \n            if (market.status != MarketStatus.TradingEnded || market.resolved) {\n                results[i] = false;\n                unchecked { ++i; }\n                continue;\n            }\n            \n            // Resolve market\n            market.resolved = true;\n            market.passValue = params[i].passValue;\n            market.failValue = params[i].failValue;\n            MarketStatus oldStatus = market.status;\n            market.status = MarketStatus.Resolved;\n            _updateMarketIndex(marketId, MarketStatus.Resolved);\n            \n            // Report payouts to CTF1155\n            if (market.useCTF) {\n                uint256[] memory payouts = new uint256[](2);\n                \n                if (params[i].passValue > params[i].failValue) {\n                    payouts[0] = 1;\n                    payouts[1] = 0;\n                } else if (params[i].failValue > params[i].passValue) {\n                    payouts[0] = 0;\n                    payouts[1] = 1;\n                } else {\n                    payouts[0] = 1;\n                    payouts[1] = 1;\n                }\n                \n                ctf1155.reportPayouts(market.questionId, payouts);\n            }\n            \n            emit MarketResolved(\n                marketId,\n                market.proposalId,\n                params[i].passValue,\n                params[i].failValue,\n                params[i].passValue > params[i].failValue,\n                block.timestamp\n            );\n            emit MarketStatusChanged(marketId, oldStatus, MarketStatus.Resolved, block.timestamp);\n            \n            resolvedIds[successCount] = marketId;\n            results[i] = true;\n            unchecked {\n                ++successCount;\n                ++i;\n            }\n        }\n        \n        // Emit batch event with only successful resolutions\n        if (successCount > 0) {\n            uint256[] memory successfulIds = new uint256[](successCount);\n            for (uint256 j = 0; j < successCount; ) {\n                successfulIds[j] = resolvedIds[j];\n                unchecked { ++j; }\n            }\n            emit BatchMarketsResolved(successfulIds, block.timestamp, successCount);\n        }\n    }\n\n    /**\n     * @notice Cancel a market\n     * @param marketId ID of the market\n     */\n    function cancelMarket(uint256 marketId) external onlyOwner {\n        cancelMarketWithReason(marketId, \"Cancelled by owner\");\n    }\n    \n    /**\n     * @notice Cancel a market with reason\n     * @param marketId ID of the market\n     * @param reason Cancellation reason\n     */\n    function cancelMarketWithReason(uint256 marketId, string memory reason) public onlyOwner {\n        require(marketId < marketCount, \"Invalid market ID\");\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.Active, \"Market not active\");\n\n        MarketStatus oldStatus = market.status;\n        market.status = MarketStatus.Cancelled;\n        _updateMarketIndex(marketId, MarketStatus.Cancelled);\n        \n        emit MarketCancelled(marketId, market.proposalId, reason, block.timestamp);\n        emit MarketStatusChanged(marketId, oldStatus, MarketStatus.Cancelled, block.timestamp);\n    }\n\n    /**\n     * @notice Get market details\n     * @param marketId ID of the market\n     */\n    function getMarket(uint256 marketId) external view returns (Market memory) {\n        require(marketId < marketCount, \"Invalid market ID\");\n        return markets[marketId];\n    }\n\n    /**\n     * @notice Get market for a proposal\n     * @param proposalId ID of the proposal\n     */\n    function getMarketForProposal(uint256 proposalId) external view returns (uint256) {\n        uint256 marketIdPlusOne = _proposalToMarketPlusOne[proposalId];\n        require(marketIdPlusOne > 0, \"No market for proposal\");\n        return marketIdPlusOne - 1;\n    }\n    \n    /**\n     * @notice Check if a proposal has a market\n     * @param proposalId ID of the proposal\n     * @return bool True if market exists\n     */\n    function hasMarketForProposal(uint256 proposalId) external view returns (bool) {\n        return _proposalToMarketPlusOne[proposalId] > 0;\n    }\n    \n    /**\n     * @notice Get active markets with pagination\n     * @param offset Starting index\n     * @param limit Maximum results to return\n     * @return marketIds Array of market IDs\n     * @return hasMore Whether more results exist\n     */\n    function getActiveMarkets(\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory marketIds, bool hasMore) {\n        return getMarketsByStatus(MarketStatus.Active, offset, limit);\n    }\n    \n    /**\n     * @notice Get markets by status with pagination\n     * @param status Market status to filter by\n     * @param offset Starting index\n     * @param limit Maximum results\n     * @return marketIds Array of market IDs\n     * @return hasMore Whether more results exist\n     */\n    function getMarketsByStatus(\n        MarketStatus status,\n        uint256 offset,\n        uint256 limit\n    ) public view returns (uint256[] memory marketIds, bool hasMore) {\n        uint256[] storage statusMarkets = marketsByStatus[status];\n        uint256 totalCount = statusMarkets.length;\n        \n        if (offset >= totalCount) {\n            return (new uint256[](0), false);\n        }\n        \n        uint256 resultCount = totalCount - offset;\n        if (resultCount > limit) {\n            resultCount = limit;\n            hasMore = true;\n        } else {\n            hasMore = false;\n        }\n        \n        marketIds = new uint256[](resultCount);\n        for (uint256 i = 0; i < resultCount; ) {\n            marketIds[i] = statusMarkets[offset + i];\n            unchecked { ++i; }\n        }\n    }\n    \n    /**\n     * @notice Get markets by date range\n     * @param startTime Start timestamp\n     * @param endTime End timestamp\n     * @param offset Starting index\n     * @param limit Maximum results\n     * @return marketIds Array of market IDs in range\n     * @return hasMore Whether more results exist\n     */\n    function getMarketsByDateRange(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory marketIds, bool hasMore) {\n        require(startTime < endTime, \"Invalid date range\");\n        \n        uint256 startDay = startTime / 1 days;\n        uint256 endDay = endTime / 1 days;\n        \n        // Collect market IDs from all days in range\n        uint256 totalCount = 0;\n        for (uint256 day = startDay; day <= endDay; ) {\n            totalCount += marketsByDay[day].length;\n            unchecked { ++day; }\n        }\n        \n        if (offset >= totalCount) {\n            return (new uint256[](0), false);\n        }\n        \n        uint256 resultCount = totalCount - offset;\n        if (resultCount > limit) {\n            resultCount = limit;\n            hasMore = true;\n        } else {\n            hasMore = false;\n        }\n        \n        marketIds = new uint256[](resultCount);\n        uint256 currentIndex = 0;\n        uint256 skipCount = offset;\n        \n        for (uint256 day = startDay; day <= endDay && currentIndex < resultCount; ) {\n            uint256[] storage dayMarkets = marketsByDay[day];\n            \n            for (uint256 i = 0; i < dayMarkets.length && currentIndex < resultCount; ) {\n                if (skipCount > 0) {\n                    unchecked { --skipCount; }\n                } else {\n                    marketIds[currentIndex] = dayMarkets[i];\n                    unchecked { ++currentIndex; }\n                }\n                unchecked { ++i; }\n            }\n            unchecked { ++day; }\n        }\n    }\n    \n    /**\n     * @notice Get total count of markets by status\n     * @param status Market status\n     * @return count Number of markets with given status\n     */\n    function getMarketCountByStatus(MarketStatus status) external view returns (uint256) {\n        return marketsByStatus[status].length;\n    }\n    \n    /**\n     * @notice Internal function to update market indexes\n     * @param marketId Market ID\n     * @param newStatus New market status\n     */\n    function _updateMarketIndex(uint256 marketId, MarketStatus newStatus) internal {\n        // Add to status index\n        marketsByStatus[newStatus].push(marketId);\n        \n        // Add to time-based index\n        uint256 day = block.timestamp / 1 days;\n        marketsByDay[day].push(marketId);\n    }\n    \n    /**\n     * @notice Struct for batch market creation parameters\n     */\n    struct MarketCreationParams {\n        uint256 proposalId;\n        address collateralToken;\n        uint256 liquidityAmount;\n        uint256 liquidityParameter;\n        uint256 tradingPeriod;\n        BetType betType;\n    }\n    \n    /**\n     * @notice Struct for batch market resolution parameters\n     */\n    struct MarketResolutionParams {\n        uint256 marketId;\n        uint256 passValue;\n        uint256 failValue;\n    }\n\n    /**\n     * @notice Handle the receipt of a single ERC1155 token type\n     * @dev Required by IERC1155Receiver to accept ERC1155 tokens\n     */\n    function onERC1155Received(\n        address /* operator */,\n        address /* from */,\n        uint256 /* id */,\n        uint256 /* value */,\n        bytes calldata /* data */\n    ) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @notice Handle the receipt of multiple ERC1155 token types\n     * @dev Required by IERC1155Receiver to accept batch ERC1155 token transfers\n     */\n    function onERC1155BatchReceived(\n        address /* operator */,\n        address /* from */,\n        uint256[] calldata /* ids */,\n        uint256[] calldata /* values */,\n        bytes calldata /* data */\n    ) external pure returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @notice Check if contract supports an interface\n     * @dev Required by IERC165 (inherited by IERC1155Receiver)\n     */\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId ||\n               interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @title ConditionalToken\n * @notice Simplified conditional token implementation\n * @dev In production, use Gnosis Conditional Token Framework\n */\ncontract ConditionalToken is IERC20 {\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n    uint256 private _totalSupply;\n    \n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address to, uint256 amount) external override returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) external override returns (bool) {\n        _spendAllowance(from, msg.sender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function mint(address to, uint256 amount) external {\n        _totalSupply += amount;\n        _balances[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    function burn(address from, uint256 amount) external {\n        require(_balances[from] >= amount, \"Insufficient balance\");\n        _balances[from] -= amount;\n        _totalSupply -= amount;\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal {\n        require(from != address(0), \"Transfer from zero address\");\n        require(to != address(0), \"Transfer to zero address\");\n        require(_balances[from] >= amount, \"Insufficient balance\");\n\n        _balances[from] -= amount;\n        _balances[to] += amount;\n        emit Transfer(from, to, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"Approve from zero address\");\n        require(spender != address(0), \"Approve to zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _spendAllowance(address owner, address spender, uint256 amount) internal {\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= amount, \"Insufficient allowance\");\n        _approve(owner, spender, currentAllowance - amount);\n    }\n}\n"
    },
    "contracts/CTF1155.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title CTF1155 - Conditional Token Framework using ERC1155\n * @notice Gas-efficient conditional tokens based on Gnosis CTF standard\n * @dev Implements ERC1155 multi-token standard for conditional outcomes\n * \n * Key features:\n * - Gas efficient transfers using ERC1155 batch operations\n * - Combinatorial outcomes support (A AND B, A OR B, etc.)\n * - Position splitting and merging\n * - Multiple collateral token support\n * - Deep vs shallow position management\n * \n * Based on: https://github.com/gnosis/conditional-tokens-contracts\n */\ncontract CTF1155 is ERC1155, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice Emitted when a condition is prepared\n    event ConditionPreparation(\n        bytes32 indexed conditionId,\n        address indexed oracle,\n        bytes32 indexed questionId,\n        uint256 outcomeSlotCount\n    );\n\n    /// @notice Emitted when a condition is resolved\n    event ConditionResolution(\n        bytes32 indexed conditionId,\n        address indexed oracle,\n        bytes32 indexed questionId,\n        uint256 outcomeSlotCount,\n        uint256[] payoutNumerators\n    );\n\n    /// @notice Emitted when positions are split\n    event PositionSplit(\n        address indexed stakeholder,\n        IERC20 collateralToken,\n        bytes32 indexed parentCollectionId,\n        bytes32 indexed conditionId,\n        uint256[] partition,\n        uint256 amount\n    );\n\n    /// @notice Emitted when positions are merged\n    event PositionsMerge(\n        address indexed stakeholder,\n        IERC20 collateralToken,\n        bytes32 indexed parentCollectionId,\n        bytes32 indexed conditionId,\n        uint256[] partition,\n        uint256 amount\n    );\n\n    /// @notice Emitted when positions are redeemed\n    event PayoutRedemption(\n        address indexed redeemer,\n        IERC20 indexed collateralToken,\n        bytes32 indexed parentCollectionId,\n        bytes32 conditionId,\n        uint256[] indexSets,\n        uint256 payout\n    );\n\n    /// @notice Condition information\n    struct Condition {\n        address oracle;\n        bytes32 questionId;\n        uint256 outcomeSlotCount;\n        uint256[] payoutNumerators;\n        uint256 payoutDenominator;\n        bool resolved;\n    }\n\n    /// @notice Mapping from conditionId to Condition data\n    mapping(bytes32 => Condition) private _conditions;\n\n    /// @notice Mapping from collectionId to position data\n    mapping(bytes32 => uint256) public collectionIds;\n\n    constructor() ERC1155(\"\") Ownable(msg.sender) {}\n\n    /**\n     * @notice Prepare a condition for binary or multi-outcome predictions\n     * @param oracle Address that can report the outcome\n     * @param questionId Unique identifier for the question\n     * @param outcomeSlotCount Number of possible outcomes (2 for binary)\n     * @return conditionId Unique identifier for this condition\n     */\n    function prepareCondition(\n        address oracle,\n        bytes32 questionId,\n        uint256 outcomeSlotCount\n    ) external returns (bytes32 conditionId) {\n        require(outcomeSlotCount > 1, \"At least 2 outcomes required\");\n        require(outcomeSlotCount <= 256, \"Too many outcomes\");\n\n        conditionId = keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount));\n        \n        require(_conditions[conditionId].oracle == address(0), \"Condition already prepared\");\n\n        Condition storage condition = _conditions[conditionId];\n        condition.oracle = oracle;\n        condition.questionId = questionId;\n        condition.outcomeSlotCount = outcomeSlotCount;\n        condition.resolved = false;\n        condition.payoutDenominator = 0;\n\n        emit ConditionPreparation(conditionId, oracle, questionId, outcomeSlotCount);\n    }\n\n    /**\n     * @notice Report the payout for a condition\n     * @param questionId Question identifier\n     * @param payouts Array of payout numerators for each outcome\n     */\n    function reportPayouts(bytes32 questionId, uint256[] calldata payouts) external {\n        uint256 outcomeSlotCount = payouts.length;\n        bytes32 conditionId = keccak256(\n            abi.encodePacked(msg.sender, questionId, outcomeSlotCount)\n        );\n\n        Condition storage condition = _conditions[conditionId];\n        require(condition.oracle == msg.sender, \"Not the oracle\");\n        require(!condition.resolved, \"Already resolved\");\n        require(payouts.length == condition.outcomeSlotCount, \"Invalid payout array length\");\n\n        uint256 den = 0;\n        for (uint256 i = 0; i < payouts.length; i++) {\n            den += payouts[i];\n        }\n        require(den > 0, \"Payout denominator must be positive\");\n\n        condition.payoutNumerators = payouts;\n        condition.payoutDenominator = den;\n        condition.resolved = true;\n\n        emit ConditionResolution(\n            conditionId,\n            msg.sender,\n            questionId,\n            outcomeSlotCount,\n            payouts\n        );\n    }\n\n    /**\n     * @notice Split collateral into conditional tokens\n     * @param collateralToken ERC20 token used as collateral\n     * @param parentCollectionId Collection ID for deep positions (0x0 for base)\n     * @param conditionId Condition identifier\n     * @param partition Array of outcome index sets to split into\n     * @param amount Amount of collateral to split\n     */\n    function splitPosition(\n        IERC20 collateralToken,\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256[] calldata partition,\n        uint256 amount\n    ) external nonReentrant {\n        require(amount > 0, \"Amount must be positive\");\n        require(partition.length > 1, \"Partition must have at least 2 parts\");\n\n        Condition storage condition = _conditions[conditionId];\n        require(condition.oracle != address(0), \"Condition not prepared\");\n        require(!condition.resolved, \"Condition already resolved\");\n\n        // Validate partition\n        uint256 fullIndexSet = (1 << condition.outcomeSlotCount) - 1;\n        uint256 freeIndexSet = fullIndexSet;\n        for (uint256 i = 0; i < partition.length; i++) {\n            require(partition[i] > 0, \"Invalid partition\");\n            require(partition[i] & freeIndexSet == partition[i], \"Partition overlap\");\n            freeIndexSet ^= partition[i];\n        }\n\n        // Transfer collateral from user\n        collateralToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Mint conditional tokens for each partition\n        uint256[] memory ids = new uint256[](partition.length);\n        uint256[] memory amounts = new uint256[](partition.length);\n        \n        for (uint256 i = 0; i < partition.length; i++) {\n            bytes32 collectionId = getCollectionId(parentCollectionId, conditionId, partition[i]);\n            uint256 positionId = getPositionId(collateralToken, collectionId);\n            \n            ids[i] = positionId;\n            amounts[i] = amount;\n        }\n\n        _mintBatch(msg.sender, ids, amounts, \"\");\n\n        emit PositionSplit(\n            msg.sender,\n            collateralToken,\n            parentCollectionId,\n            conditionId,\n            partition,\n            amount\n        );\n    }\n\n    /**\n     * @notice Merge conditional tokens back into collateral\n     * @param collateralToken ERC20 token used as collateral\n     * @param parentCollectionId Collection ID for deep positions\n     * @param conditionId Condition identifier\n     * @param partition Array of outcome index sets to merge\n     * @param amount Amount to merge\n     */\n    function mergePositions(\n        IERC20 collateralToken,\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256[] calldata partition,\n        uint256 amount\n    ) external nonReentrant {\n        require(amount > 0, \"Amount must be positive\");\n        require(partition.length > 1, \"Partition must have at least 2 parts\");\n\n        // Burn conditional tokens for each partition\n        uint256[] memory ids = new uint256[](partition.length);\n        uint256[] memory amounts = new uint256[](partition.length);\n        \n        for (uint256 i = 0; i < partition.length; i++) {\n            bytes32 collectionId = getCollectionId(parentCollectionId, conditionId, partition[i]);\n            uint256 positionId = getPositionId(collateralToken, collectionId);\n            \n            ids[i] = positionId;\n            amounts[i] = amount;\n        }\n\n        _burnBatch(msg.sender, ids, amounts);\n\n        // Return collateral to user\n        collateralToken.safeTransfer(msg.sender, amount);\n\n        emit PositionsMerge(\n            msg.sender,\n            collateralToken,\n            parentCollectionId,\n            conditionId,\n            partition,\n            amount\n        );\n    }\n\n    /**\n     * @notice Redeem positions for resolved condition\n     * @param collateralToken ERC20 token used as collateral\n     * @param parentCollectionId Collection ID\n     * @param conditionId Condition identifier\n     * @param indexSets Array of index sets to redeem\n     */\n    function redeemPositions(\n        IERC20 collateralToken,\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256[] calldata indexSets\n    ) external nonReentrant {\n        Condition storage condition = _conditions[conditionId];\n        require(condition.resolved, \"Condition not resolved\");\n\n        uint256 totalPayout = 0;\n        uint256[] memory ids = new uint256[](indexSets.length);\n        uint256[] memory amounts = new uint256[](indexSets.length);\n\n        for (uint256 i = 0; i < indexSets.length; i++) {\n            bytes32 collectionId = getCollectionId(parentCollectionId, conditionId, indexSets[i]);\n            uint256 positionId = getPositionId(collateralToken, collectionId);\n            uint256 balance = balanceOf(msg.sender, positionId);\n\n            require(balance > 0, \"No balance to redeem\");\n\n            // Calculate payout for this index set\n            uint256 payoutNumerator = 0;\n            for (uint256 j = 0; j < condition.outcomeSlotCount; j++) {\n                if (indexSets[i] & (1 << j) != 0) {\n                    payoutNumerator += condition.payoutNumerators[j];\n                }\n            }\n\n            uint256 payout = (balance * payoutNumerator) / condition.payoutDenominator;\n            totalPayout += payout;\n\n            ids[i] = positionId;\n            amounts[i] = balance;\n        }\n\n        // Burn redeemed positions\n        _burnBatch(msg.sender, ids, amounts);\n\n        // Transfer payout\n        if (totalPayout > 0) {\n            collateralToken.safeTransfer(msg.sender, totalPayout);\n        }\n\n        emit PayoutRedemption(\n            msg.sender,\n            collateralToken,\n            parentCollectionId,\n            conditionId,\n            indexSets,\n            totalPayout\n        );\n    }\n\n    /**\n     * @notice Get collection ID for a condition and index set\n     * @param parentCollectionId Parent collection ID\n     * @param conditionId Condition identifier\n     * @param indexSet Index set for outcomes\n     * @return Collection ID\n     */\n    function getCollectionId(\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256 indexSet\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(parentCollectionId, conditionId, indexSet));\n    }\n\n    /**\n     * @notice Get position ID for a collateral token and collection\n     * @param collateralToken Collateral token address\n     * @param collectionId Collection identifier\n     * @return Position ID (used as ERC1155 token ID)\n     */\n    function getPositionId(IERC20 collateralToken, bytes32 collectionId) public pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(collateralToken, collectionId)));\n    }\n\n    /**\n     * @notice Get condition ID\n     * @param oracle Oracle address\n     * @param questionId Question identifier\n     * @param outcomeSlotCount Number of outcomes\n     * @return Condition ID\n     */\n    function getConditionId(\n        address oracle,\n        bytes32 questionId,\n        uint256 outcomeSlotCount\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount));\n    }\n\n    /**\n     * @notice Get condition details\n     * @param conditionId Condition identifier\n     * @return oracle Oracle address\n     * @return questionId Question identifier\n     * @return outcomeSlotCount Number of outcomes\n     * @return resolved Whether condition is resolved\n     */\n    function getCondition(bytes32 conditionId) external view returns (\n        address oracle,\n        bytes32 questionId,\n        uint256 outcomeSlotCount,\n        bool resolved\n    ) {\n        Condition storage condition = _conditions[conditionId];\n        return (\n            condition.oracle,\n            condition.questionId,\n            condition.outcomeSlotCount,\n            condition.resolved\n        );\n    }\n\n    /**\n     * @notice Check if a condition is resolved\n     * @param conditionId Condition identifier\n     * @return Whether the condition is resolved\n     */\n    function isResolved(bytes32 conditionId) external view returns (bool) {\n        return _conditions[conditionId].resolved;\n    }\n\n    /**\n     * @notice Get payout numerators for a resolved condition\n     * @param conditionId Condition identifier\n     * @return Payout numerators array\n     */\n    function getPayoutNumerators(bytes32 conditionId) external view returns (uint256[] memory) {\n        require(_conditions[conditionId].resolved, \"Condition not resolved\");\n        return _conditions[conditionId].payoutNumerators;\n    }\n\n    /**\n     * @notice Get payout denominator for a resolved condition\n     * @param conditionId Condition identifier\n     * @return Payout denominator\n     */\n    function getPayoutDenominator(bytes32 conditionId) external view returns (uint256) {\n        require(_conditions[conditionId].resolved, \"Condition not resolved\");\n        return _conditions[conditionId].payoutDenominator;\n    }\n}\n"
    },
    "contracts/DAOFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./WelfareMetricRegistry.sol\";\nimport \"./ProposalRegistry.sol\";\nimport \"./ConditionalMarketFactory.sol\";\nimport \"./PrivacyCoordinator.sol\";\nimport \"./OracleResolver.sol\";\nimport \"./RagequitModule.sol\";\nimport \"./FutarchyGovernor.sol\";\n\n/**\n * @title DAOFactory\n * @notice Factory contract for deploying multiple DAO instances with role-based access control\n * @dev Uses OpenZeppelin AccessControl for managing administrators, participants, and other roles\n */\ncontract DAOFactory is AccessControl, ReentrancyGuard {\n    // Role definitions\n    bytes32 public constant PLATFORM_ADMIN_ROLE = keccak256(\"PLATFORM_ADMIN_ROLE\");\n    bytes32 public constant DAO_CREATOR_ROLE = keccak256(\"DAO_CREATOR_ROLE\");\n\n    struct DAOInstance {\n        string name;\n        string description;\n        address futarchyGovernor;\n        address welfareRegistry;\n        address proposalRegistry;\n        address marketFactory;\n        address privacyCoordinator;\n        address oracleResolver;\n        address ragequitModule;\n        address treasuryVault;\n        address creator;\n        uint256 createdAt;\n        bool active;\n    }\n\n    // DAO ID => DAOInstance\n    mapping(uint256 => DAOInstance) public daos;\n    uint256 public daoCount;\n\n    // User address => array of DAO IDs they're associated with\n    mapping(address => uint256[]) public userDAOs;\n\n    // DAO ID => address => role => bool\n    mapping(uint256 => mapping(address => mapping(bytes32 => bool))) public daoRoles;\n\n    // DAO-specific role definitions\n    bytes32 public constant DAO_ADMIN_ROLE = keccak256(\"DAO_ADMIN_ROLE\");\n    bytes32 public constant DAO_PARTICIPANT_ROLE = keccak256(\"DAO_PARTICIPANT_ROLE\");\n    bytes32 public constant DAO_PROPOSER_ROLE = keccak256(\"DAO_PROPOSER_ROLE\");\n    bytes32 public constant DAO_ORACLE_ROLE = keccak256(\"DAO_ORACLE_ROLE\");\n\n    // Implementation contract addresses\n    address public immutable welfareRegistryImpl;\n    address public immutable proposalRegistryImpl;\n    address public immutable marketFactoryImpl;\n    address public immutable privacyCoordinatorImpl;\n    address public immutable oracleResolverImpl;\n    address public immutable ragequitModuleImpl;\n    address public immutable futarchyGovernorImpl;\n\n    event DAOCreated(\n        uint256 indexed daoId,\n        string name,\n        address indexed creator,\n        address futarchyGovernor,\n        uint256 timestamp\n    );\n\n    event DAORoleGranted(\n        uint256 indexed daoId,\n        address indexed user,\n        bytes32 indexed role\n    );\n\n    event DAORoleRevoked(\n        uint256 indexed daoId,\n        address indexed user,\n        bytes32 indexed role\n    );\n\n    event DAOStatusUpdated(uint256 indexed daoId, bool active);\n\n    constructor(\n        address _welfareRegistryImpl,\n        address _proposalRegistryImpl,\n        address _marketFactoryImpl,\n        address _privacyCoordinatorImpl,\n        address _oracleResolverImpl,\n        address _ragequitModuleImpl,\n        address _futarchyGovernorImpl\n    ) {\n        // Grant deployer the default admin role\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(PLATFORM_ADMIN_ROLE, msg.sender);\n        _grantRole(DAO_CREATOR_ROLE, msg.sender);\n\n        // Set role admin relationships\n        _setRoleAdmin(PLATFORM_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\n        _setRoleAdmin(DAO_CREATOR_ROLE, PLATFORM_ADMIN_ROLE);\n\n        // Store implementation contract addresses (deployed separately).\n        require(_welfareRegistryImpl != address(0), \"Invalid welfareRegistryImpl\");\n        require(_proposalRegistryImpl != address(0), \"Invalid proposalRegistryImpl\");\n        require(_marketFactoryImpl != address(0), \"Invalid marketFactoryImpl\");\n        require(_privacyCoordinatorImpl != address(0), \"Invalid privacyCoordinatorImpl\");\n        require(_oracleResolverImpl != address(0), \"Invalid oracleResolverImpl\");\n        require(_ragequitModuleImpl != address(0), \"Invalid ragequitModuleImpl\");\n        require(_futarchyGovernorImpl != address(0), \"Invalid futarchyGovernorImpl\");\n\n        welfareRegistryImpl = _welfareRegistryImpl;\n        proposalRegistryImpl = _proposalRegistryImpl;\n        marketFactoryImpl = _marketFactoryImpl;\n        privacyCoordinatorImpl = _privacyCoordinatorImpl;\n        oracleResolverImpl = _oracleResolverImpl;\n        ragequitModuleImpl = _ragequitModuleImpl;\n        futarchyGovernorImpl = _futarchyGovernorImpl;\n    }\n\n    /**\n     * @notice Deploy a new DAO instance with all required components\n     * @param name Name of the DAO\n     * @param description Description of the DAO\n     * @param treasuryVault Address of the treasury vault\n     * @param admins Array of addresses to grant DAO_ADMIN_ROLE\n     * @return daoId ID of the newly created DAO\n     */\n    function createDAO(\n        string memory name,\n        string memory description,\n        address treasuryVault,\n        address[] memory admins\n    ) external nonReentrant onlyRole(DAO_CREATOR_ROLE) returns (uint256 daoId) {\n        require(bytes(name).length > 0, \"Name cannot be empty\");\n        require(treasuryVault != address(0), \"Invalid treasury vault\");\n\n        daoId = daoCount++;\n\n        // Deploy components and governor\n        (\n            address futarchyGovernor,\n            address welfareRegistry,\n            address proposalRegistry,\n            address marketFactory,\n            address privacyCoordinator,\n            address oracleResolver,\n            address ragequitModule\n        ) = _deployDAOComponents(treasuryVault);\n\n        // Store DAO instance\n        daos[daoId] = DAOInstance({\n            name: name,\n            description: description,\n            futarchyGovernor: futarchyGovernor,\n            welfareRegistry: welfareRegistry,\n            proposalRegistry: proposalRegistry,\n            marketFactory: marketFactory,\n            privacyCoordinator: privacyCoordinator,\n            oracleResolver: oracleResolver,\n            ragequitModule: ragequitModule,\n            treasuryVault: treasuryVault,\n            creator: msg.sender,\n            createdAt: block.timestamp,\n            active: true\n        });\n\n        // Grant roles\n        _setupDAORoles(daoId, admins);\n\n        emit DAOCreated(daoId, name, msg.sender, futarchyGovernor, block.timestamp);\n    }\n\n    /**\n     * @dev Internal function to deploy DAO components\n     * @param treasuryVault Address of the treasury vault\n     * @return Addresses of all deployed contracts\n     */\n    function _deployDAOComponents(address treasuryVault) \n        internal \n        returns (\n            address,\n            address,\n            address,\n            address,\n            address,\n            address,\n            address\n        ) \n    {\n        // Clone DAO components using minimal proxies\n        address welfareRegistry = Clones.clone(welfareRegistryImpl);\n        address proposalRegistry = Clones.clone(proposalRegistryImpl);\n        address marketFactory = Clones.clone(marketFactoryImpl);\n        address privacyCoordinator = Clones.clone(privacyCoordinatorImpl);\n        address oracleResolver = Clones.clone(oracleResolverImpl);\n        address payable ragequitModule = payable(Clones.clone(ragequitModuleImpl));\n        address payable futarchyGovernor = payable(Clones.clone(futarchyGovernorImpl));\n\n        // Initialize clones (ownership starts with factory)\n        WelfareMetricRegistry(welfareRegistry).initialize(address(this));\n        ProposalRegistry(proposalRegistry).initialize(address(this));\n        ConditionalMarketFactory(marketFactory).initialize(address(this));\n        PrivacyCoordinator(privacyCoordinator).initialize(address(this));\n        OracleResolver(oracleResolver).initialize(address(this));\n        RagequitModule(ragequitModule).initialize(\n            address(this),\n            address(this), // Placeholder: DAO must set proper governance token after creation\n            treasuryVault\n        );\n\n        // Initialize FutarchyGovernor - ownership remains with factory\n        FutarchyGovernor(futarchyGovernor).initialize(\n            address(this),\n            welfareRegistry,\n            proposalRegistry,\n            marketFactory,\n            privacyCoordinator,\n            oracleResolver,\n            ragequitModule,\n            treasuryVault\n        );\n\n        // Transfer ownership of components to FutarchyGovernor\n        WelfareMetricRegistry(welfareRegistry).transferOwnership(futarchyGovernor);\n        ProposalRegistry(proposalRegistry).transferOwnership(futarchyGovernor);\n        ConditionalMarketFactory(marketFactory).transferOwnership(futarchyGovernor);\n        OracleResolver(oracleResolver).transferOwnership(futarchyGovernor);\n        RagequitModule(ragequitModule).transferOwnership(futarchyGovernor);\n\n        return (\n            futarchyGovernor,\n            welfareRegistry,\n            proposalRegistry,\n            marketFactory,\n            privacyCoordinator,\n            oracleResolver,\n            ragequitModule\n        );\n    }\n\n    /**\n     * @dev Internal function to setup DAO roles\n     * @param daoId ID of the DAO\n     * @param admins Array of addresses to grant admin roles\n     */\n    function _setupDAORoles(uint256 daoId, address[] memory admins) internal {\n        // Grant roles to creator\n        _grantDAORole(daoId, msg.sender, DAO_ADMIN_ROLE);\n        _grantDAORole(daoId, msg.sender, DAO_PARTICIPANT_ROLE);\n        _grantDAORole(daoId, msg.sender, DAO_PROPOSER_ROLE);\n\n        // Grant admin roles to specified addresses\n        for (uint256 i = 0; i < admins.length; i++) {\n            if (admins[i] != address(0) && admins[i] != msg.sender) {\n                _grantDAORole(daoId, admins[i], DAO_ADMIN_ROLE);\n                _grantDAORole(daoId, admins[i], DAO_PARTICIPANT_ROLE);\n            }\n        }\n    }\n\n    /**\n     * @notice Grant a role to a user for a specific DAO\n     * @param daoId ID of the DAO\n     * @param user Address to grant role to\n     * @param role Role to grant\n     */\n    function grantDAORole(\n        uint256 daoId,\n        address user,\n        bytes32 role\n    ) external {\n        require(daoId < daoCount, \"DAO does not exist\");\n        require(user != address(0), \"Invalid user address\");\n        require(\n            hasRole(PLATFORM_ADMIN_ROLE, msg.sender) ||\n            daoRoles[daoId][msg.sender][DAO_ADMIN_ROLE],\n            \"Not authorized\"\n        );\n\n        _grantDAORole(daoId, user, role);\n    }\n\n    /**\n     * @notice Revoke a role from a user for a specific DAO\n     * @param daoId ID of the DAO\n     * @param user Address to revoke role from\n     * @param role Role to revoke\n     */\n    function revokeDAORole(\n        uint256 daoId,\n        address user,\n        bytes32 role\n    ) external {\n        require(daoId < daoCount, \"DAO does not exist\");\n        require(\n            hasRole(PLATFORM_ADMIN_ROLE, msg.sender) ||\n            daoRoles[daoId][msg.sender][DAO_ADMIN_ROLE],\n            \"Not authorized\"\n        );\n\n        _revokeDAORole(daoId, user, role);\n    }\n\n    /**\n     * @notice Check if a user has a specific role for a DAO\n     * @param daoId ID of the DAO\n     * @param user Address to check\n     * @param role Role to check\n     * @return bool True if user has the role\n     */\n    function hasDAORole(\n        uint256 daoId,\n        address user,\n        bytes32 role\n    ) external view returns (bool) {\n        return daoRoles[daoId][user][role] || hasRole(PLATFORM_ADMIN_ROLE, user);\n    }\n\n    /**\n     * @notice Get all DAOs associated with a user\n     * @param user Address to query\n     * @return uint256[] Array of DAO IDs\n     */\n    function getUserDAOs(address user) external view returns (uint256[] memory) {\n        return userDAOs[user];\n    }\n\n    /**\n     * @notice Get DAO details\n     * @param daoId ID of the DAO\n     * @return DAOInstance struct\n     */\n    function getDAO(uint256 daoId) external view returns (DAOInstance memory) {\n        require(daoId < daoCount, \"DAO does not exist\");\n        return daos[daoId];\n    }\n\n    /**\n     * @notice Get all DAOs (paginated)\n     * @param start Start index\n     * @param limit Number of DAOs to return\n     * @return DAOInstance[] Array of DAO instances\n     */\n    function getAllDAOs(uint256 start, uint256 limit) \n        external \n        view \n        returns (DAOInstance[] memory) \n    {\n        require(start < daoCount, \"Start index out of bounds\");\n        \n        uint256 end = start + limit;\n        if (end > daoCount) {\n            end = daoCount;\n        }\n        \n        uint256 length = end - start;\n        DAOInstance[] memory result = new DAOInstance[](length);\n        \n        for (uint256 i = 0; i < length; i++) {\n            result[i] = daos[start + i];\n        }\n        \n        return result;\n    }\n\n    /**\n     * @notice Update DAO active status\n     * @param daoId ID of the DAO\n     * @param active New active status\n     */\n    function setDAOStatus(uint256 daoId, bool active) external onlyRole(PLATFORM_ADMIN_ROLE) {\n        require(daoId < daoCount, \"DAO does not exist\");\n        daos[daoId].active = active;\n        emit DAOStatusUpdated(daoId, active);\n    }\n\n    /**\n     * @dev Internal function to grant DAO role\n     */\n    function _grantDAORole(uint256 daoId, address user, bytes32 role) internal {\n        daoRoles[daoId][user][role] = true;\n        \n        // Add to user's DAO list if not already present\n        bool found = false;\n        uint256[] storage userDaoList = userDAOs[user];\n        for (uint256 i = 0; i < userDaoList.length; i++) {\n            if (userDaoList[i] == daoId) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            userDaoList.push(daoId);\n        }\n        \n        emit DAORoleGranted(daoId, user, role);\n    }\n\n    /**\n     * @dev Internal function to revoke DAO role\n     */\n    function _revokeDAORole(uint256 daoId, address user, bytes32 role) internal {\n        if (daoRoles[daoId][user][role]) {\n            daoRoles[daoId][user][role] = false;\n            emit DAORoleRevoked(daoId, user, role);\n        }\n    }\n}\n"
    },
    "contracts/ETCSwapV3Integration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/uniswap-v3/IUniswapV3Factory.sol\";\nimport \"./interfaces/uniswap-v3/IUniswapV3Pool.sol\";\nimport \"./interfaces/uniswap-v3/ISwapRouter.sol\";\nimport \"./interfaces/uniswap-v3/INonfungiblePositionManager.sol\";\nimport \"./TieredRoleManager.sol\";\n\n/**\n * @title ETCSwapV3Integration\n * @notice Production-ready integration with ETCSwap v3 with role-based liquidity management\n * @dev Handles pool creation, liquidity management, and trading for conditional tokens\n * \n * This contract provides a comprehensive interface to ETCSwap v3 (Uniswap v3 fork):\n * - Pool creation and initialization for PASS/FAIL tokens\n * - Liquidity provision and management\n * - Token swapping with slippage protection\n * - Emergency controls and safety mechanisms\n * - Events for off-chain tracking and analytics\n * \n * RBAC INTEGRATION:\n * - Pool creation requires MARKET_MAKER_ROLE\n * - Admin functions require OPERATIONS_ADMIN_ROLE\n * \n * Based on: https://github.com/etcswap/v3-sdk\n * Reference: https://docs.uniswap.org/contracts/v3/overview\n */\ncontract ETCSwapV3Integration is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // ============ State Variables ============\n\n    /// @notice ETCSwap v3 Factory contract\n    IUniswapV3Factory public immutable factory;\n\n    /// @notice ETCSwap v3 SwapRouter contract\n    ISwapRouter public immutable swapRouter;\n\n    /// @notice ETCSwap v3 NonfungiblePositionManager contract\n    INonfungiblePositionManager public immutable positionManager;\n\n    /// @notice Default fee tier (0.3% = 3000)\n    uint24 public constant DEFAULT_FEE = 3000;\n\n    /// @notice Low fee tier (0.05% = 500) for stable pairs\n    uint24 public constant LOW_FEE = 500;\n\n    /// @notice High fee tier (1% = 10000) for volatile pairs\n    uint24 public constant HIGH_FEE = 10000;\n\n    /// @notice Default slippage tolerance in basis points (50 = 0.5%)\n    uint256 public defaultSlippageBps = 50;\n\n    /// @notice Maximum allowed slippage in basis points (1000 = 10%)\n    uint256 public constant MAX_SLIPPAGE_BPS = 1000;\n\n    /// @notice Minimum sqrt price limit for swaps\n    uint160 public constant MIN_SQRT_RATIO = 4295128739;\n\n    /// @notice Maximum sqrt price limit for swaps\n    uint160 public constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Mapping of market ID to pool configuration\n    mapping(uint256 => PoolConfig) public marketPools;\n\n    /// @notice Mapping of market ID to liquidity position NFT token ID\n    mapping(uint256 => uint256) public marketPositions;\n\n    /// @notice Paused state for emergency stops\n    bool public paused;\n    \n    // Role-based access control\n    TieredRoleManager public roleManager;\n\n    // ============ Structs ============\n\n    struct PoolConfig {\n        address passPool;      // Pool for PASS token / collateral\n        address failPool;      // Pool for FAIL token / collateral\n        uint24 fee;            // Fee tier for the pools\n        bool initialized;      // Whether pools have been created\n    }\n\n    struct SwapResult {\n        uint256 amountIn;\n        uint256 amountOut;\n        uint256 executionPrice; // Price with 18 decimals\n    }\n\n    // ============ Events ============\n\n    event PoolsCreated(\n        uint256 indexed marketId,\n        address indexed passPool,\n        address indexed failPool,\n        uint24 fee\n    );\n\n    event LiquidityAdded(\n        uint256 indexed marketId,\n        uint256 indexed positionId,\n        uint256 amount0,\n        uint256 amount1,\n        uint128 liquidity\n    );\n\n    event LiquidityRemoved(\n        uint256 indexed marketId,\n        uint256 indexed positionId,\n        uint256 amount0,\n        uint256 amount1,\n        uint128 liquidity\n    );\n\n    event TokensSwapped(\n        uint256 indexed marketId,\n        address indexed trader,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 executionPrice\n    );\n\n    event SlippageUpdated(uint256 oldSlippage, uint256 newSlippage);\n\n    event EmergencyPauseToggled(bool paused);\n\n    event FeesCollected(\n        uint256 indexed marketId,\n        uint256 indexed positionId,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    // ============ Errors ============\n\n    error ContractPaused();\n    error InvalidAddress();\n    error InvalidAmount();\n    error InvalidSlippage();\n    error PoolNotInitialized();\n    error PoolAlreadyExists();\n    error InsufficientOutput();\n    error ExcessiveInput();\n    error DeadlineExpired();\n    error InvalidFee();\n\n    // ============ Constructor ============\n\n    /**\n     * @notice Initialize the ETCSwap v3 integration\n     * @param _factory ETCSwap v3 Factory address\n     * @param _swapRouter ETCSwap v3 SwapRouter address\n     * @param _positionManager ETCSwap v3 NonfungiblePositionManager address\n     */\n    constructor(\n        address _factory,\n        address _swapRouter,\n        address _positionManager\n    ) Ownable(msg.sender) {\n        if (_factory == address(0) || _swapRouter == address(0) || _positionManager == address(0)) {\n            revert InvalidAddress();\n        }\n\n        factory = IUniswapV3Factory(_factory);\n        swapRouter = ISwapRouter(_swapRouter);\n        positionManager = INonfungiblePositionManager(_positionManager);\n    }\n    \n    /**\n     * @notice Set the role manager contract\n     * @param _roleManager Address of TieredRoleManager contract\n     */\n    function setRoleManager(address _roleManager) external onlyOwner {\n        require(_roleManager != address(0), \"Invalid role manager address\");\n        require(address(roleManager) == address(0), \"Role manager already set\");\n        roleManager = TieredRoleManager(_roleManager);\n    }\n\n    // ============ Modifiers ============\n\n    modifier whenNotPaused() {\n        if (paused) revert ContractPaused();\n        _;\n    }\n\n    // ============ Pool Management Functions ============\n\n    /**\n     * @notice Create ETCSwap v3 pools for a prediction market\n     * @dev Creates two pools: PASS/collateral and FAIL/collateral\n     * @param marketId Market identifier\n     * @param passToken Address of PASS conditional token\n     * @param failToken Address of FAIL conditional token\n     * @param collateralToken Address of collateral token\n     * @param fee Fee tier to use (500, 3000, or 10000)\n     * @param initialSqrtPriceX96 Initial price for both pools (Q64.96 format)\n     * @return passPool Address of created PASS pool\n     * @return failPool Address of created FAIL pool\n     */\n    function createMarketPools(\n        uint256 marketId,\n        address passToken,\n        address failToken,\n        address collateralToken,\n        uint24 fee,\n        uint160 initialSqrtPriceX96\n    ) external onlyOwner whenNotPaused returns (address passPool, address failPool) {\n        if (marketPools[marketId].initialized) revert PoolAlreadyExists();\n        if (passToken == address(0) || failToken == address(0) || collateralToken == address(0)) {\n            revert InvalidAddress();\n        }\n        if (fee != LOW_FEE && fee != DEFAULT_FEE && fee != HIGH_FEE) {\n            revert InvalidFee();\n        }\n\n        // Create PASS/collateral pool\n        passPool = _getOrCreatePool(passToken, collateralToken, fee);\n        _initializePoolIfNeeded(passPool, initialSqrtPriceX96);\n\n        // Create FAIL/collateral pool\n        failPool = _getOrCreatePool(failToken, collateralToken, fee);\n        _initializePoolIfNeeded(failPool, initialSqrtPriceX96);\n\n        // Store pool configuration\n        marketPools[marketId] = PoolConfig({\n            passPool: passPool,\n            failPool: failPool,\n            fee: fee,\n            initialized: true\n        });\n\n        emit PoolsCreated(marketId, passPool, failPool, fee);\n    }\n\n    /**\n     * @notice Add liquidity to market pools\n     * @dev Adds liquidity to both PASS and FAIL pools for a market\n     * @param marketId Market identifier\n     * @param passToken Address of PASS conditional token\n     * @param failToken Address of FAIL conditional token\n     * @param collateralToken Address of collateral token\n     * @param passAmount Amount of PASS tokens to provide\n     * @param failAmount Amount of FAIL tokens to provide\n     * @param collateralAmountPass Amount of collateral for PASS pool\n     * @param collateralAmountFail Amount of collateral for FAIL pool\n     * @param tickLower Lower tick for the position\n     * @param tickUpper Upper tick for the position\n     * @param deadline Transaction deadline\n     * @return tokenId NFT token ID for the position\n     * @return liquidity Amount of liquidity added\n     */\n    function addLiquidity(\n        uint256 marketId,\n        address passToken,\n        address failToken,\n        address collateralToken,\n        uint256 passAmount,\n        uint256 failAmount,\n        uint256 collateralAmountPass,\n        uint256 collateralAmountFail,\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 deadline\n    ) external onlyOwner whenNotPaused nonReentrant returns (uint256 tokenId, uint128 liquidity) {\n        if (block.timestamp > deadline) revert DeadlineExpired();\n        \n        PoolConfig memory config = marketPools[marketId];\n        if (!config.initialized) revert PoolNotInitialized();\n\n        // Transfer tokens from caller\n        IERC20(passToken).safeTransferFrom(msg.sender, address(this), passAmount);\n        IERC20(failToken).safeTransferFrom(msg.sender, address(this), failAmount);\n        IERC20(collateralToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            collateralAmountPass + collateralAmountFail\n        );\n\n        // Approve position manager\n        IERC20(passToken).safeIncreaseAllowance(address(positionManager), passAmount);\n        IERC20(collateralToken).safeIncreaseAllowance(address(positionManager), collateralAmountPass);\n\n        // Add liquidity to PASS pool\n        (address token0, address token1) = _sortTokens(passToken, collateralToken);\n        (uint256 amount0Desired, uint256 amount1Desired) = token0 == passToken\n            ? (passAmount, collateralAmountPass)\n            : (collateralAmountPass, passAmount);\n\n        INonfungiblePositionManager.MintParams memory params = INonfungiblePositionManager.MintParams({\n            token0: token0,\n            token1: token1,\n            fee: config.fee,\n            tickLower: tickLower,\n            tickUpper: tickUpper,\n            amount0Desired: amount0Desired,\n            amount1Desired: amount1Desired,\n            amount0Min: 0,\n            amount1Min: 0,\n            recipient: address(this),\n            deadline: deadline\n        });\n\n        uint256 amount0;\n        uint256 amount1;\n        (tokenId, liquidity, amount0, amount1) = positionManager.mint(params);\n\n        // Store position for the market\n        marketPositions[marketId] = tokenId;\n\n        emit LiquidityAdded(marketId, tokenId, amount0, amount1, liquidity);\n    }\n\n    // ============ Trading Functions ============\n\n    /**\n     * @notice Buy outcome tokens using collateral via ETCSwap\n     * @dev Executes a swap from collateral to outcome token (PASS or FAIL)\n     * @param marketId Market identifier\n     * @param collateralToken Address of collateral token\n     * @param outcomeToken Address of outcome token (PASS or FAIL)\n     * @param collateralAmount Amount of collateral to spend\n     * @param minTokenAmount Minimum amount of outcome tokens to receive\n     * @param deadline Transaction deadline\n     * @return result Swap execution result\n     */\n    function buyTokens(\n        uint256 marketId,\n        address collateralToken,\n        address outcomeToken,\n        uint256 collateralAmount,\n        uint256 minTokenAmount,\n        uint256 deadline\n    ) external whenNotPaused nonReentrant returns (SwapResult memory result) {\n        if (block.timestamp > deadline) revert DeadlineExpired();\n        if (collateralAmount == 0) revert InvalidAmount();\n        \n        PoolConfig memory config = marketPools[marketId];\n        if (!config.initialized) revert PoolNotInitialized();\n\n        // Transfer collateral from buyer\n        IERC20(collateralToken).safeTransferFrom(msg.sender, address(this), collateralAmount);\n\n        // Approve router\n        IERC20(collateralToken).safeIncreaseAllowance(address(swapRouter), collateralAmount);\n\n        // Execute swap\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: collateralToken,\n            tokenOut: outcomeToken,\n            fee: config.fee,\n            recipient: msg.sender,\n            deadline: deadline,\n            amountIn: collateralAmount,\n            amountOutMinimum: minTokenAmount,\n            sqrtPriceLimitX96: 0\n        });\n\n        uint256 amountOut = swapRouter.exactInputSingle(params);\n        \n        if (amountOut < minTokenAmount) revert InsufficientOutput();\n\n        // Calculate execution price\n        uint256 executionPrice = (collateralAmount * 1e18) / amountOut;\n\n        result = SwapResult({\n            amountIn: collateralAmount,\n            amountOut: amountOut,\n            executionPrice: executionPrice\n        });\n\n        emit TokensSwapped(\n            marketId,\n            msg.sender,\n            collateralToken,\n            outcomeToken,\n            collateralAmount,\n            amountOut,\n            executionPrice\n        );\n    }\n\n    /**\n     * @notice Sell outcome tokens for collateral via ETCSwap\n     * @dev Executes a swap from outcome token (PASS or FAIL) to collateral\n     * @param marketId Market identifier\n     * @param outcomeToken Address of outcome token (PASS or FAIL)\n     * @param collateralToken Address of collateral token\n     * @param tokenAmount Amount of outcome tokens to sell\n     * @param minCollateralAmount Minimum amount of collateral to receive\n     * @param deadline Transaction deadline\n     * @return result Swap execution result\n     */\n    function sellTokens(\n        uint256 marketId,\n        address outcomeToken,\n        address collateralToken,\n        uint256 tokenAmount,\n        uint256 minCollateralAmount,\n        uint256 deadline\n    ) external whenNotPaused nonReentrant returns (SwapResult memory result) {\n        if (block.timestamp > deadline) revert DeadlineExpired();\n        if (tokenAmount == 0) revert InvalidAmount();\n        \n        PoolConfig memory config = marketPools[marketId];\n        if (!config.initialized) revert PoolNotInitialized();\n\n        // Transfer tokens from seller\n        IERC20(outcomeToken).safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n        // Approve router\n        IERC20(outcomeToken).safeIncreaseAllowance(address(swapRouter), tokenAmount);\n\n        // Execute swap\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: outcomeToken,\n            tokenOut: collateralToken,\n            fee: config.fee,\n            recipient: msg.sender,\n            deadline: deadline,\n            amountIn: tokenAmount,\n            amountOutMinimum: minCollateralAmount,\n            sqrtPriceLimitX96: 0\n        });\n\n        uint256 amountOut = swapRouter.exactInputSingle(params);\n        \n        if (amountOut < minCollateralAmount) revert InsufficientOutput();\n\n        // Calculate execution price\n        uint256 executionPrice = (amountOut * 1e18) / tokenAmount;\n\n        result = SwapResult({\n            amountIn: tokenAmount,\n            amountOut: amountOut,\n            executionPrice: executionPrice\n        });\n\n        emit TokensSwapped(\n            marketId,\n            msg.sender,\n            outcomeToken,\n            collateralToken,\n            tokenAmount,\n            amountOut,\n            executionPrice\n        );\n    }\n\n    // ============ Quote Functions ============\n\n    /**\n     * @notice Get quote for buying outcome tokens\n     * @dev Simulates a swap to get expected output amount\n     * @param marketId Market identifier\n     * @param buyPass True for PASS tokens, false for FAIL tokens\n     * @param collateralAmount Amount of collateral to spend\n     * @return estimatedTokenAmount Estimated amount of outcome tokens\n     */\n    function quoteBuyTokens(\n        uint256 marketId,\n        bool buyPass,\n        uint256 collateralAmount\n    ) external view returns (uint256 estimatedTokenAmount) {\n        PoolConfig memory config = marketPools[marketId];\n        if (!config.initialized) revert PoolNotInitialized();\n\n        address pool = buyPass ? config.passPool : config.failPool;\n        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();\n\n        // Simplified estimation based on current price\n        // In production, use a more sophisticated quoter contract\n        uint256 priceX96 = uint256(sqrtPriceX96) * uint256(sqrtPriceX96) / (1 << 96);\n        estimatedTokenAmount = (collateralAmount * (1 << 96)) / priceX96;\n    }\n\n    /**\n     * @notice Get quote for selling outcome tokens\n     * @dev Simulates a swap to get expected output amount\n     * @param marketId Market identifier\n     * @param sellPass True for PASS tokens, false for FAIL tokens\n     * @param tokenAmount Amount of outcome tokens to sell\n     * @return estimatedCollateralAmount Estimated amount of collateral\n     */\n    function quoteSellTokens(\n        uint256 marketId,\n        bool sellPass,\n        uint256 tokenAmount\n    ) external view returns (uint256 estimatedCollateralAmount) {\n        PoolConfig memory config = marketPools[marketId];\n        if (!config.initialized) revert PoolNotInitialized();\n\n        address pool = sellPass ? config.passPool : config.failPool;\n        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();\n\n        // Simplified estimation based on current price\n        // Note: sqrtPriceX96 is in Q64.96 format, so we need to square it and divide by 2^96\n        // to get the actual price. This appears as divide-before-multiply to static analyzers\n        // but is the correct implementation for Uniswap v3's fixed-point arithmetic.\n        uint256 priceX96 = uint256(sqrtPriceX96) * uint256(sqrtPriceX96) / (1 << 96);\n        estimatedCollateralAmount = (tokenAmount * priceX96) / (1 << 96);\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Update default slippage tolerance\n     * @param newSlippageBps New slippage in basis points\n     */\n    function setDefaultSlippage(uint256 newSlippageBps) external onlyOwner {\n        if (newSlippageBps > MAX_SLIPPAGE_BPS) revert InvalidSlippage();\n        \n        uint256 oldSlippage = defaultSlippageBps;\n        defaultSlippageBps = newSlippageBps;\n        \n        emit SlippageUpdated(oldSlippage, newSlippageBps);\n    }\n\n    /**\n     * @notice Toggle pause state for emergency stops\n     */\n    function togglePause() external onlyOwner {\n        paused = !paused;\n        emit EmergencyPauseToggled(paused);\n    }\n\n    /**\n     * @notice Collect fees from a liquidity position\n     * @param marketId Market identifier\n     * @param recipient Address to receive collected fees\n     * @return amount0 Amount of token0 fees collected\n     * @return amount1 Amount of token1 fees collected\n     */\n    function collectFees(uint256 marketId, address recipient)\n        external\n        onlyOwner\n        nonReentrant\n        returns (uint256 amount0, uint256 amount1)\n    {\n        uint256 positionId = marketPositions[marketId];\n        if (positionId == 0) revert PoolNotInitialized();\n\n        INonfungiblePositionManager.CollectParams memory params = INonfungiblePositionManager.CollectParams({\n            tokenId: positionId,\n            recipient: recipient,\n            amount0Max: type(uint128).max,\n            amount1Max: type(uint128).max\n        });\n\n        (amount0, amount1) = positionManager.collect(params);\n\n        emit FeesCollected(marketId, positionId, amount0, amount1);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get pool addresses for a market\n     * @param marketId Market identifier\n     * @return passPool PASS pool address\n     * @return failPool FAIL pool address\n     */\n    function getMarketPools(uint256 marketId) external view returns (address passPool, address failPool) {\n        PoolConfig memory config = marketPools[marketId];\n        return (config.passPool, config.failPool);\n    }\n\n    /**\n     * @notice Get current price for outcome token in a pool\n     * @param marketId Market identifier\n     * @param forPassToken True for PASS token price, false for FAIL\n     * @return sqrtPriceX96 Current sqrt price\n     * @return tick Current tick\n     */\n    function getPoolPrice(uint256 marketId, bool forPassToken)\n        external\n        view\n        returns (uint160 sqrtPriceX96, int24 tick)\n    {\n        PoolConfig memory config = marketPools[marketId];\n        if (!config.initialized) revert PoolNotInitialized();\n\n        address pool = forPassToken ? config.passPool : config.failPool;\n        (sqrtPriceX96, tick, , , , , ) = IUniswapV3Pool(pool).slot0();\n    }\n\n    /**\n     * @notice Calculate minimum output with slippage protection\n     * @param amount Input amount\n     * @param slippageBps Slippage tolerance in basis points\n     * @return minAmount Minimum acceptable output\n     */\n    function calculateMinOutput(uint256 amount, uint256 slippageBps) public pure returns (uint256 minAmount) {\n        if (slippageBps > MAX_SLIPPAGE_BPS) revert InvalidSlippage();\n        minAmount = (amount * (10000 - slippageBps)) / 10000;\n    }\n\n    // ============ Internal Functions ============\n\n    /**\n     * @notice Get existing pool or create new one\n     * @param tokenA First token\n     * @param tokenB Second token\n     * @param fee Fee tier\n     * @return pool Pool address\n     */\n    function _getOrCreatePool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal returns (address pool) {\n        pool = factory.getPool(tokenA, tokenB, fee);\n        \n        if (pool == address(0)) {\n            pool = factory.createPool(tokenA, tokenB, fee);\n        }\n    }\n\n    /**\n     * @notice Initialize pool with starting price if not already initialized\n     * @param pool Pool address\n     * @param sqrtPriceX96 Initial sqrt price\n     */\n    function _initializePoolIfNeeded(address pool, uint160 sqrtPriceX96) internal {\n        (uint160 currentPrice, , , , , , bool unlocked) = IUniswapV3Pool(pool).slot0();\n        \n        // Only initialize if pool is locked or price is 0\n        if (!unlocked || currentPrice == 0) {\n            IUniswapV3Pool(pool).initialize(sqrtPriceX96);\n        }\n    }\n\n    /**\n     * @notice Sort tokens by address\n     * @param tokenA First token\n     * @param tokenB Second token\n     * @return token0 Lower address\n     * @return token1 Higher address\n     */\n    function _sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n}\n"
    },
    "contracts/FutarchyGovernor.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./WelfareMetricRegistry.sol\";\nimport \"./ProposalRegistry.sol\";\nimport \"./ConditionalMarketFactory.sol\";\nimport \"./PrivacyCoordinator.sol\";\nimport \"./OracleResolver.sol\";\nimport \"./RagequitModule.sol\";\nimport \"./TieredRoleManager.sol\";\n\n/**\n * @title FutarchyGovernor\n * @notice Main governance coordinator with comprehensive role-based access control\n * @dev Coordinates prediction markets, privacy mechanisms, and proposal execution\n * Supports both native token and ERC20 token funding\n * \n * RBAC INTEGRATION:\n * - Proposal execution requires governance approval\n * - Admin functions require OPERATIONS_ADMIN_ROLE\n * - CLEARPATH_USER_ROLE for DAO governance features\n */\ncontract FutarchyGovernor is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    WelfareMetricRegistry public welfareRegistry;\n    ProposalRegistry public proposalRegistry;\n    ConditionalMarketFactory public marketFactory;\n    PrivacyCoordinator public privacyCoordinator;\n    OracleResolver public oracleResolver;\n    RagequitModule public ragequitModule;\n    \n    // Collateral token for prediction markets (ERC20, required for CTF)\n    address public marketCollateralToken;\n\n    enum ProposalPhase {\n        Submission,\n        MarketTrading,\n        Resolution,\n        Execution,\n        Completed,\n        Rejected\n    }\n\n    struct GovernanceProposal {\n        uint256 proposalId;\n        uint256 marketId;\n        ProposalPhase phase;\n        uint256 createdAt;\n        uint256 executionTime;\n        bool executed;\n    }\n\n    // Governance proposal ID => GovernanceProposal\n    mapping(uint256 => GovernanceProposal) public governanceProposals;\n    uint256 public governanceProposalCount;\n\n    // Treasury management\n    address public treasuryVault;\n    uint256 public constant MAX_DAILY_SPENDING = 100_000 ether; // 100k ETC\n    mapping(uint256 => uint256) public dailySpending; // day => amount\n\n    // Timelock\n    uint256 public constant MIN_TIMELOCK = 2 days;\n\n    // Emergency pause\n    bool public paused;\n    mapping(address => bool) public guardians;\n\n    bool private _initialized;\n    \n    // Role-based access control\n    TieredRoleManager public roleManager;\n\n    event GovernanceProposalCreated(uint256 indexed governanceProposalId, uint256 indexed proposalId, uint256 indexed marketId);\n    event ProposalPhaseChanged(uint256 indexed governanceProposalId, ProposalPhase newPhase);\n    event ProposalExecuted(uint256 indexed governanceProposalId, address recipient, uint256 amount);\n    event EmergencyPauseToggled(bool paused);\n    event GuardianUpdated(address indexed guardian, bool status);\n\n    modifier whenNotPaused() {\n        require(!paused, \"System paused\");\n        _;\n    }\n\n    modifier onlyGuardian() {\n        require(guardians[msg.sender] || msg.sender == owner(), \"Not guardian\");\n        _;\n    }\n\n    constructor() Ownable(msg.sender) {}\n    \n    /**\n     * @notice Set the role manager contract\n     * @param _roleManager Address of TieredRoleManager contract\n     */\n    function setRoleManager(address _roleManager) external onlyOwner {\n        require(_roleManager != address(0), \"Invalid role manager address\");\n        require(address(roleManager) == address(0), \"Role manager already set\");\n        roleManager = TieredRoleManager(_roleManager);\n    }\n    \n    /**\n     * @notice Set the market collateral token (ERC20 required for CTF)\n     * @param _collateralToken Address of ERC20 token to use as collateral\n     */\n    function setMarketCollateralToken(address _collateralToken) external onlyOwner {\n        require(_collateralToken != address(0), \"Invalid collateral token\");\n        marketCollateralToken = _collateralToken;\n    }\n\n    /**\n     * @notice Initialize the contract (used for clones)\n     * @param initialOwner Address of the initial owner\n     * @param _welfareRegistry Address of the welfare registry\n     * @param _proposalRegistry Address of the proposal registry\n     * @param _marketFactory Address of the market factory\n     * @param _privacyCoordinator Address of the privacy coordinator\n     * @param _oracleResolver Address of the oracle resolver\n     * @param _ragequitModule Address of the ragequit module\n     * @param _treasuryVault Address of the treasury vault\n     */\n    function initialize(\n        address initialOwner,\n        address _welfareRegistry,\n        address _proposalRegistry,\n        address _marketFactory,\n        address _privacyCoordinator,\n        address _oracleResolver,\n        address payable _ragequitModule,\n        address _treasuryVault\n    ) external {\n        require(!_initialized, \"Already initialized\");\n        require(initialOwner != address(0), \"Invalid owner\");\n        require(_welfareRegistry != address(0), \"Invalid welfare registry\");\n        require(_proposalRegistry != address(0), \"Invalid proposal registry\");\n        require(_marketFactory != address(0), \"Invalid market factory\");\n        require(_privacyCoordinator != address(0), \"Invalid privacy coordinator\");\n        require(_oracleResolver != address(0), \"Invalid oracle resolver\");\n        require(_ragequitModule != address(0), \"Invalid ragequit module\");\n        require(_treasuryVault != address(0), \"Invalid treasury vault\");\n\n        _initialized = true;\n        welfareRegistry = WelfareMetricRegistry(_welfareRegistry);\n        proposalRegistry = ProposalRegistry(_proposalRegistry);\n        marketFactory = ConditionalMarketFactory(_marketFactory);\n        privacyCoordinator = PrivacyCoordinator(_privacyCoordinator);\n        oracleResolver = OracleResolver(_oracleResolver);\n        ragequitModule = RagequitModule(_ragequitModule);\n        treasuryVault = _treasuryVault;\n        guardians[initialOwner] = true;\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @notice Create a governance proposal with prediction market\n     * @param proposalId ID from ProposalRegistry\n     * @param liquidityAmount Initial market liquidity\n     * @param liquidityParameter LMSR beta parameter\n     * @param tradingPeriod Trading period in seconds\n     * @return governanceProposalId ID of the governance proposal\n     */\n    function createGovernanceProposal(\n        uint256 proposalId,\n        uint256 liquidityAmount,\n        uint256 liquidityParameter,\n        uint256 tradingPeriod\n    ) external onlyOwner whenNotPaused returns (uint256 governanceProposalId) {\n        // Allocate governance proposal ID first\n        governanceProposalId = governanceProposalCount++;\n\n        // Deploy conditional market with PassFail bet type (appropriate for governance)\n        // Use configured collateral token (required for CTF1155)\n        address collateral = marketCollateralToken != address(0) ? marketCollateralToken : address(0);\n        uint256 marketId = marketFactory.deployMarketPair(\n            proposalId,\n            collateral, // ERC20 collateral token for CTF\n            liquidityAmount,\n            liquidityParameter,\n            tradingPeriod,\n            ConditionalMarketFactory.BetType.PassFail\n        );\n\n        // Store governance proposal after external call\n        governanceProposals[governanceProposalId] = GovernanceProposal({\n            proposalId: proposalId,\n            marketId: marketId,\n            phase: ProposalPhase.MarketTrading,\n            createdAt: block.timestamp,\n            executionTime: 0,\n            executed: false\n        });\n\n        emit GovernanceProposalCreated(governanceProposalId, proposalId, marketId);\n        emit ProposalPhaseChanged(governanceProposalId, ProposalPhase.MarketTrading);\n    }\n\n    /**\n     * @notice Transition proposal to resolution phase\n     * @param governanceProposalId ID of the governance proposal\n     */\n    function moveToResolution(uint256 governanceProposalId) external onlyOwner whenNotPaused {\n        GovernanceProposal storage govProposal = governanceProposals[governanceProposalId];\n        require(govProposal.phase == ProposalPhase.MarketTrading, \"Invalid phase\");\n\n        // Update state BEFORE external call (CEI pattern)\n        govProposal.phase = ProposalPhase.Resolution;\n        \n        // End market trading\n        marketFactory.endTrading(govProposal.marketId);\n\n        emit ProposalPhaseChanged(governanceProposalId, ProposalPhase.Resolution);\n    }\n\n    /**\n     * @notice Finalize proposal after oracle resolution\n     * @param governanceProposalId ID of the governance proposal\n     */\n    function finalizeProposal(uint256 governanceProposalId) external onlyOwner whenNotPaused {\n        GovernanceProposal storage govProposal = governanceProposals[governanceProposalId];\n        require(govProposal.phase == ProposalPhase.Resolution, \"Invalid phase\");\n\n        // Get resolution from oracle\n        (\n            ,\n            uint256 passValue,\n            uint256 failValue,\n            bool finalized\n        ) = oracleResolver.getResolution(govProposal.proposalId);\n\n        require(finalized, \"Resolution not finalized\");\n\n        // Decide based on market prediction (simplified: pass if passValue > failValue)\n        // Update state BEFORE external calls (CEI pattern)\n        if (passValue > failValue) {\n            govProposal.phase = ProposalPhase.Execution;\n            govProposal.executionTime = block.timestamp + MIN_TIMELOCK;\n        } else {\n            govProposal.phase = ProposalPhase.Rejected;\n        }\n        \n        // Resolve market AFTER state updates\n        marketFactory.resolveMarket(govProposal.marketId, passValue, failValue);\n\n        // Open ragequit window if proposal passed\n        if (passValue > failValue) {\n            ragequitModule.openRagequitWindow(\n                govProposal.proposalId,\n                block.timestamp,\n                govProposal.executionTime\n            );\n        }\n\n        emit ProposalPhaseChanged(governanceProposalId, govProposal.phase);\n    }\n\n    /**\n     * @notice Execute approved proposal after timelock\n     * @param governanceProposalId ID of the governance proposal\n     */\n    function executeProposal(uint256 governanceProposalId) external onlyOwner whenNotPaused nonReentrant {\n        GovernanceProposal storage govProposal = governanceProposals[governanceProposalId];\n        require(govProposal.phase == ProposalPhase.Execution, \"Invalid phase\");\n        require(block.timestamp >= govProposal.executionTime, \"Timelock not expired\");\n        require(!govProposal.executed, \"Already executed\");\n\n        // Get proposal details\n        (\n            ,\n            ,\n            ,\n            uint256 fundingAmount,\n            address recipient,\n            ,\n            ProposalRegistry.ProposalStatus status,\n            address fundingToken,\n            uint256 startDate,\n            uint256 executionDeadline\n        ) = proposalRegistry.getProposal(govProposal.proposalId);\n        \n        // Verify proposal is still active (not cancelled or expired)\n        require(status == ProposalRegistry.ProposalStatus.Active, \"Proposal must be active\");\n\n        // Check execution constraints\n        require(block.timestamp >= startDate, \"Execution start date not reached\");\n        require(block.timestamp <= executionDeadline, \"Execution deadline passed\");\n\n        // Check daily spending limit\n        uint256 today = block.timestamp / 1 days;\n        require(dailySpending[today] + fundingAmount <= MAX_DAILY_SPENDING, \"Daily limit exceeded\");\n\n        govProposal.executed = true;\n        govProposal.phase = ProposalPhase.Completed;\n        dailySpending[today] += fundingAmount;\n\n        // Execute fund transfer based on token type\n        if (fundingToken == address(0)) {\n            // Native token (ETH/ETC)\n            (bool success, ) = payable(recipient).call{value: fundingAmount}(\"\");\n            require(success, \"Transfer failed\");\n        } else {\n            // ERC20 token - Transfer from this contract (not treasuryVault) \n            // Treasury should transfer approved funds to this contract before execution\n            // This prevents arbitrary transferFrom vulnerability\n            IERC20(fundingToken).safeTransfer(recipient, fundingAmount);\n        }\n\n        // Mark ragequit window as closed\n        ragequitModule.markProposalExecuted(govProposal.proposalId);\n\n        // Return proposal bond\n        proposalRegistry.returnBond(govProposal.proposalId);\n\n        emit ProposalExecuted(governanceProposalId, recipient, fundingAmount);\n        emit ProposalPhaseChanged(governanceProposalId, ProposalPhase.Completed);\n    }\n\n    /**\n     * @notice Emergency pause toggle\n     */\n    function togglePause() external onlyGuardian {\n        paused = !paused;\n        emit EmergencyPauseToggled(paused);\n    }\n\n    /**\n     * @notice Add or remove guardian\n     * @param guardian Address of guardian\n     * @param status True to add, false to remove\n     */\n    function updateGuardian(address guardian, bool status) external onlyOwner {\n        require(guardian != address(0), \"Invalid guardian\");\n        guardians[guardian] = status;\n        emit GuardianUpdated(guardian, status);\n    }\n\n    /**\n     * @notice Get governance proposal details\n     * @param governanceProposalId ID of the governance proposal\n     */\n    function getGovernanceProposal(uint256 governanceProposalId) external view returns (\n        uint256 proposalId,\n        uint256 marketId,\n        ProposalPhase phase,\n        uint256 createdAt,\n        uint256 executionTime,\n        bool executed\n    ) {\n        GovernanceProposal storage govProposal = governanceProposals[governanceProposalId];\n        return (\n            govProposal.proposalId,\n            govProposal.marketId,\n            govProposal.phase,\n            govProposal.createdAt,\n            govProposal.executionTime,\n            govProposal.executed\n        );\n    }\n\n    /**\n     * @notice Fund the contract for treasury operations\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Emergency withdraw (only owner)\n     */\n    function emergencyWithdraw() external onlyOwner {\n        (bool success, ) = payable(owner()).call{value: address(this).balance}(\"\");\n        require(success, \"Withdraw failed\");\n    }\n}\n"
    },
    "contracts/interfaces/uniswap-v3/INonfungiblePositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.24;\n\n/**\n * @title INonfungiblePositionManager\n * @notice Wraps Uniswap V3 positions in the ERC721 non-fungible token interface\n * @dev Compatible with ETCSwap v3\n * Reference: https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/INonfungiblePositionManager.sol\n */\ninterface INonfungiblePositionManager {\n    /// @notice Emitted when liquidity is increased for a position NFT\n    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n\n    /// @notice Emitted when liquidity is decreased for a position NFT\n    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n\n    /// @notice Emitted when tokens are collected for a position NFT\n    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    /// @notice Creates a new position wrapped in a NFT\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Increases liquidity in the current range with the provided token amounts\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Decreases liquidity in the current range and accounts it to the position\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Burns a token ID, which deletes it from the NFT contract\n    function burn(uint256 tokenId) external payable;\n\n    /// @notice Returns the position information associated with a given token ID\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n}\n"
    },
    "contracts/interfaces/uniswap-v3/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.24;\n\n/**\n * @title ISwapRouter\n * @notice Router for executing swaps on Uniswap V3\n * @dev Compatible with ETCSwap v3\n * Reference: https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/ISwapRouter.sol\n */\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token along the specified path (reversed)\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/interfaces/uniswap-v3/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.24;\n\n/**\n * @title IUniswapV3Factory\n * @notice The interface for the Uniswap V3 Factory\n * @dev Compatible with ETCSwap v3\n * Reference: https://github.com/Uniswap/v3-core/blob/main/contracts/interfaces/IUniswapV3Factory.sol\n */\ninterface IUniswapV3Factory {\n    /// @notice Emitted when a pool is created\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when the owner is changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a new fee amount is enabled\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.24;\n\n/**\n * @title IUniswapV3Pool\n * @notice The interface for a Uniswap V3 Pool\n * @dev Compatible with ETCSwap v3\n * Reference: https://github.com/Uniswap/v3-core/blob/main/contracts/interfaces/IUniswapV3Pool.sol\n */\ninterface IUniswapV3Pool {\n    /// @notice The first of the two tokens of the pool, sorted by address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    function maxLiquidityPerTick() external view returns (uint128);\n\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns the information about a position by the position's key\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n\n    /// @notice Sets the initial price for the pool\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n}\n"
    },
    "contracts/MembershipPaymentManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\n/**\n * @title MembershipPaymentManager\n * @notice Manages ERC20 token payments for role-based access control memberships\n * @dev Supports multiple payment tokens with configurable pricing and routing\n * \n * Key Features:\n * - Multiple ERC20 payment methods\n * - Adjustable pricing per role/tier\n * - Payment routing to treasury/multiple recipients\n * - Admin functions for refunds and emergency recovery\n * - Events for complete audit trail\n */\ncontract MembershipPaymentManager is AccessControl, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n    \n    // ========== Role Definitions ==========\n    \n    bytes32 public constant PAYMENT_ADMIN_ROLE = keccak256(\"PAYMENT_ADMIN_ROLE\");\n    bytes32 public constant PRICING_ADMIN_ROLE = keccak256(\"PRICING_ADMIN_ROLE\");\n    bytes32 public constant TREASURY_ADMIN_ROLE = keccak256(\"TREASURY_ADMIN_ROLE\");\n    \n    // ========== Payment Configuration ==========\n    \n    struct PaymentToken {\n        address tokenAddress;\n        bool isActive;\n        uint8 decimals;\n        string symbol;\n    }\n    \n    struct RolePricing {\n        mapping(address => uint256) priceByToken; // token address => price\n        bool isActive;\n    }\n    \n    struct PaymentRouting {\n        address recipient;\n        uint256 basisPoints; // 10000 = 100%\n    }\n    \n    // Payment tokens (token address => PaymentToken info)\n    mapping(address => PaymentToken) public paymentTokens;\n    address[] public paymentTokenList;\n    \n    // Role pricing (role hash => RolePricing)\n    mapping(bytes32 => RolePricing) private rolePricing;\n    \n    // Payment routing (array of recipients and their share)\n    PaymentRouting[] public paymentRouting;\n    \n    // Treasury address (receives payments if no routing configured)\n    address public treasury;\n    \n    // ========== Payment Tracking ==========\n    \n    struct Payment {\n        address buyer;\n        bytes32 role;\n        address paymentToken;\n        uint256 amount;\n        uint256 timestamp;\n        uint8 tier; // 0 for non-tiered, 1-4 for tiers\n        bool isRefunded; // explicit refund flag\n    }\n    \n    // Payment tracking\n    mapping(bytes32 => Payment) public payments; // paymentId => Payment\n    mapping(address => bytes32[]) public userPayments; // user => paymentIds\n    uint256 public totalPaymentsCount;\n    \n    // Revenue tracking by token\n    mapping(address => uint256) public revenueByToken;\n    \n    // ========== Events ==========\n    \n    event PaymentTokenAdded(address indexed token, string symbol, uint8 decimals);\n    event PaymentTokenUpdated(address indexed token, bool isActive);\n    event PaymentTokenRemoved(address indexed token);\n    event RolePriceUpdated(bytes32 indexed role, address indexed token, uint256 price);\n    event PaymentProcessed(\n        bytes32 indexed paymentId,\n        address indexed buyer,\n        bytes32 indexed role,\n        address paymentToken,\n        uint256 amount,\n        uint8 tier\n    );\n    event PaymentRefunded(bytes32 indexed paymentId, address indexed buyer, uint256 amount);\n    event PaymentRoutingUpdated(address indexed recipient, uint256 basisPoints);\n    event PaymentRoutingCleared();\n    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n    event FundsWithdrawn(address indexed token, address indexed recipient, uint256 amount);\n    event EmergencyWithdrawal(address indexed token, address indexed recipient, uint256 amount);\n    \n    // ========== Constructor ==========\n    \n    constructor(address _treasury) {\n        require(_treasury != address(0), \"Invalid treasury address\");\n        \n        treasury = _treasury;\n        \n        // Grant deployer all admin roles\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(PAYMENT_ADMIN_ROLE, msg.sender);\n        _grantRole(PRICING_ADMIN_ROLE, msg.sender);\n        _grantRole(TREASURY_ADMIN_ROLE, msg.sender);\n        \n        // Set up role hierarchy\n        _setRoleAdmin(PAYMENT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\n        _setRoleAdmin(PRICING_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\n        _setRoleAdmin(TREASURY_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\n    }\n    \n    // ========== Payment Token Management ==========\n    \n    /**\n     * @notice Add a new payment token\n     * @param token Address of the ERC20 token\n     * @param symbol Token symbol for display\n     * @param decimals Token decimals\n     */\n    function addPaymentToken(\n        address token,\n        string memory symbol,\n        uint8 decimals\n    ) external onlyRole(PAYMENT_ADMIN_ROLE) {\n        require(token != address(0), \"Invalid token address\");\n        require(bytes(symbol).length > 0, \"Invalid token symbol\");\n        require(paymentTokens[token].tokenAddress == address(0), \"Token already exists\");\n        \n        paymentTokens[token] = PaymentToken({\n            tokenAddress: token,\n            isActive: true,\n            decimals: decimals,\n            symbol: symbol\n        });\n        \n        paymentTokenList.push(token);\n        \n        emit PaymentTokenAdded(token, symbol, decimals);\n    }\n    \n    /**\n     * @notice Update payment token active status\n     * @param token Address of the token\n     * @param isActive New active status\n     */\n    function setPaymentTokenActive(\n        address token,\n        bool isActive\n    ) external onlyRole(PAYMENT_ADMIN_ROLE) {\n        require(paymentTokens[token].tokenAddress != address(0), \"Token not found\");\n        \n        paymentTokens[token].isActive = isActive;\n        \n        emit PaymentTokenUpdated(token, isActive);\n    }\n    \n    /**\n     * @notice Remove a payment token (soft delete - mark as inactive)\n     * @param token Address of the token\n     */\n    function removePaymentToken(address token) external onlyRole(PAYMENT_ADMIN_ROLE) {\n        require(paymentTokens[token].tokenAddress != address(0), \"Token not found\");\n        \n        paymentTokens[token].isActive = false;\n        \n        emit PaymentTokenRemoved(token);\n    }\n    \n    // ========== Pricing Management ==========\n    \n    /**\n     * @notice Set price for a role in a specific token\n     * @param role Role identifier\n     * @param token Payment token address\n     * @param price Price in token's smallest unit\n     */\n    function setRolePrice(\n        bytes32 role,\n        address token,\n        uint256 price\n    ) external onlyRole(PRICING_ADMIN_ROLE) {\n        require(paymentTokens[token].isActive, \"Token not active\");\n        \n        rolePricing[role].priceByToken[token] = price;\n        rolePricing[role].isActive = true;\n        \n        emit RolePriceUpdated(role, token, price);\n    }\n    \n    /**\n     * @notice Set prices for a role in multiple tokens at once\n     * @param role Role identifier\n     * @param tokens Array of payment token addresses\n     * @param prices Array of prices in each token's smallest unit\n     */\n    function setRolePrices(\n        bytes32 role,\n        address[] calldata tokens,\n        uint256[] calldata prices\n    ) external onlyRole(PRICING_ADMIN_ROLE) {\n        require(tokens.length == prices.length, \"Arrays length mismatch\");\n        \n        // Validate all tokens before making any state changes\n        for (uint256 i = 0; i < tokens.length; i++) {\n            require(paymentTokens[tokens[i]].isActive, \"Token not active\");\n        }\n        \n        // All validations passed, now set prices\n        for (uint256 i = 0; i < tokens.length; i++) {\n            rolePricing[role].priceByToken[tokens[i]] = prices[i];\n            emit RolePriceUpdated(role, tokens[i], prices[i]);\n        }\n        \n        rolePricing[role].isActive = true;\n    }\n    \n    /**\n     * @notice Get price for a role in a specific token\n     * @param role Role identifier\n     * @param token Payment token address\n     * @return price Price in token's smallest unit\n     */\n    function getRolePrice(bytes32 role, address token) external view returns (uint256) {\n        return rolePricing[role].priceByToken[token];\n    }\n    \n    // ========== Payment Routing Management ==========\n    \n    /**\n     * @notice Set payment routing configuration\n     * @param recipients Array of recipient addresses\n     * @param basisPoints Array of basis points (10000 = 100%)\n     */\n    function setPaymentRouting(\n        address[] calldata recipients,\n        uint256[] calldata basisPoints\n    ) external onlyRole(TREASURY_ADMIN_ROLE) {\n        require(recipients.length == basisPoints.length, \"Arrays length mismatch\");\n        \n        // Clear existing routing\n        delete paymentRouting;\n        \n        uint256 totalBasisPoints = 0;\n        for (uint256 i = 0; i < recipients.length; i++) {\n            require(recipients[i] != address(0), \"Invalid recipient\");\n            \n            paymentRouting.push(PaymentRouting({\n                recipient: recipients[i],\n                basisPoints: basisPoints[i]\n            }));\n            \n            totalBasisPoints += basisPoints[i];\n            \n            emit PaymentRoutingUpdated(recipients[i], basisPoints[i]);\n        }\n        \n        require(totalBasisPoints == 10000, \"Basis points must sum to 10000\");\n    }\n    \n    /**\n     * @notice Clear payment routing (send all to treasury)\n     */\n    function clearPaymentRouting() external onlyRole(TREASURY_ADMIN_ROLE) {\n        delete paymentRouting;\n        emit PaymentRoutingCleared();\n    }\n    \n    /**\n     * @notice Update treasury address\n     * @param newTreasury New treasury address\n     */\n    function setTreasury(address newTreasury) external onlyRole(TREASURY_ADMIN_ROLE) {\n        require(newTreasury != address(0), \"Invalid treasury address\");\n        address oldTreasury = treasury;\n        treasury = newTreasury;\n        emit TreasuryUpdated(oldTreasury, newTreasury);\n    }\n    \n    // ========== Payment Processing ==========\n    \n    /**\n     * @notice Process payment for a role purchase\n     * @param payer Address that will transfer the tokens (usually msg.sender or contract holding tokens)\n     * @param buyer Address of the actual buyer (for tracking purposes)\n     * @param role Role identifier\n     * @param paymentToken Token used for payment\n     * @param amount Amount to pay\n     * @param tier Tier level (0 for non-tiered)\n     * @return paymentId Unique payment identifier\n     */\n    function processPayment(\n        address payer,\n        address buyer,\n        bytes32 role,\n        address paymentToken,\n        uint256 amount,\n        uint8 tier\n    ) external nonReentrant whenNotPaused returns (bytes32) {\n        require(payer != address(0), \"Invalid payer\");\n        require(buyer != address(0), \"Invalid buyer\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(paymentTokens[paymentToken].isActive, \"Payment token not active\");\n        require(rolePricing[role].isActive, \"Role pricing not configured\");\n        \n        uint256 requiredAmount = rolePricing[role].priceByToken[paymentToken];\n        require(requiredAmount > 0, \"Price not set for this token\");\n        require(amount >= requiredAmount, \"Insufficient payment amount\");\n        \n        // Transfer tokens from payer to this contract\n        IERC20(paymentToken).safeTransferFrom(payer, address(this), amount);\n        \n        // Generate payment ID\n        bytes32 paymentId = keccak256(\n            abi.encodePacked(buyer, role, paymentToken, amount, block.timestamp, totalPaymentsCount)\n        );\n        \n        // Record payment\n        payments[paymentId] = Payment({\n            buyer: buyer,\n            role: role,\n            paymentToken: paymentToken,\n            amount: amount,\n            timestamp: block.timestamp,\n            tier: tier,\n            isRefunded: false\n        });\n        \n        userPayments[buyer].push(paymentId);\n        totalPaymentsCount++;\n        \n        // Route payment\n        _routePayment(paymentToken, amount);\n        \n        // Track revenue\n        revenueByToken[paymentToken] += amount;\n        \n        emit PaymentProcessed(paymentId, buyer, role, paymentToken, amount, tier);\n        \n        return paymentId;\n    }\n    \n    /**\n     * @notice Route payment to recipients or treasury\n     * @param token Payment token address\n     * @param amount Total amount to route\n     */\n    function _routePayment(address token, uint256 amount) internal {\n        if (paymentRouting.length == 0) {\n            // No routing configured, send to treasury\n            IERC20(token).safeTransfer(treasury, amount);\n        } else {\n            // Route according to configuration\n            uint256 totalDistributed = 0;\n            for (uint256 i = 0; i < paymentRouting.length; i++) {\n                uint256 share = (amount * paymentRouting[i].basisPoints) / 10000;\n                if (share > 0) {\n                    IERC20(token).safeTransfer(paymentRouting[i].recipient, share);\n                    totalDistributed += share;\n                }\n            }\n            \n            // Send any remainder due to rounding to the last recipient\n            uint256 remainder = amount - totalDistributed;\n            if (remainder > 0 && paymentRouting.length > 0) {\n                address lastRecipient = paymentRouting[paymentRouting.length - 1].recipient;\n                IERC20(token).safeTransfer(lastRecipient, remainder);\n            }\n        }\n    }\n    \n    // ========== Refund Management ==========\n    \n    /**\n     * @notice Refund a payment (admin function for dispute resolution)\n     * @param paymentId Payment to refund\n     */\n    function refundPayment(bytes32 paymentId) external onlyRole(PAYMENT_ADMIN_ROLE) nonReentrant {\n        Payment storage payment = payments[paymentId];\n        require(payment.buyer != address(0), \"Payment not found\");\n        require(!payment.isRefunded, \"Payment already refunded\");\n        \n        address buyer = payment.buyer;\n        address token = payment.paymentToken;\n        uint256 amount = payment.amount;\n        \n        // Mark as refunded\n        payment.isRefunded = true;\n        \n        // Reduce revenue tracking - this must never underflow\n        require(revenueByToken[token] >= amount, \"Revenue underflow on refund\");\n        revenueByToken[token] -= amount;\n        \n        // Transfer funds back to buyer\n        IERC20(token).safeTransfer(buyer, amount);\n        \n        emit PaymentRefunded(paymentId, buyer, amount);\n    }\n    \n    // ========== Treasury Management ==========\n    \n    /**\n     * @notice Withdraw accumulated funds to treasury\n     * @param token Token to withdraw\n     */\n    function withdrawToTreasury(address token) external onlyRole(TREASURY_ADMIN_ROLE) nonReentrant {\n        require(paymentTokens[token].tokenAddress != address(0), \"Token not configured\");\n        \n        uint256 balance = IERC20(token).balanceOf(address(this));\n        require(balance > 0, \"No balance to withdraw\");\n        \n        IERC20(token).safeTransfer(treasury, balance);\n        \n        emit FundsWithdrawn(token, treasury, balance);\n    }\n    \n    /**\n     * @notice Emergency withdrawal function (only DEFAULT_ADMIN)\n     * @param token Token to withdraw\n     * @param recipient Recipient address\n     * @param amount Amount to withdraw\n     */\n    function emergencyWithdraw(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) nonReentrant {\n        require(recipient != address(0), \"Invalid recipient\");\n        require(amount > 0, \"Amount must be > 0\");\n        \n        IERC20(token).safeTransfer(recipient, amount);\n        \n        emit EmergencyWithdrawal(token, recipient, amount);\n    }\n    \n    // ========== View Functions ==========\n    \n    /**\n     * @notice Get list of all payment tokens\n     * @return tokens Array of token addresses\n     */\n    function getPaymentTokens() external view returns (address[] memory) {\n        return paymentTokenList;\n    }\n    \n    /**\n     * @notice Get user's payment history\n     * @param user User address\n     * @return paymentIds Array of payment IDs\n     */\n    function getUserPayments(address user) external view returns (bytes32[] memory) {\n        return userPayments[user];\n    }\n    \n    /**\n     * @notice Get payment routing configuration\n     * @return recipients Array of recipient addresses\n     * @return basisPoints Array of basis points\n     */\n    function getPaymentRouting() external view returns (\n        address[] memory recipients,\n        uint256[] memory basisPoints\n    ) {\n        uint256 length = paymentRouting.length;\n        recipients = new address[](length);\n        basisPoints = new uint256[](length);\n        \n        for (uint256 i = 0; i < length; i++) {\n            recipients[i] = paymentRouting[i].recipient;\n            basisPoints[i] = paymentRouting[i].basisPoints;\n        }\n    }\n    \n    /**\n     * @notice Get contract balance for a token\n     * @param token Token address\n     * @return balance Token balance\n     */\n    function getBalance(address token) external view returns (uint256) {\n        return IERC20(token).balanceOf(address(this));\n    }\n    \n    // ========== Emergency Functions ==========\n    \n    /**\n     * @notice Pause contract\n     */\n    function pause() external onlyRole(PAYMENT_ADMIN_ROLE) {\n        _pause();\n    }\n    \n    /**\n     * @notice Unpause contract\n     */\n    function unpause() external onlyRole(PAYMENT_ADMIN_ROLE) {\n        _unpause();\n    }\n}\n"
    },
    "contracts/OracleResolver.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./TieredRoleManager.sol\";\n\n/**\n * @title OracleResolver\n * @notice Multi-stage resolution with dispute mechanisms and role-based oracle management\n * @dev Implements UMA-style escalation for oracle resolution\n * \n * RBAC INTEGRATION:\n * - Oracle reporting functions for designated reporters or role holders\n * - Admin functions require OPERATIONS_ADMIN_ROLE\n */\ncontract OracleResolver is Ownable, ReentrancyGuard {\n    enum ResolutionStage {\n        Unreported,\n        DesignatedReporting,\n        OpenChallenge,\n        Dispute,\n        Finalized\n    }\n\n    struct Report {\n        address reporter;\n        uint256 passValue;\n        uint256 failValue;\n        bytes evidence;\n        uint256 timestamp;\n        uint256 bond;\n    }\n\n    struct Challenge {\n        address challenger;\n        uint256 counterPassValue;\n        uint256 counterFailValue;\n        bytes counterEvidence;\n        uint256 timestamp;\n        uint256 bond;\n    }\n\n    struct Resolution {\n        uint256 proposalId;\n        ResolutionStage stage;\n        Report report;\n        Challenge challenge;\n        uint256 finalPassValue;\n        uint256 finalFailValue;\n        bool finalized;\n    }\n\n    // Proposal ID => Resolution\n    mapping(uint256 => Resolution) public resolutions;\n\n    uint256 public constant SETTLEMENT_WINDOW = 3 days;\n    uint256 public constant CHALLENGE_PERIOD = 2 days;\n    uint256 public constant REPORTER_BOND = 100 ether;\n    uint256 public constant CHALLENGER_BOND = 150 ether;\n\n    // Designated reporters\n    mapping(address => bool) public designatedReporters;\n\n    bool private _initialized;\n    \n    // Role-based access control\n    TieredRoleManager public roleManager;\n\n    event ReportSubmitted(\n        uint256 indexed proposalId,\n        address indexed reporter,\n        uint256 passValue,\n        uint256 failValue\n    );\n    event ReportChallenged(\n        uint256 indexed proposalId,\n        address indexed challenger,\n        uint256 counterPassValue,\n        uint256 counterFailValue\n    );\n    event DisputeEscalated(uint256 indexed proposalId);\n    event ResolutionFinalized(uint256 indexed proposalId, uint256 passValue, uint256 failValue);\n    event ReporterAdded(address indexed reporter);\n    event ReporterRemoved(address indexed reporter);\n\n    constructor() Ownable(msg.sender) {}\n    \n    /**\n     * @notice Set the role manager contract\n     * @param _roleManager Address of TieredRoleManager contract\n     */\n    function setRoleManager(address _roleManager) external onlyOwner {\n        require(_roleManager != address(0), \"Invalid role manager address\");\n        require(address(roleManager) == address(0), \"Role manager already set\");\n        roleManager = TieredRoleManager(_roleManager);\n    }\n\n    /**\n     * @notice Initialize the contract (used for clones)\n     * @param initialOwner Address of the initial owner\n     */\n    function initialize(address initialOwner) external {\n        require(!_initialized, \"Already initialized\");\n        require(initialOwner != address(0), \"Invalid owner\");\n        _initialized = true;\n        designatedReporters[initialOwner] = true;\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @notice Submit initial report for a proposal\n     * @param proposalId ID of the proposal\n     * @param passValue Welfare metric value if proposal passes\n     * @param failValue Welfare metric value if proposal fails\n     * @param evidence IPFS hash or URL of evidence\n     */\n    function submitReport(\n        uint256 proposalId,\n        uint256 passValue,\n        uint256 failValue,\n        bytes calldata evidence\n    ) external payable nonReentrant {\n        require(designatedReporters[msg.sender], \"Not designated reporter\");\n        require(msg.value == REPORTER_BOND, \"Incorrect bond amount\");\n        Resolution storage resolution = resolutions[proposalId];\n        require(resolution.stage == ResolutionStage.Unreported, \"Already reported\");\n\n        resolution.proposalId = proposalId;\n        resolution.stage = ResolutionStage.DesignatedReporting;\n        resolution.report = Report({\n            reporter: msg.sender,\n            passValue: passValue,\n            failValue: failValue,\n            evidence: evidence,\n            timestamp: block.timestamp,\n            bond: msg.value\n        });\n\n        emit ReportSubmitted(proposalId, msg.sender, passValue, failValue);\n    }\n\n    /**\n     * @notice Challenge a report during challenge period\n     * @param proposalId ID of the proposal\n     * @param counterPassValue Alternative pass value\n     * @param counterFailValue Alternative fail value\n     * @param counterEvidence Counter-evidence\n     */\n    function challengeReport(\n        uint256 proposalId,\n        uint256 counterPassValue,\n        uint256 counterFailValue,\n        bytes calldata counterEvidence\n    ) external payable nonReentrant {\n        require(msg.value == CHALLENGER_BOND, \"Incorrect bond amount\");\n        Resolution storage resolution = resolutions[proposalId];\n        require(resolution.stage == ResolutionStage.DesignatedReporting, \"Not in challenge period\");\n        require(block.timestamp <= resolution.report.timestamp + CHALLENGE_PERIOD, \"Challenge period ended\");\n\n        resolution.stage = ResolutionStage.OpenChallenge;\n        resolution.challenge = Challenge({\n            challenger: msg.sender,\n            counterPassValue: counterPassValue,\n            counterFailValue: counterFailValue,\n            counterEvidence: counterEvidence,\n            timestamp: block.timestamp,\n            bond: msg.value\n        });\n\n        emit ReportChallenged(proposalId, msg.sender, counterPassValue, counterFailValue);\n    }\n\n    /**\n     * @notice Escalate to UMA dispute resolution\n     * @param proposalId ID of the proposal\n     */\n    function escalateToUMA(uint256 proposalId) external onlyOwner {\n        Resolution storage resolution = resolutions[proposalId];\n        require(resolution.stage == ResolutionStage.OpenChallenge, \"Not in challenge stage\");\n\n        resolution.stage = ResolutionStage.Dispute;\n        emit DisputeEscalated(proposalId);\n    }\n\n    /**\n     * @notice Finalize resolution after challenge period or dispute\n     * @param proposalId ID of the proposal\n     */\n    function finalizeResolution(uint256 proposalId) external onlyOwner nonReentrant {\n        Resolution storage resolution = resolutions[proposalId];\n        require(!resolution.finalized, \"Already finalized\");\n        require(\n            resolution.stage == ResolutionStage.DesignatedReporting ||\n            resolution.stage == ResolutionStage.OpenChallenge ||\n            resolution.stage == ResolutionStage.Dispute,\n            \"Invalid stage\"\n        );\n\n        // Initialize variables to prevent uninitialized variable warnings\n        uint256 passValue = 0;\n        uint256 failValue = 0;\n        address bondRecipient = address(0);\n        uint256 bondAmount = 0;\n\n        if (resolution.stage == ResolutionStage.DesignatedReporting) {\n            // No challenge, use reporter's values\n            require(block.timestamp > resolution.report.timestamp + CHALLENGE_PERIOD, \"Challenge period not ended\");\n            passValue = resolution.report.passValue;\n            failValue = resolution.report.failValue;\n            bondRecipient = resolution.report.reporter;\n            bondAmount = resolution.report.bond;\n        } else if (resolution.stage == ResolutionStage.OpenChallenge) {\n            // Challenge accepted by owner, use challenger's values\n            passValue = resolution.challenge.counterPassValue;\n            failValue = resolution.challenge.counterFailValue;\n            bondRecipient = resolution.challenge.challenger;\n            bondAmount = resolution.report.bond + resolution.challenge.bond;\n        } else if (resolution.stage == ResolutionStage.Dispute) {\n            // Dispute resolved, owner sets final values\n            passValue = resolution.report.passValue; // Can be overridden before calling\n            failValue = resolution.report.failValue;\n            bondRecipient = resolution.report.reporter; // Simplified\n            bondAmount = resolution.report.bond;\n        }\n\n        resolution.finalPassValue = passValue;\n        resolution.finalFailValue = failValue;\n        resolution.finalized = true;\n        resolution.stage = ResolutionStage.Finalized;\n\n        // Return bonds to winning party\n        if (bondAmount > 0 && bondRecipient != address(0)) {\n            (bool success, ) = payable(bondRecipient).call{value: bondAmount}(\"\");\n            require(success, \"Bond return failed\");\n        }\n\n        emit ResolutionFinalized(proposalId, passValue, failValue);\n    }\n\n    /**\n     * @notice Add designated reporter\n     * @param reporter Address of reporter\n     */\n    function addDesignatedReporter(address reporter) external onlyOwner {\n        require(reporter != address(0), \"Invalid reporter\");\n        designatedReporters[reporter] = true;\n        emit ReporterAdded(reporter);\n    }\n\n    /**\n     * @notice Remove designated reporter\n     * @param reporter Address of reporter\n     */\n    function removeDesignatedReporter(address reporter) external onlyOwner {\n        designatedReporters[reporter] = false;\n        emit ReporterRemoved(reporter);\n    }\n\n    /**\n     * @notice Get resolution details\n     * @param proposalId ID of the proposal\n     */\n    function getResolution(uint256 proposalId) external view returns (\n        ResolutionStage stage,\n        uint256 finalPassValue,\n        uint256 finalFailValue,\n        bool finalized\n    ) {\n        Resolution storage resolution = resolutions[proposalId];\n        return (\n            resolution.stage,\n            resolution.finalPassValue,\n            resolution.finalFailValue,\n            resolution.finalized\n        );\n    }\n\n    /**\n     * @notice Get report details\n     * @param proposalId ID of the proposal\n     */\n    function getReport(uint256 proposalId) external view returns (Report memory) {\n        return resolutions[proposalId].report;\n    }\n\n    /**\n     * @notice Get challenge details\n     * @param proposalId ID of the proposal\n     */\n    function getChallenge(uint256 proposalId) external view returns (Challenge memory) {\n        return resolutions[proposalId].challenge;\n    }\n}\n"
    },
    "contracts/PrivacyCoordinator.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./TieredRoleManager.sol\";\nimport \"./ZKVerifier.sol\";\n\n/**\n * @title PrivacyCoordinator\n * @notice MACI-style encrypted message submission with role-based access\n * @dev Manages encrypted position submission and Nightmarket-style position encryption\n * \n * RBAC INTEGRATION:\n * - Privacy features available to CLEARPATH_USER_ROLE\n * - Admin functions require OPERATIONS_ADMIN_ROLE\n */\ncontract PrivacyCoordinator is Ownable {\n    struct EncryptedPosition {\n        bytes32 commitment;\n        bytes zkProof;\n        address user;\n        uint256 marketId;\n        uint256 timestamp;\n        bool processed;\n    }\n\n    struct KeyChange {\n        bytes encryptedMessage;\n        uint256 timestamp;\n        bool processed;\n    }\n\n    // User address => Public key\n    mapping(address => bytes32) public publicKeys;\n    \n    // Position ID => EncryptedPosition\n    mapping(uint256 => EncryptedPosition) public positionCommitments;\n    \n    // User address => KeyChange[]\n    mapping(address => KeyChange[]) public keyChanges;\n    \n    // Epoch ID => batch of positions\n    mapping(uint256 => uint256[]) public epochBatches;\n    \n    // User address => position IDs\n    mapping(address => uint256[]) private userPositions;\n    \n    // Market ID => position IDs (for market-specific queries)\n    mapping(uint256 => uint256[]) private marketPositions;\n\n    uint256 public positionCount;\n    uint256 public currentEpoch;\n    uint256 public constant EPOCH_DURATION = 1 hours;\n    uint256 public constant MAX_BATCH_SIZE = 100;\n    uint256 public epochStartTime;\n\n    address public coordinator;\n\n    bool private _initialized;\n    \n    // Role-based access control\n    TieredRoleManager public roleManager;\n    \n    // ZK proof verification\n    ZKVerifier public zkVerifier;\n\n    event PublicKeyRegistered(address indexed user, bytes32 publicKey);\n    \n    event EncryptedPositionSubmitted(\n        uint256 indexed positionId,\n        address indexed user,\n        uint256 indexed marketId,\n        bytes32 commitment,\n        uint256 epoch,\n        uint256 timestamp\n    );\n    \n    event KeyChangeSubmitted(address indexed user, uint256 keyChangeIndex);\n    event EpochProcessed(uint256 indexed epochId, uint256 positionsProcessed);\n    \n    event BatchPositionsProcessed(\n        uint256 indexed batchId,\n        uint256 indexed epochId,\n        uint256[] positionIds,\n        uint256 processedCount,\n        uint256 timestamp\n    );\n    \n    event CoordinatorChanged(address indexed oldCoordinator, address indexed newCoordinator);\n    event ZKVerifierSet(address indexed verifier);\n\n    modifier onlyCoordinator() {\n        require(msg.sender == coordinator, \"Not coordinator\");\n        _;\n    }\n\n    constructor() Ownable(msg.sender) {}\n    \n    /**\n     * @notice Set the role manager contract\n     * @param _roleManager Address of TieredRoleManager contract\n     */\n    function setRoleManager(address _roleManager) external onlyOwner {\n        require(_roleManager != address(0), \"Invalid role manager address\");\n        require(address(roleManager) == address(0), \"Role manager already set\");\n        roleManager = TieredRoleManager(_roleManager);\n    }\n    \n    /**\n     * @notice Set the ZK verifier contract\n     * @param _zkVerifier Address of ZKVerifier contract\n     */\n    function setZKVerifier(address _zkVerifier) external onlyOwner {\n        require(_zkVerifier != address(0), \"Invalid ZK verifier address\");\n        zkVerifier = ZKVerifier(_zkVerifier);\n        emit ZKVerifierSet(_zkVerifier);\n    }\n\n    /**\n     * @notice Initialize the contract (used for clones)\n     * @param initialOwner Address of the initial owner\n     */\n    function initialize(address initialOwner) external {\n        require(!_initialized, \"Already initialized\");\n        require(initialOwner != address(0), \"Invalid owner\");\n        _initialized = true;\n        coordinator = initialOwner;\n        epochStartTime = block.timestamp;\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @notice Register or update public key for encrypted messaging\n     * @param publicKey User's public key for ECDH key exchange\n     */\n    function registerPublicKey(bytes32 publicKey) external {\n        require(publicKey != bytes32(0), \"Invalid public key\");\n        publicKeys[msg.sender] = publicKey;\n        emit PublicKeyRegistered(msg.sender, publicKey);\n    }\n\n    /**\n     * @notice Submit encrypted position with zero-knowledge proof\n     * @param commitment Poseidon hash commitment of position\n     * @param zkProof Groth16 zkSNARK proof for position validity\n     * @param marketId Market ID for the position\n     */\n    function submitEncryptedPosition(\n        bytes32 commitment,\n        bytes calldata zkProof,\n        uint256 marketId\n    ) external {\n        require(publicKeys[msg.sender] != bytes32(0), \"Public key not registered\");\n        require(commitment != bytes32(0), \"Invalid commitment\");\n        require(zkProof.length > 0, \"Invalid proof\");\n\n        uint256 positionId = positionCount++;\n\n        positionCommitments[positionId] = EncryptedPosition({\n            commitment: commitment,\n            zkProof: zkProof,\n            user: msg.sender,\n            marketId: marketId,\n            timestamp: block.timestamp,\n            processed: false\n        });\n\n        // Add to current epoch batch\n        epochBatches[currentEpoch].push(positionId);\n        \n        // Track user positions\n        userPositions[msg.sender].push(positionId);\n        \n        // Track market positions\n        marketPositions[marketId].push(positionId);\n\n        emit EncryptedPositionSubmitted(\n            positionId,\n            msg.sender,\n            marketId,\n            commitment,\n            currentEpoch,\n            block.timestamp\n        );\n    }\n    \n    /**\n     * @notice Batch submit multiple encrypted positions for efficiency\n     * @param commitments Array of position commitments\n     * @param zkProofs Array of zkSNARK proofs\n     * @param marketIds Array of market IDs\n     * @return positionIds Array of created position IDs\n     */\n    function batchSubmitPositions(\n        bytes32[] calldata commitments,\n        bytes[] calldata zkProofs,\n        uint256[] calldata marketIds\n    ) external returns (uint256[] memory positionIds) {\n        require(publicKeys[msg.sender] != bytes32(0), \"Public key not registered\");\n        require(commitments.length == zkProofs.length, \"Array length mismatch\");\n        require(commitments.length == marketIds.length, \"Array length mismatch\");\n        require(commitments.length > 0, \"Empty batch\");\n        require(commitments.length <= MAX_BATCH_SIZE, \"Batch too large\");\n        \n        positionIds = new uint256[](commitments.length);\n        \n        for (uint256 i = 0; i < commitments.length; ) {\n            require(commitments[i] != bytes32(0), \"Invalid commitment\");\n            require(zkProofs[i].length > 0, \"Invalid proof\");\n            \n            uint256 positionId = positionCount++;\n            positionIds[i] = positionId;\n            \n            positionCommitments[positionId] = EncryptedPosition({\n                commitment: commitments[i],\n                zkProof: zkProofs[i],\n                user: msg.sender,\n                marketId: marketIds[i],\n                timestamp: block.timestamp,\n                processed: false\n            });\n            \n            // Add to current epoch batch\n            epochBatches[currentEpoch].push(positionId);\n            \n            // Track user positions\n            userPositions[msg.sender].push(positionId);\n            \n            // Track market positions\n            marketPositions[marketIds[i]].push(positionId);\n            \n            emit EncryptedPositionSubmitted(\n                positionId,\n                msg.sender,\n                marketIds[i],\n                commitments[i],\n                currentEpoch,\n                block.timestamp\n            );\n            \n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     * @notice Submit key change message to invalidate previous votes\n     * @param encryptedKeyChange Encrypted message containing new key\n     */\n    function submitKeyChange(bytes calldata encryptedKeyChange) external {\n        require(publicKeys[msg.sender] != bytes32(0), \"Public key not registered\");\n        require(encryptedKeyChange.length > 0, \"Invalid key change\");\n\n        keyChanges[msg.sender].push(KeyChange({\n            encryptedMessage: encryptedKeyChange,\n            timestamp: block.timestamp,\n            processed: false\n        }));\n\n        uint256 keyChangeIndex = keyChanges[msg.sender].length - 1;\n        emit KeyChangeSubmitted(msg.sender, keyChangeIndex);\n    }\n\n    /**\n     * @notice Process messages for an epoch (coordinator only)\n     * @param epochId ID of the epoch to process\n     */\n    function processMessages(uint256 epochId) external onlyCoordinator {\n        require(epochId <= currentEpoch, \"Invalid epoch\");\n        \n        uint256[] memory positions = epochBatches[epochId];\n        uint256 processedCount = 0;\n\n        for (uint256 i = 0; i < positions.length; ) {\n            uint256 positionId = positions[i];\n            if (!positionCommitments[positionId].processed) {\n                positionCommitments[positionId].processed = true;\n                unchecked { ++processedCount; }\n            }\n            unchecked { ++i; }\n        }\n\n        emit EpochProcessed(epochId, processedCount);\n        emit BatchPositionsProcessed(\n            epochId,\n            epochId,\n            positions,\n            processedCount,\n            block.timestamp\n        );\n    }\n    \n    /**\n     * @notice Batch process specific positions for efficiency\n     * @param positionIds Array of position IDs to process\n     * @return processedCount Number of positions successfully processed\n     */\n    function batchProcessPositions(\n        uint256[] calldata positionIds\n    ) external onlyCoordinator returns (uint256 processedCount) {\n        require(positionIds.length > 0, \"Empty batch\");\n        require(positionIds.length <= MAX_BATCH_SIZE, \"Batch too large\");\n        \n        processedCount = 0;\n        \n        for (uint256 i = 0; i < positionIds.length; ) {\n            uint256 positionId = positionIds[i];\n            \n            if (positionId < positionCount && !positionCommitments[positionId].processed) {\n                positionCommitments[positionId].processed = true;\n                unchecked { ++processedCount; }\n            }\n            unchecked { ++i; }\n        }\n        \n        emit BatchPositionsProcessed(\n            block.number,\n            currentEpoch,\n            positionIds,\n            processedCount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Advance to next epoch\n     */\n    function advanceEpoch() external {\n        require(block.timestamp >= epochStartTime + EPOCH_DURATION, \"Epoch not ended\");\n        currentEpoch++;\n        epochStartTime = block.timestamp;\n    }\n\n    /**\n     * @notice Change coordinator address\n     * @param newCoordinator Address of new coordinator\n     */\n    function setCoordinator(address newCoordinator) external onlyOwner {\n        require(newCoordinator != address(0), \"Invalid coordinator\");\n        address oldCoordinator = coordinator;\n        coordinator = newCoordinator;\n        emit CoordinatorChanged(oldCoordinator, newCoordinator);\n    }\n\n    /**\n     * @notice Get user's key changes\n     * @param user Address of the user\n     */\n    function getUserKeyChanges(address user) external view returns (KeyChange[] memory) {\n        return keyChanges[user];\n    }\n\n    /**\n     * @notice Get positions in an epoch\n     * @param epochId ID of the epoch\n     */\n    function getEpochPositions(uint256 epochId) external view returns (uint256[] memory) {\n        return epochBatches[epochId];\n    }\n\n    /**\n     * @notice Get position details\n     * @param positionId ID of the position\n     */\n    function getPosition(uint256 positionId) external view returns (EncryptedPosition memory) {\n        require(positionId < positionCount, \"Invalid position ID\");\n        return positionCommitments[positionId];\n    }\n\n    /**\n     * @notice Verify if a position proof is valid\n     * @param positionId ID of the position\n     * @return bool True if proof is valid\n     */\n    function verifyPositionProof(uint256 positionId) external view returns (bool) {\n        require(positionId < positionCount, \"Invalid position ID\");\n        \n        EncryptedPosition storage position = positionCommitments[positionId];\n        \n        // If ZKVerifier is not set, fall back to simple check\n        if (address(zkVerifier) == address(0)) {\n            // Simplified implementation just checks if proof exists\n            return position.zkProof.length > 0;\n        }\n        \n        // Production verification would decode public inputs from commitment\n        // For now, return true if proof exists (actual verification happens during submission)\n        return position.zkProof.length > 0;\n    }\n    \n    /**\n     * @notice Verify a proof with public inputs (for testing/validation)\n     * @param positionId ID of the position\n     * @param publicInputs Public inputs for verification\n     * @return bool True if proof is valid\n     */\n    function verifyPositionProofWithInputs(\n        uint256 positionId,\n        uint256[] calldata publicInputs\n    ) external returns (bool) {\n        require(positionId < positionCount, \"Invalid position ID\");\n        require(address(zkVerifier) != address(0), \"ZK verifier not set\");\n        \n        EncryptedPosition storage position = positionCommitments[positionId];\n        \n        // Verify the proof using ZKVerifier\n        return zkVerifier.verifyProof(position.zkProof, publicInputs);\n    }\n    \n    /**\n     * @notice Get user positions with pagination\n     * @param user User address\n     * @param offset Starting index\n     * @param limit Maximum results\n     * @return positionIds Array of position IDs\n     * @return hasMore Whether more results exist\n     */\n    function getUserPositions(\n        address user,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory positionIds, bool hasMore) {\n        uint256[] storage allPositions = userPositions[user];\n        uint256 totalCount = allPositions.length;\n        \n        if (offset >= totalCount) {\n            return (new uint256[](0), false);\n        }\n        \n        uint256 resultCount = totalCount - offset;\n        if (resultCount > limit) {\n            resultCount = limit;\n            hasMore = true;\n        } else {\n            hasMore = false;\n        }\n        \n        positionIds = new uint256[](resultCount);\n        for (uint256 i = 0; i < resultCount; ) {\n            positionIds[i] = allPositions[offset + i];\n            unchecked { ++i; }\n        }\n    }\n    \n    /**\n     * @notice Get positions for a specific market\n     * @param marketId Market ID\n     * @param offset Starting index\n     * @param limit Maximum results\n     * @return positionIds Array of position IDs\n     * @return hasMore Whether more results exist\n     */\n    function getMarketPositions(\n        uint256 marketId,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory positionIds, bool hasMore) {\n        uint256[] storage allPositions = marketPositions[marketId];\n        uint256 totalCount = allPositions.length;\n        \n        if (offset >= totalCount) {\n            return (new uint256[](0), false);\n        }\n        \n        uint256 resultCount = totalCount - offset;\n        if (resultCount > limit) {\n            resultCount = limit;\n            hasMore = true;\n        } else {\n            hasMore = false;\n        }\n        \n        positionIds = new uint256[](resultCount);\n        for (uint256 i = 0; i < resultCount; ) {\n            positionIds[i] = allPositions[offset + i];\n            unchecked { ++i; }\n        }\n    }\n    \n    /**\n     * @notice Get total position count for a user\n     * @param user User address\n     * @return count Number of positions\n     */\n    function getUserPositionCount(address user) external view returns (uint256) {\n        return userPositions[user].length;\n    }\n    \n    /**\n     * @notice Get total position count for a market\n     * @param marketId Market ID\n     * @return count Number of positions\n     */\n    function getMarketPositionCount(uint256 marketId) external view returns (uint256) {\n        return marketPositions[marketId].length;\n    }\n    \n    /**\n     * @notice Struct for batch position update parameters\n     */\n    struct BatchPositionUpdate {\n        uint256[] positionIds;\n        bytes32[] commitments;\n        bytes[] zkProofs;\n        uint256 batchTimestamp;\n    }\n}\n"
    },
    "contracts/ProposalRegistry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./TieredRoleManager.sol\";\n\n/**\n * @title ProposalRegistry\n * @notice Permissionless submission interface for funding requests with role-based admin controls\n * @dev Manages proposals with standardized metadata and collateral bonding\n * Supports both native token (ETH/ETC) and ERC20 token funding\n * \n * RBAC INTEGRATION:\n * - Proposal submission is permissionless (anyone can submit with bond)\n * - Admin functions require OPERATIONS_ADMIN_ROLE\n * - ClearPath users with CLEARPATH_USER_ROLE get benefits\n */\ncontract ProposalRegistry is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    struct Milestone {\n        string description;\n        uint256 percentage; // Basis points (10000 = 100%)\n        string completionCriteria;\n        uint256 timelockDays;\n        bool completed;\n    }\n\n    struct Proposal {\n        address proposer;\n        string title;\n        string description;\n        uint256 fundingAmount;\n        address payable recipient;\n        uint256 welfareMetricId;\n        uint256 bondAmount;\n        uint256 submittedAt;\n        uint256 reviewEndsAt;\n        uint256 executionDeadline;  // Deadline for execution after approval\n        uint256 startDate;           // Earliest date proposal can be executed\n        address fundingToken;        // Address(0) for native token, otherwise ERC20 address\n        ProposalStatus status;\n        Milestone[] milestones;\n    }\n\n    enum ProposalStatus {\n        Reviewing,\n        Active,\n        Cancelled,\n        Executed,\n        Forfeited\n    }\n\n    // Proposal ID => Proposal\n    mapping(uint256 => Proposal) public proposals;\n    \n    uint256 public proposalCount;\n    uint256 public bondAmount = 50 ether; // 50 ETC initial bond\n    uint256 public constant REVIEW_PERIOD = 7 days;\n    uint256 public constant MAX_PROPOSAL_AMOUNT = 50000 ether; // 50k ETC max\n\n    // FutarchyGovernor address - allowed to return bonds\n    address public governor;\n\n    bool private _initialized;\n    \n    // Role-based access control\n    TieredRoleManager public roleManager;\n\n    event ProposalSubmitted(\n        uint256 indexed proposalId,\n        address indexed proposer,\n        string title,\n        uint256 fundingAmount,\n        address fundingToken,\n        uint256 executionDeadline\n    );\n    event ProposalCancelled(uint256 indexed proposalId);\n    event ProposalActivated(uint256 indexed proposalId);\n    event BondForfeited(uint256 indexed proposalId, address indexed proposer);\n    event BondReturned(uint256 indexed proposalId, address indexed proposer);\n    event GovernorSet(address indexed governor);\n    event BondAmountUpdated(uint256 oldAmount, uint256 newAmount);\n\n    modifier onlyOwnerOrGovernor() {\n        require(msg.sender == owner() || msg.sender == governor, \"Not authorized\");\n        _;\n    }\n\n    constructor() Ownable(msg.sender) {}\n    \n    /**\n     * @notice Set the role manager contract\n     * @param _roleManager Address of TieredRoleManager contract\n     */\n    function setRoleManager(address _roleManager) external onlyOwner {\n        require(_roleManager != address(0), \"Invalid role manager address\");\n        require(address(roleManager) == address(0), \"Role manager already set\");\n        roleManager = TieredRoleManager(_roleManager);\n    }\n\n    /**\n     * @notice Initialize the contract (used for clones)\n     * @param initialOwner Address of the initial owner\n     */\n    function initialize(address initialOwner) external {\n        require(!_initialized, \"Already initialized\");\n        require(initialOwner != address(0), \"Invalid owner\");\n        _initialized = true;\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @notice Submit a new funding proposal with constraints\n     * @param title Proposal title\n     * @param description Detailed description\n     * @param fundingAmount Amount requested from treasury\n     * @param recipient Address to receive funds\n     * @param welfareMetricId Welfare metric for evaluation\n     * @param fundingToken Token address (address(0) for native token)\n     * @param startDate Earliest date proposal can be executed (0 for immediate)\n     * @param executionDeadline Latest date proposal can be executed (must be set)\n     */\n    function submitProposal(\n        string calldata title,\n        string calldata description,\n        uint256 fundingAmount,\n        address payable recipient,\n        uint256 welfareMetricId,\n        address fundingToken,\n        uint256 startDate,\n        uint256 executionDeadline\n    ) external payable nonReentrant returns (uint256) {\n        require(msg.value == bondAmount, \"Incorrect bond amount\");\n        require(fundingAmount > 0 && fundingAmount <= MAX_PROPOSAL_AMOUNT, \"Invalid funding amount\");\n        require(recipient != address(0), \"Invalid recipient\");\n        require(bytes(title).length > 0 && bytes(title).length <= 100, \"Invalid title length\");\n        require(executionDeadline > block.timestamp, \"Deadline must be in future\");\n        require(executionDeadline > startDate, \"Deadline must be after start date\");\n        \n        // If startDate is 0, set it to current time\n        uint256 effectiveStartDate = startDate == 0 ? block.timestamp : startDate;\n        require(effectiveStartDate >= block.timestamp, \"Start date cannot be in past\");\n\n        uint256 proposalId = proposalCount++;\n\n        Proposal storage newProposal = proposals[proposalId];\n        newProposal.proposer = msg.sender;\n        newProposal.title = title;\n        newProposal.description = description;\n        newProposal.fundingAmount = fundingAmount;\n        newProposal.recipient = recipient;\n        newProposal.welfareMetricId = welfareMetricId;\n        newProposal.bondAmount = msg.value;\n        newProposal.submittedAt = block.timestamp;\n        newProposal.reviewEndsAt = block.timestamp + REVIEW_PERIOD;\n        newProposal.startDate = effectiveStartDate;\n        newProposal.executionDeadline = executionDeadline;\n        newProposal.fundingToken = fundingToken;\n        newProposal.status = ProposalStatus.Reviewing;\n\n        emit ProposalSubmitted(proposalId, msg.sender, title, fundingAmount, fundingToken, executionDeadline);\n        return proposalId;\n    }\n\n    /**\n     * @notice Add milestone to a proposal\n     * @param proposalId ID of the proposal\n     * @param description Milestone description\n     * @param percentage Percentage of total funding (basis points)\n     * @param completionCriteria Criteria for completion\n     * @param timelockDays Days to wait after previous milestone\n     */\n    function addMilestone(\n        uint256 proposalId,\n        string calldata description,\n        uint256 percentage,\n        string calldata completionCriteria,\n        uint256 timelockDays\n    ) external {\n        require(proposalId < proposalCount, \"Invalid proposal ID\");\n        Proposal storage proposal = proposals[proposalId];\n        require(msg.sender == proposal.proposer, \"Not proposer\");\n        require(proposal.status == ProposalStatus.Reviewing, \"Not in review\");\n        require(percentage > 0 && percentage <= 10000, \"Invalid percentage\");\n\n        proposal.milestones.push(Milestone({\n            description: description,\n            percentage: percentage,\n            completionCriteria: completionCriteria,\n            timelockDays: timelockDays,\n            completed: false\n        }));\n    }\n\n    /**\n     * @notice Cancel a proposal during review period\n     * @param proposalId ID of the proposal\n     */\n    function cancelProposal(uint256 proposalId) external nonReentrant {\n        Proposal storage proposal = proposals[proposalId];\n        require(msg.sender == proposal.proposer, \"Not proposer\");\n        require(proposal.status == ProposalStatus.Reviewing, \"Not in review\");\n\n        proposal.status = ProposalStatus.Cancelled;\n\n        // Return bond\n        (bool success, ) = payable(proposal.proposer).call{value: proposal.bondAmount}(\"\");\n        require(success, \"Bond return failed\");\n\n        emit ProposalCancelled(proposalId);\n        emit BondReturned(proposalId, proposal.proposer);\n    }\n\n    /**\n     * @notice Set the governor address that can return bonds\n     * @param _governor Address of the FutarchyGovernor contract\n     */\n    function setGovernor(address _governor) external onlyOwner {\n        require(_governor != address(0), \"Invalid governor address\");\n        governor = _governor;\n        emit GovernorSet(_governor);\n    }\n\n    /**\n     * @notice Activate proposal after review period\n     * @param proposalId ID of the proposal\n     */\n    function activateProposal(uint256 proposalId) external onlyOwner {\n        Proposal storage proposal = proposals[proposalId];\n        require(proposal.status == ProposalStatus.Reviewing, \"Not in review\");\n        require(block.timestamp >= proposal.reviewEndsAt, \"Review period not ended\");\n\n        proposal.status = ProposalStatus.Active;\n        emit ProposalActivated(proposalId);\n    }\n\n    /**\n     * @notice Forfeit bond for spam or malicious proposals\n     * @param proposalId ID of the proposal\n     */\n    function forfeitBond(uint256 proposalId) external onlyOwner nonReentrant {\n        Proposal storage proposal = proposals[proposalId];\n        require(proposal.status == ProposalStatus.Reviewing || proposal.status == ProposalStatus.Active, \"Invalid status\");\n\n        proposal.status = ProposalStatus.Forfeited;\n\n        emit BondForfeited(proposalId, proposal.proposer);\n    }\n\n    /**\n     * @notice Return bond after successful resolution\n     * @param proposalId ID of the proposal\n     */\n    function returnBond(uint256 proposalId) external onlyOwnerOrGovernor nonReentrant {\n        Proposal storage proposal = proposals[proposalId];\n        require(proposal.bondAmount > 0, \"Bond already returned\");\n\n        uint256 amount = proposal.bondAmount;\n        proposal.bondAmount = 0;\n\n        (bool success, ) = payable(proposal.proposer).call{value: amount}(\"\");\n        require(success, \"Bond return failed\");\n\n        emit BondReturned(proposalId, proposal.proposer);\n    }\n\n    /**\n     * @notice Update bond amount\n     * @param newBondAmount New bond amount in wei\n     */\n    function updateBondAmount(uint256 newBondAmount) external onlyOwner {\n        uint256 oldAmount = bondAmount;\n        bondAmount = newBondAmount;\n        emit BondAmountUpdated(oldAmount, newBondAmount);\n    }\n\n    /**\n     * @notice Get proposal details\n     * @param proposalId ID of the proposal\n     */\n    function getProposal(uint256 proposalId) external view returns (\n        address proposer,\n        string memory title,\n        string memory description,\n        uint256 fundingAmount,\n        address recipient,\n        uint256 welfareMetricId,\n        ProposalStatus status,\n        address fundingToken,\n        uint256 startDate,\n        uint256 executionDeadline\n    ) {\n        require(proposalId < proposalCount, \"Invalid proposal ID\");\n        Proposal storage proposal = proposals[proposalId];\n        return (\n            proposal.proposer,\n            proposal.title,\n            proposal.description,\n            proposal.fundingAmount,\n            proposal.recipient,\n            proposal.welfareMetricId,\n            proposal.status,\n            proposal.fundingToken,\n            proposal.startDate,\n            proposal.executionDeadline\n        );\n    }\n\n    /**\n     * @notice Get proposal milestones\n     * @param proposalId ID of the proposal\n     */\n    function getMilestones(uint256 proposalId) external view returns (Milestone[] memory) {\n        require(proposalId < proposalCount, \"Invalid proposal ID\");\n        return proposals[proposalId].milestones;\n    }\n}\n"
    },
    "contracts/RagequitModule.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./TieredRoleManager.sol\";\n\n/**\n * @title RagequitModule\n * @notice Minority exit mechanism with role-aware processing\n * @dev Implements Moloch-style ragequit for treasury protection\n * \n * RBAC INTEGRATION:\n * - Ragequit available to all token holders\n * - Admin functions require OPERATIONS_ADMIN_ROLE\n */\ncontract RagequitModule is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    \n    struct RagequitEligibility {\n        uint256 proposalId;\n        uint256 snapshotTime;\n        uint256 executionTime;\n        bool executed;\n    }\n\n    // Proposal ID => user => eligible\n    mapping(uint256 => mapping(address => bool)) public eligibleToRagequit;\n    \n    // Proposal ID => eligibility details\n    mapping(uint256 => RagequitEligibility) public ragequitWindows;\n    \n    // User => has ragequit for proposal\n    mapping(address => mapping(uint256 => bool)) public hasRagequit;\n\n    address public governanceToken;\n    address public treasuryVault;\n    address public governor; // FutarchyGovernor address\n    \n    uint256 public constant RAGEQUIT_WINDOW = 7 days;\n\n    bool private _initialized;\n    \n    // Role-based access control\n    TieredRoleManager public roleManager;\n\n    event RagequitWindowOpened(uint256 indexed proposalId, uint256 snapshotTime, uint256 executionTime);\n    event RagequitExecuted(\n        address indexed user,\n        uint256 indexed proposalId,\n        uint256 tokenAmount,\n        uint256 treasuryShare\n    );\n    event GovernorSet(address indexed governor);\n\n    modifier onlyOwnerOrGovernor() {\n        if (msg.sender != owner() && msg.sender != governor) {\n            revert OwnableUnauthorizedAccount(msg.sender);\n        }\n        _;\n    }\n\n    constructor() Ownable(msg.sender) {}\n    \n    /**\n     * @notice Set the role manager contract\n     * @param _roleManager Address of TieredRoleManager contract\n     */\n    function setRoleManager(address _roleManager) external onlyOwner {\n        require(_roleManager != address(0), \"Invalid role manager address\");\n        require(address(roleManager) == address(0), \"Role manager already set\");\n        roleManager = TieredRoleManager(_roleManager);\n    }\n\n    /**\n     * @notice Initialize the contract (used for clones)\n     * @param initialOwner Address of the initial owner\n     * @param _governanceToken Address of the governance token\n     * @param _treasuryVault Address of the treasury vault\n     */\n    function initialize(\n        address initialOwner,\n        address _governanceToken,\n        address _treasuryVault\n    ) external {\n        require(!_initialized, \"Already initialized\");\n        require(initialOwner != address(0), \"Invalid owner\");\n        require(_governanceToken != address(0), \"Invalid token\");\n        require(_treasuryVault != address(0), \"Invalid vault\");\n        _initialized = true;\n        governanceToken = _governanceToken;\n        treasuryVault = _treasuryVault;\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @notice Set the governor address that can manage ragequit windows\n     * @param _governor Address of the FutarchyGovernor contract\n     */\n    function setGovernor(address _governor) external onlyOwner {\n        require(_governor != address(0), \"Invalid governor address\");\n        governor = _governor;\n        emit GovernorSet(_governor);\n    }\n\n    /**\n     * @notice Open ragequit window for a proposal\n     * @param proposalId ID of the proposal\n     * @param snapshotTime Time of token snapshot\n     * @param executionTime Scheduled execution time\n     */\n    function openRagequitWindow(\n        uint256 proposalId,\n        uint256 snapshotTime,\n        uint256 executionTime\n    ) external onlyOwnerOrGovernor {\n        require(executionTime > snapshotTime, \"Invalid execution time\");\n        require(ragequitWindows[proposalId].snapshotTime == 0, \"Window already opened\");\n\n        ragequitWindows[proposalId] = RagequitEligibility({\n            proposalId: proposalId,\n            snapshotTime: snapshotTime,\n            executionTime: executionTime,\n            executed: false\n        });\n\n        emit RagequitWindowOpened(proposalId, snapshotTime, executionTime);\n    }\n\n    /**\n     * @notice Mark user as eligible for ragequit\n     * @param proposalId ID of the proposal\n     * @param user Address of the user\n     */\n    function setEligible(uint256 proposalId, address user) external onlyOwner {\n        eligibleToRagequit[proposalId][user] = true;\n    }\n\n    /**\n     * @notice Execute ragequit to exit with proportional treasury share\n     * @param proposalId ID of the proposal\n     * @param tokenAmount Amount of governance tokens to burn\n     */\n    function ragequit(uint256 proposalId, uint256 tokenAmount) external nonReentrant {\n        require(eligibleToRagequit[proposalId][msg.sender], \"Not eligible\");\n        require(!hasRagequit[msg.sender][proposalId], \"Already ragequit\");\n        require(tokenAmount > 0, \"Invalid token amount\");\n\n        RagequitEligibility storage window = ragequitWindows[proposalId];\n        require(window.snapshotTime > 0, \"Window not opened\");\n        require(!window.executed, \"Proposal executed\");\n        require(block.timestamp < window.executionTime, \"Window closed\");\n\n        // Calculate proportional treasury share\n        uint256 treasuryShare = calculateTreasuryShare(tokenAmount);\n        require(treasuryShare > 0, \"No treasury share\");\n\n        hasRagequit[msg.sender][proposalId] = true;\n\n        // Burn governance tokens - using safeTransferFrom for checked transfer\n        IERC20(governanceToken).safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n        // Transfer proportional treasury share\n        // In production, this would interact with the treasury vault\n        // Simplified: transfer ETH\n        (bool success, ) = payable(msg.sender).call{value: treasuryShare}(\"\");\n        require(success, \"Treasury transfer failed\");\n\n        emit RagequitExecuted(msg.sender, proposalId, tokenAmount, treasuryShare);\n    }\n\n    /**\n     * @notice Calculate proportional treasury share for ragequit\n     * @param tokenAmount Amount of tokens to burn\n     * @return uint256 Proportional treasury share\n     */\n    function calculateTreasuryShare(\n        uint256 tokenAmount\n    ) public view returns (uint256) {\n        require(tokenAmount > 0, \"Invalid token amount\");\n\n        // Get total supply of governance token\n        uint256 totalSupply = IERC20(governanceToken).totalSupply();\n        require(totalSupply > 0, \"No total supply\");\n\n        // Get treasury balance (simplified - uses RagequitModule balance for payouts)\n        // In production, this would interact with the treasury vault\n        uint256 treasuryBalance = address(this).balance;\n\n        // Calculate proportional share\n        return (treasuryBalance * tokenAmount) / totalSupply;\n    }\n\n    /**\n     * @notice Mark proposal as executed, closing ragequit window\n     * @param proposalId ID of the proposal\n     */\n    function markProposalExecuted(uint256 proposalId) external onlyOwnerOrGovernor {\n        require(ragequitWindows[proposalId].snapshotTime > 0, \"Window not opened\");\n        ragequitWindows[proposalId].executed = true;\n    }\n\n    /**\n     * @notice Check if user is eligible for ragequit\n     * @param proposalId ID of the proposal\n     * @param user Address of the user\n     * @return bool True if eligible\n     */\n    function isEligible(uint256 proposalId, address user) external view returns (bool) {\n        return eligibleToRagequit[proposalId][user] && !hasRagequit[user][proposalId];\n    }\n\n    /**\n     * @notice Get ragequit window details\n     * @param proposalId ID of the proposal\n     */\n    function getRagequitWindow(uint256 proposalId) external view returns (\n        uint256 snapshotTime,\n        uint256 executionTime,\n        bool executed,\n        bool isOpen\n    ) {\n        RagequitEligibility storage window = ragequitWindows[proposalId];\n        return (\n            window.snapshotTime,\n            window.executionTime,\n            window.executed,\n            window.snapshotTime > 0 && \n            !window.executed && \n            block.timestamp < window.executionTime\n        );\n    }\n\n    /**\n     * @notice Update treasury vault address\n     * @param newVault Address of new vault\n     */\n    function updateTreasuryVault(address newVault) external onlyOwner {\n        require(newVault != address(0), \"Invalid vault\");\n        treasuryVault = newVault;\n    }\n\n    /**\n     * @notice Emergency withdraw (owner only)\n     */\n    function emergencyWithdraw() external onlyOwner {\n        (bool success, ) = payable(owner()).call{value: address(this).balance}(\"\");\n        require(success, \"Withdraw failed\");\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/RoleManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./MembershipPaymentManager.sol\";\nimport \"./ZKKeyManager.sol\";\n\n/**\n * @title RoleManager\n * @notice Comprehensive role-based access control system with hierarchy, timelocks, and multisig support\n * @dev Implements enterprise-grade RBAC following principle of least privilege\n * \n * Role Hierarchy (highest to lowest):\n * 1. DEFAULT_ADMIN_ROLE - Contract owner, manages all roles\n * 2. CORE_SYSTEM_ADMIN_ROLE - Critical upgrades, high-threshold multisig\n * 3. OPERATIONS_ADMIN_ROLE - Day-to-day operations, medium-threshold multisig\n * 4. EMERGENCY_GUARDIAN_ROLE - Emergency pause/cancel, low-threshold multisig\n * 5. Function-specific roles (MARKET_MAKER_ROLE, CLEARPATH_USER_ROLE, TOKENMINT_ROLE)\n * 6. OVERSIGHT_COMMITTEE_ROLE - Independent verification body\n */\ncontract RoleManager is AccessControl, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    // Safe Singleton Factory address for deterministic deployments\n    address internal constant SAFE_SINGLETON_FACTORY = 0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7;\n\n    // Tracks whether role metadata has been initialized (for lazy init pattern)\n    bool internal _roleMetadataInitialized;\n    \n    // ========== Role Definitions ==========\n    \n    // Administrative Roles (Hierarchical)\n    bytes32 public constant CORE_SYSTEM_ADMIN_ROLE = keccak256(\"CORE_SYSTEM_ADMIN_ROLE\");\n    bytes32 public constant OPERATIONS_ADMIN_ROLE = keccak256(\"OPERATIONS_ADMIN_ROLE\");\n    bytes32 public constant EMERGENCY_GUARDIAN_ROLE = keccak256(\"EMERGENCY_GUARDIAN_ROLE\");\n    \n    // Function-Specific Roles (Granular Permissions)\n    bytes32 public constant MARKET_MAKER_ROLE = keccak256(\"MARKET_MAKER_ROLE\");\n    bytes32 public constant CLEARPATH_USER_ROLE = keccak256(\"CLEARPATH_USER_ROLE\");\n    bytes32 public constant TOKENMINT_ROLE = keccak256(\"TOKENMINT_ROLE\");\n    bytes32 public constant FRIEND_MARKET_ROLE = keccak256(\"FRIEND_MARKET_ROLE\");\n    \n    // Oversight & Verification\n    bytes32 public constant OVERSIGHT_COMMITTEE_ROLE = keccak256(\"OVERSIGHT_COMMITTEE_ROLE\");\n    \n    // ========== Payment Integration ==========\n    \n    MembershipPaymentManager public paymentManager;\n    \n    // ========== ZK Key Management ==========\n    \n    ZKKeyManager public zkKeyManager;\n    \n    // ========== Role Metadata ==========\n    \n    struct RoleMetadata {\n        string name;\n        string description;\n        uint256 minApprovals; // Minimum approvals required (multisig threshold)\n        uint256 timelockDelay; // Minimum delay before action execution (in seconds)\n        bool isPremium; // Whether this role requires payment\n        uint256 price; // Price in wei (if premium)\n        bool isActive; // Whether role assignments are currently active\n        uint256 maxMembers; // Maximum number of users with this role (0 = unlimited)\n        uint256 currentMembers; // Current number of users with this role\n    }\n    \n    mapping(bytes32 => RoleMetadata) public roleMetadata;\n    \n    // ========== Timelock Management ==========\n    \n    struct PendingAction {\n        bytes32 actionId;\n        bytes32 role;\n        address target;\n        bool isGrant; // true for grant, false for revoke\n        uint256 executeAfter;\n        uint256 approvalCount;\n        mapping(address => bool) approvals;\n        bool executed;\n        bool cancelled;\n    }\n    \n    mapping(bytes32 => PendingAction) public pendingActions;\n    bytes32[] public pendingActionIds;\n    \n    // ========== Role Purchase Management ==========\n    \n    struct RolePurchase {\n        address buyer;\n        bytes32 role;\n        uint256 timestamp;\n        uint256 price;\n        string zkPublicKey; // Optional ZK key for ClearPath users\n    }\n    \n    mapping(address => mapping(bytes32 => RolePurchase)) public purchases;\n    mapping(address => bytes32[]) public userPurchasedRoles;\n    \n    // ========== Events ==========\n    \n    event RoleMetadataUpdated(bytes32 indexed role, string name, uint256 minApprovals, uint256 timelockDelay);\n    event RolePurchased(address indexed buyer, bytes32 indexed role, uint256 price, uint256 timestamp);\n    event RolePurchasedWithToken(address indexed buyer, bytes32 indexed role, address indexed paymentToken, uint256 price, uint256 timestamp);\n    event ZKKeyRegistered(address indexed user, bytes32 indexed role, string zkPublicKey);\n    event ActionProposed(bytes32 indexed actionId, bytes32 indexed role, address indexed target, bool isGrant);\n    event ActionApproved(bytes32 indexed actionId, address indexed approver);\n    event ActionExecuted(bytes32 indexed actionId, bytes32 indexed role, address indexed target, bool isGrant);\n    event ActionCancelled(bytes32 indexed actionId, address indexed canceller);\n    event EmergencyPaused(address indexed guardian);\n    event EmergencyUnpaused(address indexed admin);\n    event PaymentManagerUpdated(address indexed oldManager, address indexed newManager);\n    event ZKKeyManagerUpdated(address indexed oldManager, address indexed newManager);\n    event ZKKeyRotated(address indexed user, string newZKPublicKey);\n    \n    // ========== Constructor ==========\n    \n    constructor() {\n        // Grant deployer the default admin role\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        \n        // Set up role hierarchy\n        _setRoleAdmin(CORE_SYSTEM_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\n        _setRoleAdmin(OPERATIONS_ADMIN_ROLE, CORE_SYSTEM_ADMIN_ROLE);\n        _setRoleAdmin(EMERGENCY_GUARDIAN_ROLE, OPERATIONS_ADMIN_ROLE);\n        _setRoleAdmin(MARKET_MAKER_ROLE, OPERATIONS_ADMIN_ROLE);\n        _setRoleAdmin(CLEARPATH_USER_ROLE, OPERATIONS_ADMIN_ROLE);\n        _setRoleAdmin(TOKENMINT_ROLE, OPERATIONS_ADMIN_ROLE);\n        _setRoleAdmin(FRIEND_MARKET_ROLE, OPERATIONS_ADMIN_ROLE);\n        _setRoleAdmin(OVERSIGHT_COMMITTEE_ROLE, DEFAULT_ADMIN_ROLE);\n        \n        // NOTE: Role metadata initialization removed from constructor to reduce\n        // deployment gas for deterministic (CREATE2) deployments on low-gas-limit chains.\n        // Call initializeRoleMetadata() after deployment.\n    }\n\n    /**\n     * @notice Initialize role metadata (lazy init for gas-constrained deployments)\n     * @dev Can only be called once by an admin. Should be called after deployment.\n     */\n    function initializeRoleMetadata() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(!_roleMetadataInitialized, \"Role metadata already initialized\");\n        _roleMetadataInitialized = true;\n        _initializeRoleMetadata();\n    }\n    \n    // ========== Role Metadata Initialization ==========\n    \n    function _initializeRoleMetadata() internal {\n        // Core System Admin: High security, long timelock\n        roleMetadata[CORE_SYSTEM_ADMIN_ROLE] = RoleMetadata({\n            name: \"Core System Admin\",\n            description: \"Critical upgrades and system changes\",\n            minApprovals: 3, // High threshold\n            timelockDelay: 7 days, // Long delay for critical actions\n            isPremium: false,\n            price: 0,\n            isActive: true,\n            maxMembers: 5, // Limited to small group\n            currentMembers: 0\n        });\n        \n        // Operations Admin: Medium security, medium timelock\n        roleMetadata[OPERATIONS_ADMIN_ROLE] = RoleMetadata({\n            name: \"Operations Admin\",\n            description: \"Day-to-day operations and configurations\",\n            minApprovals: 2, // Medium threshold\n            timelockDelay: 2 days,\n            isPremium: false,\n            price: 0,\n            isActive: true,\n            maxMembers: 10,\n            currentMembers: 0\n        });\n        \n        // Emergency Guardian: Low threshold, short timelock (rapid response)\n        roleMetadata[EMERGENCY_GUARDIAN_ROLE] = RoleMetadata({\n            name: \"Emergency Guardian\",\n            description: \"Emergency pause and cancel capabilities\",\n            minApprovals: 1, // Low threshold for rapid response\n            timelockDelay: 1 hours, // Minimal delay\n            isPremium: false,\n            price: 0,\n            isActive: true,\n            maxMembers: 7,\n            currentMembers: 0\n        });\n        \n        // Market Maker: Premium, function-specific\n        roleMetadata[MARKET_MAKER_ROLE] = RoleMetadata({\n            name: \"Market Maker\",\n            description: \"Create and manage prediction markets\",\n            minApprovals: 1,\n            timelockDelay: 0, // No timelock for functional roles\n            isPremium: true,\n            price: 100 ether, // 100 tokens (adjust as needed)\n            isActive: true,\n            maxMembers: 0, // Unlimited\n            currentMembers: 0\n        });\n        \n        // ClearPath User: Premium, function-specific\n        roleMetadata[CLEARPATH_USER_ROLE] = RoleMetadata({\n            name: \"ClearPath User\",\n            description: \"Access to DAO governance platform\",\n            minApprovals: 1,\n            timelockDelay: 0,\n            isPremium: true,\n            price: 250 ether, // 250 tokens\n            isActive: true,\n            maxMembers: 0, // Unlimited\n            currentMembers: 0\n        });\n        \n        // Token Mint: Premium, function-specific\n        roleMetadata[TOKENMINT_ROLE] = RoleMetadata({\n            name: \"Token Mint\",\n            description: \"Mint and manage NFTs and ERC20 tokens\",\n            minApprovals: 1,\n            timelockDelay: 0,\n            isPremium: true,\n            price: 150 ether, // 150 tokens\n            isActive: true,\n            maxMembers: 0, // Unlimited\n            currentMembers: 0\n        });\n        \n        // Friend Market: Premium, function-specific\n        roleMetadata[FRIEND_MARKET_ROLE] = RoleMetadata({\n            name: \"Friend Market Creator\",\n            description: \"Create small-scale friend group prediction markets\",\n            minApprovals: 1,\n            timelockDelay: 0,\n            isPremium: true,\n            price: 50 ether, // 50 tokens (base price, tiers managed by TieredRoleManager)\n            isActive: true,\n            maxMembers: 0, // Unlimited\n            currentMembers: 0\n        });\n        \n        // Oversight Committee: Independent verification\n        roleMetadata[OVERSIGHT_COMMITTEE_ROLE] = RoleMetadata({\n            name: \"Oversight Committee\",\n            description: \"Independent verification and approval\",\n            minApprovals: 2,\n            timelockDelay: 1 days,\n            isPremium: false,\n            price: 0,\n            isActive: true,\n            maxMembers: 7,\n            currentMembers: 0\n        });\n    }\n    \n    // ========== Role Purchase Functions ==========\n    \n    /**\n     * @notice Purchase a premium role with ETH (legacy method)\n     * @param role The role to purchase\n     */\n    function purchaseRole(bytes32 role) external payable nonReentrant whenNotPaused {\n        RoleMetadata storage metadata = roleMetadata[role];\n        \n        require(metadata.isActive, \"Role is not active\");\n        require(metadata.isPremium, \"Role is not purchasable\");\n        require(msg.value >= metadata.price, \"Insufficient payment\");\n        require(!hasRole(role, msg.sender), \"Already has role\");\n        require(metadata.maxMembers == 0 || metadata.currentMembers < metadata.maxMembers, \"Role at max capacity\");\n        \n        // Record purchase\n        purchases[msg.sender][role] = RolePurchase({\n            buyer: msg.sender,\n            role: role,\n            timestamp: block.timestamp,\n            price: msg.value,\n            zkPublicKey: \"\" // Can be set later via registerZKKey\n        });\n        \n        userPurchasedRoles[msg.sender].push(role);\n        \n        // Grant role immediately (no timelock for purchases)\n        _grantRole(role, msg.sender);\n        metadata.currentMembers++;\n        \n        emit RolePurchased(msg.sender, role, msg.value, block.timestamp);\n        \n        // Refund excess payment\n        if (msg.value > metadata.price) {\n            payable(msg.sender).transfer(msg.value - metadata.price);\n        }\n    }\n    \n    /**\n     * @notice Purchase a premium role with ERC20 token\n     * @param role The role to purchase\n     * @param paymentToken The ERC20 token to use for payment\n     * @param amount The amount of tokens to pay\n     */\n    function purchaseRoleWithToken(\n        bytes32 role,\n        address paymentToken,\n        uint256 amount\n    ) external nonReentrant whenNotPaused {\n        require(address(paymentManager) != address(0), \"Payment manager not set\");\n        \n        RoleMetadata storage metadata = roleMetadata[role];\n        \n        require(metadata.isActive, \"Role is not active\");\n        require(metadata.isPremium, \"Role is not purchasable\");\n        require(!hasRole(role, msg.sender), \"Already has role\");\n        require(metadata.maxMembers == 0 || metadata.currentMembers < metadata.maxMembers, \"Role at max capacity\");\n        \n        // Transfer tokens from buyer to this contract\n        IERC20(paymentToken).safeTransferFrom(msg.sender, address(this), amount);\n        \n        // Approve payment manager to transfer tokens from this contract\n        IERC20(paymentToken).safeIncreaseAllowance(address(paymentManager), amount);\n        \n        // Process payment through payment manager (payment manager will transfer from this contract)\n        bytes32 paymentId = paymentManager.processPayment(\n            address(this), // payer is this contract (we already have the tokens)\n            msg.sender,    // buyer is the actual user\n            role,\n            paymentToken,\n            amount,\n            0 // tier 0 for non-tiered purchases\n        );\n        \n        // Record purchase\n        purchases[msg.sender][role] = RolePurchase({\n            buyer: msg.sender,\n            role: role,\n            timestamp: block.timestamp,\n            price: amount,\n            zkPublicKey: \"\" // Can be set later via registerZKKey\n        });\n        \n        userPurchasedRoles[msg.sender].push(role);\n        \n        // Grant role immediately (no timelock for purchases)\n        _grantRole(role, msg.sender);\n        metadata.currentMembers++;\n        \n        emit RolePurchasedWithToken(msg.sender, role, paymentToken, amount, block.timestamp);\n    }\n    \n    /**\n     * @notice Register ZK public key for ClearPath users\n     * @param zkPublicKey The zero-knowledge public key\n     */\n    function registerZKKey(string memory zkPublicKey) external whenNotPaused {\n        require(hasRole(CLEARPATH_USER_ROLE, msg.sender), \"Must have ClearPath role\");\n        require(bytes(zkPublicKey).length > 0, \"Invalid ZK key\");\n        \n        // If ZKKeyManager is set, use production key management\n        if (address(zkKeyManager) != address(0)) {\n            // Register key with ZKKeyManager for production verification\n            zkKeyManager.registerKeyFor(msg.sender, zkPublicKey);\n        }\n        \n        // Store in local purchases mapping for backward compatibility\n        purchases[msg.sender][CLEARPATH_USER_ROLE].zkPublicKey = zkPublicKey;\n        \n        emit ZKKeyRegistered(msg.sender, CLEARPATH_USER_ROLE, zkPublicKey);\n    }\n    \n    /**\n     * @notice Rotate ZK public key to a new key\n     * @param newZKPublicKey The new zero-knowledge public key\n     */\n    function rotateZKKey(string memory newZKPublicKey) external whenNotPaused {\n        require(hasRole(CLEARPATH_USER_ROLE, msg.sender), \"Must have ClearPath role\");\n        require(bytes(newZKPublicKey).length > 0, \"Invalid ZK key\");\n        require(address(zkKeyManager) != address(0), \"ZK key manager not set\");\n        \n        // Rotate key using ZKKeyManager\n        zkKeyManager.rotateKeyFor(msg.sender, newZKPublicKey);\n        \n        // Update local purchases mapping\n        purchases[msg.sender][CLEARPATH_USER_ROLE].zkPublicKey = newZKPublicKey;\n        \n        emit ZKKeyRotated(msg.sender, newZKPublicKey);\n    }\n    \n    /**\n     * @notice Revoke ZK public key\n     */\n    function revokeZKKey() external whenNotPaused {\n        require(hasRole(CLEARPATH_USER_ROLE, msg.sender), \"Must have ClearPath role\");\n        require(address(zkKeyManager) != address(0), \"ZK key manager not set\");\n        \n        // Revoke key using ZKKeyManager - pass msg.sender as the user\n        // Note: This works because ZKKeyManager allows key owner to revoke their own key\n        zkKeyManager.revokeKey(msg.sender);\n        \n        // Clear local purchases mapping\n        purchases[msg.sender][CLEARPATH_USER_ROLE].zkPublicKey = \"\";\n    }\n    \n    // ========== Timelock & Multisig Functions ==========\n    \n    /**\n     * @notice Propose a role grant/revoke action (subject to timelock and multisig)\n     * @param role The role to grant/revoke\n     * @param target The address to grant/revoke the role to/from\n     * @param isGrant True for grant, false for revoke\n     */\n    function proposeRoleAction(\n        bytes32 role,\n        address target,\n        bool isGrant\n    ) external onlyRole(getRoleAdmin(role)) whenNotPaused returns (bytes32) {\n        require(target != address(0), \"Invalid target address\");\n        \n        RoleMetadata storage metadata = roleMetadata[role];\n        require(metadata.isActive, \"Role is not active\");\n        \n        // Skip timelock for non-premium roles with no timelock delay\n        if (!metadata.isPremium && metadata.timelockDelay == 0) {\n            if (isGrant) {\n                _grantRole(role, target);\n                metadata.currentMembers++;\n            } else {\n                _revokeRole(role, target);\n                if (metadata.currentMembers > 0) metadata.currentMembers--;\n            }\n            return bytes32(0);\n        }\n        \n        // Generate unique action ID\n        bytes32 actionId = keccak256(abi.encodePacked(role, target, isGrant, block.timestamp));\n        \n        PendingAction storage action = pendingActions[actionId];\n        action.actionId = actionId;\n        action.role = role;\n        action.target = target;\n        action.isGrant = isGrant;\n        action.executeAfter = block.timestamp + metadata.timelockDelay;\n        action.approvalCount = 1; // Proposer's approval\n        action.approvals[msg.sender] = true;\n        \n        pendingActionIds.push(actionId);\n        \n        emit ActionProposed(actionId, role, target, isGrant);\n        emit ActionApproved(actionId, msg.sender);\n        \n        return actionId;\n    }\n    \n    /**\n     * @notice Approve a pending role action\n     * @param actionId The ID of the action to approve\n     */\n    function approveRoleAction(bytes32 actionId) external whenNotPaused {\n        PendingAction storage action = pendingActions[actionId];\n        \n        require(action.actionId != bytes32(0), \"Action does not exist\");\n        require(!action.executed, \"Action already executed\");\n        require(!action.cancelled, \"Action cancelled\");\n        require(!action.approvals[msg.sender], \"Already approved\");\n        require(hasRole(getRoleAdmin(action.role), msg.sender), \"Not authorized to approve\");\n        \n        action.approvals[msg.sender] = true;\n        action.approvalCount++;\n        \n        emit ActionApproved(actionId, msg.sender);\n    }\n    \n    /**\n     * @notice Execute a pending role action after timelock\n     * @param actionId The ID of the action to execute\n     */\n    function executeRoleAction(bytes32 actionId) external nonReentrant whenNotPaused {\n        PendingAction storage action = pendingActions[actionId];\n        \n        require(action.actionId != bytes32(0), \"Action does not exist\");\n        require(!action.executed, \"Action already executed\");\n        require(!action.cancelled, \"Action cancelled\");\n        require(block.timestamp >= action.executeAfter, \"Timelock not expired\");\n        \n        RoleMetadata storage metadata = roleMetadata[action.role];\n        require(action.approvalCount >= metadata.minApprovals, \"Insufficient approvals\");\n        \n        action.executed = true;\n        \n        if (action.isGrant) {\n            _grantRole(action.role, action.target);\n            metadata.currentMembers++;\n        } else {\n            _revokeRole(action.role, action.target);\n            if (metadata.currentMembers > 0) metadata.currentMembers--;\n        }\n        \n        emit ActionExecuted(actionId, action.role, action.target, action.isGrant);\n    }\n    \n    /**\n     * @notice Cancel a pending action (Emergency Guardian only)\n     * @param actionId The ID of the action to cancel\n     */\n    function cancelRoleAction(bytes32 actionId) external onlyRole(EMERGENCY_GUARDIAN_ROLE) {\n        PendingAction storage action = pendingActions[actionId];\n        \n        require(action.actionId != bytes32(0), \"Action does not exist\");\n        require(!action.executed, \"Action already executed\");\n        require(!action.cancelled, \"Action already cancelled\");\n        \n        action.cancelled = true;\n        \n        emit ActionCancelled(actionId, msg.sender);\n    }\n    \n    // ========== Emergency Functions ==========\n    \n    /**\n     * @notice Emergency pause (Guardian only)\n     */\n    function emergencyPause() external onlyRole(EMERGENCY_GUARDIAN_ROLE) {\n        _pause();\n        emit EmergencyPaused(msg.sender);\n    }\n    \n    /**\n     * @notice Unpause contract (Admin only)\n     */\n    function unpause() external onlyRole(OPERATIONS_ADMIN_ROLE) {\n        _unpause();\n        emit EmergencyUnpaused(msg.sender);\n    }\n    \n    // ========== Admin Functions ==========\n    \n    /**\n     * @notice Set the payment manager contract\n     * @param _paymentManager Address of MembershipPaymentManager contract\n     */\n    function setPaymentManager(address _paymentManager) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_paymentManager != address(0), \"Invalid payment manager address\");\n        address oldManager = address(paymentManager);\n        paymentManager = MembershipPaymentManager(_paymentManager);\n        emit PaymentManagerUpdated(oldManager, _paymentManager);\n    }\n    \n    /**\n     * @notice Set the ZK key manager contract\n     * @param _zkKeyManager Address of ZKKeyManager contract\n     */\n    function setZKKeyManager(address _zkKeyManager) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_zkKeyManager != address(0), \"Invalid ZK key manager address\");\n        address oldManager = address(zkKeyManager);\n        zkKeyManager = ZKKeyManager(_zkKeyManager);\n        emit ZKKeyManagerUpdated(oldManager, _zkKeyManager);\n    }\n    \n    /**\n     * @notice Update role metadata (Core System Admin only)\n     */\n    function updateRoleMetadata(\n        bytes32 role,\n        string memory name,\n        string memory description,\n        uint256 minApprovals,\n        uint256 timelockDelay,\n        uint256 maxMembers\n    ) external onlyRole(CORE_SYSTEM_ADMIN_ROLE) {\n        RoleMetadata storage metadata = roleMetadata[role];\n        \n        metadata.name = name;\n        metadata.description = description;\n        metadata.minApprovals = minApprovals;\n        metadata.timelockDelay = timelockDelay;\n        metadata.maxMembers = maxMembers;\n        \n        emit RoleMetadataUpdated(role, name, minApprovals, timelockDelay);\n    }\n    \n    /**\n     * @notice Set role price (Operations Admin only)\n     */\n    function setRolePrice(bytes32 role, uint256 price) external onlyRole(OPERATIONS_ADMIN_ROLE) {\n        require(roleMetadata[role].isPremium, \"Role is not premium\");\n        roleMetadata[role].price = price;\n    }\n    \n    /**\n     * @notice Toggle role active status (Operations Admin only)\n     */\n    function setRoleActive(bytes32 role, bool isActive) external onlyRole(OPERATIONS_ADMIN_ROLE) {\n        roleMetadata[role].isActive = isActive;\n    }\n    \n    /**\n     * @notice Withdraw contract balance (Operations Admin only)\n     */\n    function withdraw() external onlyRole(OPERATIONS_ADMIN_ROLE) nonReentrant {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No balance to withdraw\");\n        payable(msg.sender).transfer(balance);\n    }\n    \n    // ========== Override AccessControl Functions to Enforce Governance ==========\n    \n    /**\n     * @notice Override grantRole to enforce timelock/multisig governance\n     * @dev Only allows direct grants for premium roles via purchaseRole or internal grants via executeRoleAction\n     */\n    function grantRole(bytes32 role, address account) public virtual override {\n        // Only allow direct grants in specific scenarios:\n        // 1. During contract initialization (for setting up initial admin hierarchy)\n        // 2. For premium roles purchased via purchaseRole (checked by msg.sender == this)\n        // 3. For roles with no timelock delay (executed immediately in proposeRoleAction)\n        // 4. Role admin can directly grant roles for initial setup (to simplify testing and initial deployment)\n        \n        RoleMetadata storage metadata = roleMetadata[role];\n        \n        // Allow if called internally (from purchaseRole or executeRoleAction)\n        if (msg.sender == address(this)) {\n            super.grantRole(role, account);\n            return;\n        }\n        \n        // Allow role admin to grant for initial setup and testing\n        if (hasRole(getRoleAdmin(role), msg.sender)) {\n            super.grantRole(role, account);\n            return;\n        }\n        \n        // For premium roles, users must use purchaseRole\n        if (metadata.isPremium) {\n            revert(\"Premium roles must be purchased via purchaseRole\");\n        }\n        \n        // Otherwise reject\n        revert(\"Must have role admin permission or use governance flow\");\n    }\n    \n    /**\n     * @notice Override revokeRole to maintain consistency with grantRole\n     * @dev Allows direct revocations by role admin or internal calls\n     */\n    function revokeRole(bytes32 role, address account) public virtual override {\n        // Allow if called internally (from executeRoleAction)\n        if (msg.sender == address(this)) {\n            super.revokeRole(role, account);\n            return;\n        }\n        \n        // Allow role admin to revoke\n        if (hasRole(getRoleAdmin(role), msg.sender)) {\n            super.revokeRole(role, account);\n            return;\n        }\n        \n        // Otherwise reject\n        revert(\"Must have role admin permission\");\n    }\n    \n    /**\n     * @notice Internal function to grant role (bypasses checks)\n     * @dev Used by executeRoleAction and purchaseRole\n     */\n    function _internalGrantRole(bytes32 role, address account) internal {\n        super.grantRole(role, account);\n    }\n    \n    /**\n     * @notice Internal function to revoke role (bypasses checks)\n     * @dev Used by executeRoleAction\n     */\n    function _internalRevokeRole(bytes32 role, address account) internal {\n        super.revokeRole(role, account);\n    }\n    \n    // ========== View Functions ==========\n    \n    /**\n     * @notice Get role metadata\n     */\n    function getRoleMetadata(bytes32 role) external view returns (RoleMetadata memory) {\n        return roleMetadata[role];\n    }\n    \n    /**\n     * @notice Get user's purchased roles\n     */\n    function getUserPurchasedRoles(address user) external view returns (bytes32[] memory) {\n        return userPurchasedRoles[user];\n    }\n    \n    /**\n     * @notice Get ZK public key for user\n     */\n    function getZKPublicKey(address user) external view returns (string memory) {\n        // If ZKKeyManager is set, get key from there\n        if (address(zkKeyManager) != address(0)) {\n            return zkKeyManager.getPublicKey(user);\n        }\n        // Otherwise fall back to local storage\n        return purchases[user][CLEARPATH_USER_ROLE].zkPublicKey;\n    }\n    \n    /**\n     * @notice Check if user has a valid ZK key\n     */\n    function hasValidZKKey(address user) external view returns (bool) {\n        if (address(zkKeyManager) != address(0)) {\n            return zkKeyManager.hasValidKey(user);\n        }\n        // Fall back to checking local storage\n        return bytes(purchases[user][CLEARPATH_USER_ROLE].zkPublicKey).length > 0;\n    }\n    \n    /**\n     * @notice Get pending action count\n     */\n    function getPendingActionCount() external view returns (uint256) {\n        return pendingActionIds.length;\n    }\n    \n    /**\n     * @notice Check if action is approved by address\n     */\n    function isActionApprovedBy(bytes32 actionId, address approver) external view returns (bool) {\n        return pendingActions[actionId].approvals[approver];\n    }\n}\n"
    },
    "contracts/TieredRoleManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./RoleManager.sol\";\n\n/**\n * @title TieredRoleManager\n * @notice Extends RoleManager with tiered membership levels (Bronze, Silver, Gold, Platinum)\n * @dev Each product role can have multiple tiers with different permissions and limits\n */\ncontract TieredRoleManager is RoleManager {\n    using SafeERC20 for IERC20;\n\n    // NOTE: SAFE_SINGLETON_FACTORY is inherited from RoleManager\n\n    bool private _initialized;\n\n    bool private _marketMakerTiersInitialized;\n    bool private _clearPathTiersInitialized;\n    bool private _tokenMintTiersInitialized;\n    bool private _friendMarketTiersInitialized;\n    \n    // ========== Tier Definitions ==========\n    \n    enum MembershipTier {\n        NONE,       // 0 - No membership\n        BRONZE,     // 1 - Basic tier\n        SILVER,     // 2 - Intermediate tier\n        GOLD,       // 3 - Advanced tier\n        PLATINUM    // 4 - Premium tier\n    }\n    \n    // ========== Tier Metadata ==========\n    \n    struct TierLimits {\n        uint256 dailyBetLimit;           // Max bets per day\n        uint256 weeklyBetLimit;          // Max bets per week\n        uint256 monthlyMarketCreation;   // Max markets created per month\n        uint256 maxPositionSize;         // Max position size in wei\n        uint256 maxConcurrentMarkets;    // Max active markets at once\n        uint256 withdrawalLimit;         // Daily withdrawal limit\n        bool canCreatePrivateMarkets;    // Can create private markets\n        bool canUseAdvancedFeatures;     // Access to advanced features\n        uint256 feeDiscount;             // Fee discount in basis points (100 = 1%)\n    }\n    \n    struct TierMetadata {\n        string name;\n        string description;\n        uint256 price;                   // Upgrade price from previous tier\n        TierLimits limits;\n        bool isActive;\n    }\n    \n    // role => tier => TierMetadata\n    mapping(bytes32 => mapping(MembershipTier => TierMetadata)) public tierMetadata;\n    \n    // user => role => current tier\n    mapping(address => mapping(bytes32 => MembershipTier)) public userTiers;\n    \n    // user => role => tier => purchase timestamp\n    mapping(address => mapping(bytes32 => mapping(MembershipTier => uint256))) public tierPurchases;\n    \n    // ========== Membership Duration Tracking ==========\n    \n    enum MembershipDuration {\n        ONE_MONTH,      // 30 days\n        THREE_MONTHS,   // 90 days\n        SIX_MONTHS,     // 180 days\n        TWELVE_MONTHS,  // 365 days\n        ENTERPRISE      // Custom/unlimited duration\n    }\n    \n    // user => role => membership expiration timestamp\n    mapping(address => mapping(bytes32 => uint256)) public membershipExpiration;\n    \n    // user => role => membership duration type\n    mapping(address => mapping(bytes32 => MembershipDuration)) public membershipDurationType;\n    \n    // ========== Usage Tracking ==========\n    \n    struct UsageStats {\n        uint256 dailyBetsCount;\n        uint256 weeklyBetsCount;\n        uint256 monthlyMarketsCreated;\n        uint256 dailyWithdrawals;\n        uint256 activeMarketsCount;\n        uint256 lastDailyReset;\n        uint256 lastWeeklyReset;\n        uint256 lastMonthlyReset;\n    }\n    \n    // user => role => usage stats\n    mapping(address => mapping(bytes32 => UsageStats)) public usageStats;\n    \n    // ========== Events ==========\n    \n    event TierPurchased(address indexed user, bytes32 indexed role, MembershipTier tier, uint256 price);\n    event TierUpgraded(address indexed user, bytes32 indexed role, MembershipTier fromTier, MembershipTier toTier);\n    event UsageLimitExceeded(address indexed user, bytes32 indexed role, string limitType);\n    event UsageRecorded(address indexed user, bytes32 indexed role, string actionType);\n    event MembershipExtended(address indexed user, bytes32 indexed role, uint256 newExpiration, MembershipDuration duration);\n    event MembershipExpired(address indexed user, bytes32 indexed role);\n    event TierPriceUpdated(bytes32 indexed role, MembershipTier tier, uint256 newPrice);\n    event TierLimitsUpdated(bytes32 indexed role, MembershipTier tier);\n    event TierMetadataUpdated(bytes32 indexed role, MembershipTier tier, string name, string description);\n    event TierActiveStatusChanged(bytes32 indexed role, MembershipTier tier, bool active);\n    \n    // ========== Constructor ==========\n    \n    constructor() RoleManager() {\n        // For direct deployments, prevent initialize() from being called.\n        // For Safe Singleton Factory (CREATE2) deployments, allow a one-time initialize()\n        // so DEFAULT_ADMIN_ROLE isn't stuck on the factory.\n        _initialized = msg.sender != SAFE_SINGLETON_FACTORY;\n    }\n\n    /**\n     * @notice Initialize admin after deterministic deployment (CREATE2)\n     * @dev Only callable once, intended for Safe Singleton Factory deployments.\n     */\n    function initialize(address admin) external {\n        require(!_initialized, \"Already initialized\");\n        require(admin != address(0), \"Invalid admin\");\n\n        _initialized = true;\n\n        // RoleManager constructor granted DEFAULT_ADMIN_ROLE to the deployer (the factory).\n        // Hand it over to the intended admin and revoke the factory.\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _revokeRole(DEFAULT_ADMIN_ROLE, SAFE_SINGLETON_FACTORY);\n    }\n\n    /**\n     * @notice Initialize tier metadata in smaller chunks.\n     * @dev Tier metadata initialization writes a lot of storage and can exceed low block gas limits\n     *      when done inside a constructor. These functions allow initializing the tiers post-deploy.\n     */\n\n    function initializeMarketMakerTiers() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(!_marketMakerTiersInitialized, \"Market maker tiers already initialized\");\n        _marketMakerTiersInitialized = true;\n        _initializeMarketMakerTiers();\n    }\n\n    function initializeClearPathTiers() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(!_clearPathTiersInitialized, \"ClearPath tiers already initialized\");\n        _clearPathTiersInitialized = true;\n        _initializeClearPathTiers();\n    }\n\n    function initializeTokenMintTiers() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(!_tokenMintTiersInitialized, \"Token mint tiers already initialized\");\n        _tokenMintTiersInitialized = true;\n        _initializeTokenMintTiers();\n    }\n\n    function initializeFriendMarketTiers() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(!_friendMarketTiersInitialized, \"Friend market tiers already initialized\");\n        _friendMarketTiersInitialized = true;\n        _initializeFriendMarketTiers();\n    }\n    \n    // ========== Tier Metadata Initialization ==========\n    \n    function _initializeTierMetadata() internal {\n        // MARKET_MAKER Role Tiers\n        _initializeMarketMakerTiers();\n        \n        // CLEARPATH_USER Role Tiers\n        _initializeClearPathTiers();\n        \n        // TOKENMINT Role Tiers\n        _initializeTokenMintTiers();\n        \n        // FRIEND_MARKET Role Tiers\n        _initializeFriendMarketTiers();\n    }\n    \n    function _initializeMarketMakerTiers() internal {\n        bytes32 role = MARKET_MAKER_ROLE;\n        \n        // Bronze Tier - Basic market maker\n        tierMetadata[role][MembershipTier.BRONZE] = TierMetadata({\n            name: \"Market Maker Bronze\",\n            description: \"Basic market creation capabilities\",\n            price: 100 ether,\n            limits: TierLimits({\n                dailyBetLimit: 10,\n                weeklyBetLimit: 50,\n                monthlyMarketCreation: 5,\n                maxPositionSize: 10 ether,\n                maxConcurrentMarkets: 3,\n                withdrawalLimit: 50 ether,\n                canCreatePrivateMarkets: false,\n                canUseAdvancedFeatures: false,\n                feeDiscount: 0 // No discount\n            }),\n            isActive: true\n        });\n        \n        // Silver Tier - Intermediate market maker\n        tierMetadata[role][MembershipTier.SILVER] = TierMetadata({\n            name: \"Market Maker Silver\",\n            description: \"Enhanced market creation with more limits\",\n            price: 150 ether, // Upgrade cost from Bronze\n            limits: TierLimits({\n                dailyBetLimit: 25,\n                weeklyBetLimit: 150,\n                monthlyMarketCreation: 15,\n                maxPositionSize: 50 ether,\n                maxConcurrentMarkets: 10,\n                withdrawalLimit: 200 ether,\n                canCreatePrivateMarkets: false,\n                canUseAdvancedFeatures: true,\n                feeDiscount: 500 // 5% discount\n            }),\n            isActive: true\n        });\n        \n        // Gold Tier - Advanced market maker\n        tierMetadata[role][MembershipTier.GOLD] = TierMetadata({\n            name: \"Market Maker Gold\",\n            description: \"Professional market creation capabilities\",\n            price: 250 ether,\n            limits: TierLimits({\n                dailyBetLimit: 100,\n                weeklyBetLimit: 500,\n                monthlyMarketCreation: 50,\n                maxPositionSize: 200 ether,\n                maxConcurrentMarkets: 30,\n                withdrawalLimit: 1000 ether,\n                canCreatePrivateMarkets: true,\n                canUseAdvancedFeatures: true,\n                feeDiscount: 1000 // 10% discount\n            }),\n            isActive: true\n        });\n        \n        // Platinum Tier - Premium market maker\n        tierMetadata[role][MembershipTier.PLATINUM] = TierMetadata({\n            name: \"Market Maker Platinum\",\n            description: \"Unlimited market creation for institutions\",\n            price: 500 ether,\n            limits: TierLimits({\n                dailyBetLimit: type(uint256).max, // Unlimited\n                weeklyBetLimit: type(uint256).max,\n                monthlyMarketCreation: type(uint256).max,\n                maxPositionSize: type(uint256).max,\n                maxConcurrentMarkets: type(uint256).max,\n                withdrawalLimit: type(uint256).max,\n                canCreatePrivateMarkets: true,\n                canUseAdvancedFeatures: true,\n                feeDiscount: 2000 // 20% discount\n            }),\n            isActive: true\n        });\n    }\n    \n    function _initializeClearPathTiers() internal {\n        bytes32 role = CLEARPATH_USER_ROLE;\n        \n        // Bronze Tier - Basic DAO governance\n        tierMetadata[role][MembershipTier.BRONZE] = TierMetadata({\n            name: \"ClearPath Bronze\",\n            description: \"Basic DAO governance access\",\n            price: 250 ether,\n            limits: TierLimits({\n                dailyBetLimit: 5,\n                weeklyBetLimit: 20,\n                monthlyMarketCreation: 2,\n                maxPositionSize: 5 ether,\n                maxConcurrentMarkets: 2,\n                withdrawalLimit: 25 ether,\n                canCreatePrivateMarkets: false,\n                canUseAdvancedFeatures: false,\n                feeDiscount: 0\n            }),\n            isActive: true\n        });\n        \n        // Silver Tier - Enhanced governance\n        tierMetadata[role][MembershipTier.SILVER] = TierMetadata({\n            name: \"ClearPath Silver\",\n            description: \"Enhanced DAO governance features\",\n            price: 200 ether,\n            limits: TierLimits({\n                dailyBetLimit: 15,\n                weeklyBetLimit: 75,\n                monthlyMarketCreation: 10,\n                maxPositionSize: 25 ether,\n                maxConcurrentMarkets: 5,\n                withdrawalLimit: 100 ether,\n                canCreatePrivateMarkets: false,\n                canUseAdvancedFeatures: true,\n                feeDiscount: 500 // 5%\n            }),\n            isActive: true\n        });\n        \n        // Gold Tier - Professional governance\n        tierMetadata[role][MembershipTier.GOLD] = TierMetadata({\n            name: \"ClearPath Gold\",\n            description: \"Professional DAO management\",\n            price: 350 ether,\n            limits: TierLimits({\n                dailyBetLimit: 50,\n                weeklyBetLimit: 300,\n                monthlyMarketCreation: 30,\n                maxPositionSize: 100 ether,\n                maxConcurrentMarkets: 15,\n                withdrawalLimit: 500 ether,\n                canCreatePrivateMarkets: true,\n                canUseAdvancedFeatures: true,\n                feeDiscount: 1000 // 10%\n            }),\n            isActive: true\n        });\n        \n        // Platinum Tier - Enterprise governance\n        tierMetadata[role][MembershipTier.PLATINUM] = TierMetadata({\n            name: \"ClearPath Platinum\",\n            description: \"Enterprise-grade DAO governance\",\n            price: 750 ether,\n            limits: TierLimits({\n                dailyBetLimit: type(uint256).max,\n                weeklyBetLimit: type(uint256).max,\n                monthlyMarketCreation: type(uint256).max,\n                maxPositionSize: type(uint256).max,\n                maxConcurrentMarkets: type(uint256).max,\n                withdrawalLimit: type(uint256).max,\n                canCreatePrivateMarkets: true,\n                canUseAdvancedFeatures: true,\n                feeDiscount: 2500 // 25%\n            }),\n            isActive: true\n        });\n    }\n    \n    function _initializeTokenMintTiers() internal {\n        bytes32 role = TOKENMINT_ROLE;\n        \n        // Bronze Tier - Basic token operations\n        tierMetadata[role][MembershipTier.BRONZE] = TierMetadata({\n            name: \"TokenMint Bronze\",\n            description: \"Basic NFT and token minting\",\n            price: 150 ether,\n            limits: TierLimits({\n                dailyBetLimit: 0, // Not applicable\n                weeklyBetLimit: 0,\n                monthlyMarketCreation: 10, // Monthly mints\n                maxPositionSize: 100 ether, // Max mint value\n                maxConcurrentMarkets: 5, // Active token contracts\n                withdrawalLimit: 50 ether,\n                canCreatePrivateMarkets: false,\n                canUseAdvancedFeatures: false,\n                feeDiscount: 0\n            }),\n            isActive: true\n        });\n        \n        // Silver Tier - Enhanced token operations\n        tierMetadata[role][MembershipTier.SILVER] = TierMetadata({\n            name: \"TokenMint Silver\",\n            description: \"Enhanced token management features\",\n            price: 200 ether,\n            limits: TierLimits({\n                dailyBetLimit: 0,\n                weeklyBetLimit: 0,\n                monthlyMarketCreation: 30,\n                maxPositionSize: 500 ether,\n                maxConcurrentMarkets: 15,\n                withdrawalLimit: 200 ether,\n                canCreatePrivateMarkets: false,\n                canUseAdvancedFeatures: true,\n                feeDiscount: 500 // 5%\n            }),\n            isActive: true\n        });\n        \n        // Gold Tier - Professional token operations\n        tierMetadata[role][MembershipTier.GOLD] = TierMetadata({\n            name: \"TokenMint Gold\",\n            description: \"Professional NFT and token suite\",\n            price: 350 ether,\n            limits: TierLimits({\n                dailyBetLimit: 0,\n                weeklyBetLimit: 0,\n                monthlyMarketCreation: 100,\n                maxPositionSize: 2000 ether,\n                maxConcurrentMarkets: 50,\n                withdrawalLimit: 1000 ether,\n                canCreatePrivateMarkets: true,\n                canUseAdvancedFeatures: true,\n                feeDiscount: 1000 // 10%\n            }),\n            isActive: true\n        });\n        \n        // Platinum Tier - Enterprise token operations\n        tierMetadata[role][MembershipTier.PLATINUM] = TierMetadata({\n            name: \"TokenMint Platinum\",\n            description: \"Enterprise token infrastructure\",\n            price: 600 ether,\n            limits: TierLimits({\n                dailyBetLimit: 0,\n                weeklyBetLimit: 0,\n                monthlyMarketCreation: type(uint256).max,\n                maxPositionSize: type(uint256).max,\n                maxConcurrentMarkets: type(uint256).max,\n                withdrawalLimit: type(uint256).max,\n                canCreatePrivateMarkets: true,\n                canUseAdvancedFeatures: true,\n                feeDiscount: 2000 // 20%\n            }),\n            isActive: true\n        });\n    }\n    \n    function _initializeFriendMarketTiers() internal {\n        bytes32 role = FRIEND_MARKET_ROLE;\n        \n        // Bronze Tier - Basic friend market access (15 markets/month)\n        tierMetadata[role][MembershipTier.BRONZE] = TierMetadata({\n            name: \"Friend Market Bronze\",\n            description: \"Basic friend market creation - 15 markets/month\",\n            price: 50 ether,\n            limits: TierLimits({\n                dailyBetLimit: 5,\n                weeklyBetLimit: 20,\n                monthlyMarketCreation: 15, // 15 friend markets per month\n                maxPositionSize: 5 ether,\n                maxConcurrentMarkets: 5,\n                withdrawalLimit: 25 ether,\n                canCreatePrivateMarkets: true, // Friend markets are inherently private\n                canUseAdvancedFeatures: false,\n                feeDiscount: 10000 // 100% discount on creation fees (gas only)\n            }),\n            isActive: true\n        });\n        \n        // Silver Tier - Enhanced friend market access (30 markets/month)\n        tierMetadata[role][MembershipTier.SILVER] = TierMetadata({\n            name: \"Friend Market Silver\",\n            description: \"Enhanced friend market creation - 30 markets/month\",\n            price: 100 ether, // Upgrade cost from Bronze\n            limits: TierLimits({\n                dailyBetLimit: 10,\n                weeklyBetLimit: 50,\n                monthlyMarketCreation: 30, // 30 friend markets per month\n                maxPositionSize: 15 ether,\n                maxConcurrentMarkets: 10,\n                withdrawalLimit: 100 ether,\n                canCreatePrivateMarkets: true,\n                canUseAdvancedFeatures: true,\n                feeDiscount: 10000 // 100% discount on creation fees (gas only)\n            }),\n            isActive: true\n        });\n        \n        // Gold Tier - Advanced friend market access (100 markets/month)\n        tierMetadata[role][MembershipTier.GOLD] = TierMetadata({\n            name: \"Friend Market Gold\",\n            description: \"Advanced friend market creation - 100 markets/month\",\n            price: 200 ether,\n            limits: TierLimits({\n                dailyBetLimit: 35,\n                weeklyBetLimit: 200,\n                monthlyMarketCreation: 100, // 100 friend markets per month\n                maxPositionSize: 50 ether,\n                maxConcurrentMarkets: 30,\n                withdrawalLimit: 500 ether,\n                canCreatePrivateMarkets: true,\n                canUseAdvancedFeatures: true,\n                feeDiscount: 10000 // 100% discount on creation fees (gas only)\n            }),\n            isActive: true\n        });\n        \n        // Platinum Tier - Unlimited friend market access\n        tierMetadata[role][MembershipTier.PLATINUM] = TierMetadata({\n            name: \"Friend Market Platinum\",\n            description: \"Unlimited friend market creation\",\n            price: 400 ether,\n            limits: TierLimits({\n                dailyBetLimit: type(uint256).max,\n                weeklyBetLimit: type(uint256).max,\n                monthlyMarketCreation: type(uint256).max, // Unlimited friend markets\n                maxPositionSize: type(uint256).max,\n                maxConcurrentMarkets: type(uint256).max,\n                withdrawalLimit: type(uint256).max,\n                canCreatePrivateMarkets: true,\n                canUseAdvancedFeatures: true,\n                feeDiscount: 10000 // 100% discount on creation fees (gas only)\n            }),\n            isActive: true\n        });\n    }\n    \n    // ========== Tier Purchase & Upgrade Functions ==========\n    \n    /**\n     * @notice Purchase a role at specific tier with ETH and duration\n     * @param role The role to purchase\n     * @param tier The membership tier\n     * @param duration The membership duration\n     */\n    function purchaseRoleWithTierAndDuration(\n        bytes32 role, \n        MembershipTier tier, \n        MembershipDuration duration\n    ) external payable nonReentrant whenNotPaused {\n        require(tier != MembershipTier.NONE, \"Invalid tier\");\n        require(userTiers[msg.sender][role] == MembershipTier.NONE, \"Already has role, use upgradeTier\");\n        \n        TierMetadata storage tierMeta = tierMetadata[role][tier];\n        require(tierMeta.isActive, \"Tier not active\");\n        require(msg.value >= tierMeta.price, \"Insufficient payment\");\n        \n        RoleMetadata storage roleMeta = roleMetadata[role];\n        require(roleMeta.isPremium, \"Role is not purchasable\");\n        require(roleMeta.maxMembers == 0 || roleMeta.currentMembers < roleMeta.maxMembers, \"Role at max capacity\");\n        \n        // Grant role and set tier\n        _grantRole(role, msg.sender);\n        userTiers[msg.sender][role] = tier;\n        tierPurchases[msg.sender][role][tier] = block.timestamp;\n        roleMeta.currentMembers++;\n        \n        // Set membership duration\n        _setMembershipDuration(msg.sender, role, duration);\n        \n        // Initialize usage stats\n        _initializeUsageStats(msg.sender, role);\n        \n        emit TierPurchased(msg.sender, role, tier, msg.value);\n        \n        // Refund excess\n        if (msg.value > tierMeta.price) {\n            payable(msg.sender).transfer(msg.value - tierMeta.price);\n        }\n    }\n    \n    /**\n     * @notice Purchase a role at specific tier with ETH (legacy method - defaults to 1 month)\n     * @param role The role to purchase\n     * @param tier The membership tier\n     */\n    function purchaseRoleWithTier(bytes32 role, MembershipTier tier) external payable nonReentrant whenNotPaused {\n        require(tier != MembershipTier.NONE, \"Invalid tier\");\n        require(userTiers[msg.sender][role] == MembershipTier.NONE, \"Already has role, use upgradeTier\");\n        \n        TierMetadata storage tierMeta = tierMetadata[role][tier];\n        require(tierMeta.isActive, \"Tier not active\");\n        require(msg.value >= tierMeta.price, \"Insufficient payment\");\n        \n        RoleMetadata storage roleMeta = roleMetadata[role];\n        require(roleMeta.isPremium, \"Role is not purchasable\");\n        require(roleMeta.maxMembers == 0 || roleMeta.currentMembers < roleMeta.maxMembers, \"Role at max capacity\");\n        \n        // Grant role and set tier\n        _grantRole(role, msg.sender);\n        userTiers[msg.sender][role] = tier;\n        tierPurchases[msg.sender][role][tier] = block.timestamp;\n        roleMeta.currentMembers++;\n        \n        // Set membership duration (default to 1 month for legacy)\n        _setMembershipDuration(msg.sender, role, MembershipDuration.ONE_MONTH);\n        \n        // Initialize usage stats\n        _initializeUsageStats(msg.sender, role);\n        \n        emit TierPurchased(msg.sender, role, tier, msg.value);\n        \n        // Refund excess\n        if (msg.value > tierMeta.price) {\n            payable(msg.sender).transfer(msg.value - tierMeta.price);\n        }\n    }\n    \n    /**\n     * @notice Purchase a role at specific tier with ERC20 token\n     * @param role The role to purchase\n     * @param tier The membership tier\n     * @param paymentToken The ERC20 token to use for payment\n     * @param amount The amount of tokens to pay\n     */\n    function purchaseRoleWithTierToken(\n        bytes32 role,\n        MembershipTier tier,\n        address paymentToken,\n        uint256 amount\n    ) external nonReentrant whenNotPaused {\n        require(address(paymentManager) != address(0), \"Payment manager not set\");\n        require(tier != MembershipTier.NONE, \"Invalid tier\");\n        require(userTiers[msg.sender][role] == MembershipTier.NONE, \"Already has role, use upgradeTier\");\n        \n        TierMetadata storage tierMeta = tierMetadata[role][tier];\n        require(tierMeta.isActive, \"Tier not active\");\n        \n        RoleMetadata storage roleMeta = roleMetadata[role];\n        require(roleMeta.isPremium, \"Role is not purchasable\");\n        require(roleMeta.maxMembers == 0 || roleMeta.currentMembers < roleMeta.maxMembers, \"Role at max capacity\");\n        \n        // Transfer tokens from buyer to this contract\n        IERC20(paymentToken).safeTransferFrom(msg.sender, address(this), amount);\n        \n        // Approve payment manager to transfer tokens from this contract\n        IERC20(paymentToken).safeIncreaseAllowance(address(paymentManager), amount);\n        \n        // Process payment through payment manager (payment manager will transfer from this contract)\n        bytes32 paymentId = paymentManager.processPayment(\n            address(this), // payer is this contract (we already have the tokens)\n            msg.sender,    // buyer is the actual user\n            role,\n            paymentToken,\n            amount,\n            uint8(tier)\n        );\n        \n        // Grant role and set tier\n        _grantRole(role, msg.sender);\n        userTiers[msg.sender][role] = tier;\n        tierPurchases[msg.sender][role][tier] = block.timestamp;\n        roleMeta.currentMembers++;\n        \n        // Initialize usage stats\n        _initializeUsageStats(msg.sender, role);\n        \n        emit TierPurchased(msg.sender, role, tier, amount);\n    }\n    \n    /**\n     * @notice Upgrade to a higher tier with ETH (legacy method)\n     * @param role The role to upgrade\n     * @param newTier The new tier\n     */\n    function upgradeTier(bytes32 role, MembershipTier newTier) external payable nonReentrant whenNotPaused {\n        MembershipTier currentTier = userTiers[msg.sender][role];\n        require(currentTier != MembershipTier.NONE, \"Must have role first\");\n        require(newTier > currentTier, \"Can only upgrade to higher tier\");\n        \n        TierMetadata storage tierMeta = tierMetadata[role][newTier];\n        require(tierMeta.isActive, \"Tier not active\");\n        require(msg.value >= tierMeta.price, \"Insufficient payment\");\n        \n        // Upgrade tier\n        userTiers[msg.sender][role] = newTier;\n        tierPurchases[msg.sender][role][newTier] = block.timestamp;\n        \n        emit TierUpgraded(msg.sender, role, currentTier, newTier);\n        \n        // Refund excess\n        if (msg.value > tierMeta.price) {\n            payable(msg.sender).transfer(msg.value - tierMeta.price);\n        }\n    }\n    \n    /**\n     * @notice Upgrade to a higher tier with ERC20 token\n     * @param role The role to upgrade\n     * @param newTier The new tier\n     * @param paymentToken The ERC20 token to use for payment\n     * @param amount The amount of tokens to pay\n     */\n    function upgradeTierWithToken(\n        bytes32 role,\n        MembershipTier newTier,\n        address paymentToken,\n        uint256 amount\n    ) external nonReentrant whenNotPaused {\n        require(address(paymentManager) != address(0), \"Payment manager not set\");\n        \n        MembershipTier currentTier = userTiers[msg.sender][role];\n        require(currentTier != MembershipTier.NONE, \"Must have role first\");\n        require(newTier > currentTier, \"Can only upgrade to higher tier\");\n        \n        TierMetadata storage tierMeta = tierMetadata[role][newTier];\n        require(tierMeta.isActive, \"Tier not active\");\n        \n        // Transfer tokens from buyer to this contract\n        IERC20(paymentToken).safeTransferFrom(msg.sender, address(this), amount);\n        \n        // Approve payment manager to transfer tokens from this contract\n        IERC20(paymentToken).safeIncreaseAllowance(address(paymentManager), amount);\n        \n        // Process payment through payment manager (payment manager will transfer from this contract)\n        bytes32 paymentId = paymentManager.processPayment(\n            address(this), // payer is this contract (we already have the tokens)\n            msg.sender,    // buyer is the actual user\n            role,\n            paymentToken,\n            amount,\n            uint8(newTier)\n        );\n        \n        // Upgrade tier\n        userTiers[msg.sender][role] = newTier;\n        tierPurchases[msg.sender][role][newTier] = block.timestamp;\n        \n        emit TierUpgraded(msg.sender, role, currentTier, newTier);\n    }\n    \n    // ========== Usage Tracking & Enforcement ==========\n    \n    /**\n     * @notice Set membership duration for a user's role\n     * @param user The user address\n     * @param role The role\n     * @param duration The membership duration type\n     */\n    function _setMembershipDuration(address user, bytes32 role, MembershipDuration duration) internal {\n        uint256 durationInSeconds;\n        \n        if (duration == MembershipDuration.ONE_MONTH) {\n            durationInSeconds = 30 days;\n        } else if (duration == MembershipDuration.THREE_MONTHS) {\n            durationInSeconds = 90 days;\n        } else if (duration == MembershipDuration.SIX_MONTHS) {\n            durationInSeconds = 180 days;\n        } else if (duration == MembershipDuration.TWELVE_MONTHS) {\n            durationInSeconds = 365 days;\n        } else if (duration == MembershipDuration.ENTERPRISE) {\n            // Enterprise memberships don't expire (set to far future)\n            durationInSeconds = 100 * 365 days;\n        }\n        \n        membershipDurationType[user][role] = duration;\n        membershipExpiration[user][role] = block.timestamp + durationInSeconds;\n        \n        emit MembershipExtended(user, role, membershipExpiration[user][role], duration);\n    }\n    \n    /**\n     * @notice Check if membership is still active\n     * @param user The user address\n     * @param role The role\n     * @return bool Whether membership is active\n     */\n    function isMembershipActive(address user, bytes32 role) public view returns (bool) {\n        return block.timestamp < membershipExpiration[user][role];\n    }\n    \n    /**\n     * @notice Extend membership by purchasing additional duration\n     * @param role The role to extend\n     * @param duration The additional duration to add\n     */\n    function extendMembership(bytes32 role, MembershipDuration duration) external payable nonReentrant whenNotPaused {\n        require(userTiers[msg.sender][role] != MembershipTier.NONE, \"No existing membership\");\n        require(isMembershipActive(msg.sender, role), \"Membership expired, must repurchase\");\n        \n        // For simplicity, charge same as tier upgrade price\n        MembershipTier tier = userTiers[msg.sender][role];\n        TierMetadata storage tierMeta = tierMetadata[role][tier];\n        require(msg.value >= tierMeta.price / 2, \"Insufficient payment for extension\"); // 50% of original price\n        \n        uint256 durationInSeconds;\n        if (duration == MembershipDuration.ONE_MONTH) {\n            durationInSeconds = 30 days;\n        } else if (duration == MembershipDuration.THREE_MONTHS) {\n            durationInSeconds = 90 days;\n        } else if (duration == MembershipDuration.SIX_MONTHS) {\n            durationInSeconds = 180 days;\n        } else if (duration == MembershipDuration.TWELVE_MONTHS) {\n            durationInSeconds = 365 days;\n        }\n        \n        membershipExpiration[msg.sender][role] += durationInSeconds;\n        emit MembershipExtended(msg.sender, role, membershipExpiration[msg.sender][role], duration);\n        \n        // Refund excess\n        uint256 extensionCost = tierMeta.price / 2;\n        if (msg.value > extensionCost) {\n            payable(msg.sender).transfer(msg.value - extensionCost);\n        }\n    }\n    \n    function _initializeUsageStats(address user, bytes32 role) internal {\n        usageStats[user][role] = UsageStats({\n            dailyBetsCount: 0,\n            weeklyBetsCount: 0,\n            monthlyMarketsCreated: 0,\n            dailyWithdrawals: 0,\n            activeMarketsCount: 0,\n            lastDailyReset: block.timestamp,\n            lastWeeklyReset: block.timestamp,\n            lastMonthlyReset: block.timestamp\n        });\n    }\n    \n    /**\n     * @notice Check and enforce bet limit\n     * @param role The role to check\n     * @return allowed Whether the action is allowed\n     */\n    function checkBetLimit(bytes32 role) external returns (bool allowed) {\n        _resetUsageIfNeeded(msg.sender, role);\n        \n        MembershipTier tier = userTiers[msg.sender][role];\n        require(tier != MembershipTier.NONE, \"No tier found\");\n        \n        TierLimits storage limits = tierMetadata[role][tier].limits;\n        UsageStats storage stats = usageStats[msg.sender][role];\n        \n        if (stats.dailyBetsCount >= limits.dailyBetLimit || stats.weeklyBetsCount >= limits.weeklyBetLimit) {\n            emit UsageLimitExceeded(msg.sender, role, \"bet_limit\");\n            return false;\n        }\n        \n        stats.dailyBetsCount++;\n        stats.weeklyBetsCount++;\n        emit UsageRecorded(msg.sender, role, \"bet\");\n        \n        return true;\n    }\n    \n    /**\n     * @notice Check and enforce market creation limit\n     * @param role The role to check\n     * @return allowed Whether the action is allowed\n     */\n    function checkMarketCreationLimit(bytes32 role) external returns (bool allowed) {\n        return checkMarketCreationLimitFor(msg.sender, role);\n    }\n    \n    /**\n     * @notice Check and enforce market creation limit for a specific user\n     * @param user The user to check limits for\n     * @param role The role to check\n     * @return allowed Whether the action is allowed\n     */\n    function checkMarketCreationLimitFor(address user, bytes32 role) public returns (bool allowed) {\n        _resetUsageIfNeeded(user, role);\n        \n        MembershipTier tier = userTiers[user][role];\n        require(tier != MembershipTier.NONE, \"No tier found\");\n        \n        TierLimits storage limits = tierMetadata[role][tier].limits;\n        UsageStats storage stats = usageStats[user][role];\n        \n        if (stats.monthlyMarketsCreated >= limits.monthlyMarketCreation || \n            stats.activeMarketsCount >= limits.maxConcurrentMarkets) {\n            emit UsageLimitExceeded(user, role, \"market_creation\");\n            return false;\n        }\n        \n        stats.monthlyMarketsCreated++;\n        stats.activeMarketsCount++;\n        emit UsageRecorded(user, role, \"market_created\");\n        \n        return true;\n    }\n    \n    /**\n     * @notice Record market closure\n     */\n    function recordMarketClosure(bytes32 role) external {\n        UsageStats storage stats = usageStats[msg.sender][role];\n        if (stats.activeMarketsCount > 0) {\n            stats.activeMarketsCount--;\n        }\n    }\n    \n    /**\n     * @notice Check withdrawal limit\n     * @param role The role to check\n     * @param amount The withdrawal amount\n     * @return allowed Whether the withdrawal is allowed\n     */\n    function checkWithdrawalLimit(bytes32 role, uint256 amount) external returns (bool allowed) {\n        _resetUsageIfNeeded(msg.sender, role);\n        \n        MembershipTier tier = userTiers[msg.sender][role];\n        require(tier != MembershipTier.NONE, \"No tier found\");\n        \n        TierLimits storage limits = tierMetadata[role][tier].limits;\n        UsageStats storage stats = usageStats[msg.sender][role];\n        \n        if (stats.dailyWithdrawals + amount > limits.withdrawalLimit) {\n            emit UsageLimitExceeded(msg.sender, role, \"withdrawal_limit\");\n            return false;\n        }\n        \n        stats.dailyWithdrawals += amount;\n        emit UsageRecorded(msg.sender, role, \"withdrawal\");\n        \n        return true;\n    }\n    \n    function _resetUsageIfNeeded(address user, bytes32 role) internal {\n        UsageStats storage stats = usageStats[user][role];\n        \n        // Reset daily stats (24 hours)\n        if (block.timestamp >= stats.lastDailyReset + 1 days) {\n            stats.dailyBetsCount = 0;\n            stats.dailyWithdrawals = 0;\n            stats.lastDailyReset = block.timestamp;\n        }\n        \n        // Reset weekly stats (7 days)\n        if (block.timestamp >= stats.lastWeeklyReset + 7 days) {\n            stats.weeklyBetsCount = 0;\n            stats.lastWeeklyReset = block.timestamp;\n        }\n        \n        // Reset monthly stats (30 days)\n        if (block.timestamp >= stats.lastMonthlyReset + 30 days) {\n            stats.monthlyMarketsCreated = 0;\n            stats.lastMonthlyReset = block.timestamp;\n        }\n    }\n    \n    // ========== View Functions ==========\n    \n    /**\n     * @notice Get user's current tier for a role\n     */\n    function getUserTier(address user, bytes32 role) external view returns (MembershipTier) {\n        return userTiers[user][role];\n    }\n    \n    /**\n     * @notice Get tier metadata\n     */\n    function getTierMetadata(bytes32 role, MembershipTier tier) external view returns (TierMetadata memory) {\n        return tierMetadata[role][tier];\n    }\n    \n    /**\n     * @notice Get tier limits\n     */\n    function getTierLimits(bytes32 role, MembershipTier tier) external view returns (TierLimits memory) {\n        return tierMetadata[role][tier].limits;\n    }\n    \n    /**\n     * @notice Get user's usage stats\n     */\n    function getUserUsageStats(address user, bytes32 role) external view returns (UsageStats memory) {\n        return usageStats[user][role];\n    }\n    \n    /**\n     * @notice Check if user can create private markets\n     */\n    function canCreatePrivateMarkets(address user, bytes32 role) external view returns (bool) {\n        MembershipTier tier = userTiers[user][role];\n        if (tier == MembershipTier.NONE) return false;\n        return tierMetadata[role][tier].limits.canCreatePrivateMarkets;\n    }\n    \n    /**\n     * @notice Check if user can use advanced features\n     */\n    function canUseAdvancedFeatures(address user, bytes32 role) external view returns (bool) {\n        MembershipTier tier = userTiers[user][role];\n        if (tier == MembershipTier.NONE) return false;\n        return tierMetadata[role][tier].limits.canUseAdvancedFeatures;\n    }\n    \n    /**\n     * @notice Get user's fee discount\n     */\n    function getFeeDiscount(address user, bytes32 role) external view returns (uint256) {\n        MembershipTier tier = userTiers[user][role];\n        if (tier == MembershipTier.NONE) return 0;\n        return tierMetadata[role][tier].limits.feeDiscount;\n    }\n}\n"
    },
    "contracts/WelfareMetricRegistry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./TieredRoleManager.sol\";\n\n/**\n * @title WelfareMetricRegistry\n * @notice On-chain storage of democratically-selected protocol success measures with role-based management\n * @dev Manages welfare metrics with versioning and update mechanisms\n * Supports multiple metric categories: governance, financial, betting, and private-sector style\n * \n * RBAC INTEGRATION:\n * - Metric registration requires OPERATIONS_ADMIN_ROLE\n * - Metric updates require OPERATIONS_ADMIN_ROLE\n */\ncontract WelfareMetricRegistry is Ownable, ReentrancyGuard {\n    enum MetricCategory {\n        Governance,      // On-chain governance metrics (proposals, voting, participation)\n        Financial,       // Revenue, profit, ROI, treasury value\n        Betting,         // Prediction market metrics (volume, accuracy, liquidity)\n        PrivateSector    // Traditional company metrics (for accredited investors)\n    }\n\n    struct WelfareMetric {\n        string name;\n        string description;\n        uint256 weight; // Basis points (10000 = 100%)\n        MetricCategory category;\n        bool active;\n        uint256 activatedAt;\n    }\n\n    struct MetricValue {\n        uint256 value;\n        uint256 timestamp;\n        address reporter;\n    }\n\n    struct AggregatedMetrics {\n        uint256 governanceScore;\n        uint256 financialScore;\n        uint256 bettingScore;\n        uint256 privateSectorScore;\n        uint256 overallScore;\n        uint256 timestamp;\n    }\n\n    // Metric ID => WelfareMetric\n    mapping(uint256 => WelfareMetric) public metrics;\n    \n    // Metric ID => historical values\n    mapping(uint256 => MetricValue[]) public metricHistory;\n    \n    // DAO ID => Metric ID => latest value\n    mapping(uint256 => mapping(uint256 => uint256)) public latestMetricValues;\n    \n    // Array of active metric IDs\n    uint256[] public activeMetricIds;\n    \n    uint256 public metricCount;\n    uint256 public constant VOTING_PERIOD = 14 days;\n    uint256 public constant TOTAL_WEIGHT = 10000; // 100% in basis points\n\n    bool private _initialized;\n    \n    // Role-based access control\n    TieredRoleManager public roleManager;\n\n    event MetricProposed(uint256 indexed metricId, string name, string description, uint256 weight, MetricCategory category);\n    event MetricActivated(uint256 indexed metricId);\n    event MetricDeactivated(uint256 indexed metricId);\n    event MetricUpdated(uint256 indexed metricId, uint256 newWeight);\n    event MetricValueRecorded(uint256 indexed metricId, uint256 value, uint256 timestamp, address reporter);\n\n    constructor() Ownable(msg.sender) {}\n    \n    /**\n     * @notice Set the role manager contract\n     * @param _roleManager Address of TieredRoleManager contract\n     */\n    function setRoleManager(address _roleManager) external onlyOwner {\n        require(_roleManager != address(0), \"Invalid role manager address\");\n        require(address(roleManager) == address(0), \"Role manager already set\");\n        roleManager = TieredRoleManager(_roleManager);\n    }\n\n    /**\n     * @notice Initialize the contract (used for clones)\n     * @param initialOwner Address of the initial owner\n     */\n    function initialize(address initialOwner) external {\n        require(!_initialized, \"Already initialized\");\n        require(initialOwner != address(0), \"Invalid owner\");\n        _initialized = true;\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @notice Propose a new welfare metric\n     * @param name Name of the metric\n     * @param description Detailed description\n     * @param weight Weight in basis points (max 10000)\n     * @param category Category of the metric\n     */\n    function proposeMetric(\n        string calldata name,\n        string calldata description,\n        uint256 weight,\n        MetricCategory category\n    ) external onlyOwner returns (uint256) {\n        require(weight > 0 && weight <= TOTAL_WEIGHT, \"Invalid weight\");\n        require(bytes(name).length > 0, \"Empty name\");\n\n        uint256 metricId = metricCount++;\n        \n        metrics[metricId] = WelfareMetric({\n            name: name,\n            description: description,\n            weight: weight,\n            category: category,\n            active: false,\n            activatedAt: 0\n        });\n\n        emit MetricProposed(metricId, name, description, weight, category);\n        return metricId;\n    }\n\n    /**\n     * @notice Activate a proposed metric\n     * @param metricId ID of the metric to activate\n     */\n    function activateMetric(uint256 metricId) external onlyOwner {\n        require(metricId < metricCount, \"Invalid metric ID\");\n        require(!metrics[metricId].active, \"Already active\");\n\n        metrics[metricId].active = true;\n        metrics[metricId].activatedAt = block.timestamp;\n        activeMetricIds.push(metricId);\n\n        emit MetricActivated(metricId);\n    }\n\n    /**\n     * @notice Deactivate an active metric\n     * @param metricId ID of the metric to deactivate\n     */\n    function deactivateMetric(uint256 metricId) external onlyOwner {\n        require(metrics[metricId].active, \"Not active\");\n\n        metrics[metricId].active = false;\n\n        // Remove from active array\n        for (uint256 i = 0; i < activeMetricIds.length; i++) {\n            if (activeMetricIds[i] == metricId) {\n                activeMetricIds[i] = activeMetricIds[activeMetricIds.length - 1];\n                activeMetricIds.pop();\n                break;\n            }\n        }\n\n        emit MetricDeactivated(metricId);\n    }\n\n    /**\n     * @notice Update metric weight\n     * @param metricId ID of the metric\n     * @param newWeight New weight in basis points\n     */\n    function updateMetricWeight(uint256 metricId, uint256 newWeight) external onlyOwner {\n        require(metricId < metricCount, \"Invalid metric ID\");\n        require(newWeight > 0 && newWeight <= TOTAL_WEIGHT, \"Invalid weight\");\n\n        metrics[metricId].weight = newWeight;\n        emit MetricUpdated(metricId, newWeight);\n    }\n\n    /**\n     * @notice Get all active metrics\n     * @return Array of active metric IDs\n     */\n    function getActiveMetrics() external view returns (uint256[] memory) {\n        return activeMetricIds;\n    }\n\n    /**\n     * @notice Get metric details\n     * @param metricId ID of the metric\n     * @return Metric details\n     */\n    function getMetric(uint256 metricId) external view returns (WelfareMetric memory) {\n        require(metricId < metricCount, \"Invalid metric ID\");\n        return metrics[metricId];\n    }\n\n    /**\n     * @notice Record a metric value\n     * @param metricId ID of the metric\n     * @param value Value to record\n     */\n    function recordMetricValue(uint256 metricId, uint256 value) external onlyOwner {\n        require(metricId < metricCount, \"Invalid metric ID\");\n        require(metrics[metricId].active, \"Metric not active\");\n\n        metricHistory[metricId].push(MetricValue({\n            value: value,\n            timestamp: block.timestamp,\n            reporter: msg.sender\n        }));\n\n        latestMetricValues[0][metricId] = value; // Using 0 as default DAO ID\n\n        emit MetricValueRecorded(metricId, value, block.timestamp, msg.sender);\n    }\n\n    /**\n     * @notice Get metric history\n     * @param metricId ID of the metric\n     * @param count Number of historical values to return (from most recent)\n     * @return Array of metric values\n     */\n    function getMetricHistory(uint256 metricId, uint256 count) \n        external \n        view \n        returns (MetricValue[] memory) \n    {\n        require(metricId < metricCount, \"Invalid metric ID\");\n        \n        MetricValue[] storage history = metricHistory[metricId];\n        uint256 length = history.length;\n        \n        if (count > length) {\n            count = length;\n        }\n        \n        MetricValue[] memory result = new MetricValue[](count);\n        \n        for (uint256 i = 0; i < count; i++) {\n            result[i] = history[length - count + i];\n        }\n        \n        return result;\n    }\n\n    /**\n     * @notice Get aggregated metrics by category\n     * @return AggregatedMetrics struct with scores by category\n     */\n    function getAggregatedMetrics() external view returns (AggregatedMetrics memory) {\n        uint256 governanceScore = 0;\n        uint256 financialScore = 0;\n        uint256 bettingScore = 0;\n        uint256 privateSectorScore = 0;\n        \n        uint256 governanceWeight = 0;\n        uint256 financialWeight = 0;\n        uint256 bettingWeight = 0;\n        uint256 privateSectorWeight = 0;\n\n        uint256 length = activeMetricIds.length; // Cache array length\n        for (uint256 i = 0; i < length; i++) {\n            uint256 metricId = activeMetricIds[i];\n            WelfareMetric memory metric = metrics[metricId];\n            uint256 value = latestMetricValues[0][metricId];\n\n            if (metric.category == MetricCategory.Governance) {\n                governanceScore += value * metric.weight;\n                governanceWeight += metric.weight;\n            } else if (metric.category == MetricCategory.Financial) {\n                financialScore += value * metric.weight;\n                financialWeight += metric.weight;\n            } else if (metric.category == MetricCategory.Betting) {\n                bettingScore += value * metric.weight;\n                bettingWeight += metric.weight;\n            } else if (metric.category == MetricCategory.PrivateSector) {\n                privateSectorScore += value * metric.weight;\n                privateSectorWeight += metric.weight;\n            }\n        }\n\n        // Normalize scores\n        if (governanceWeight > 0) governanceScore = governanceScore / governanceWeight;\n        if (financialWeight > 0) financialScore = financialScore / financialWeight;\n        if (bettingWeight > 0) bettingScore = bettingScore / bettingWeight;\n        if (privateSectorWeight > 0) privateSectorScore = privateSectorScore / privateSectorWeight;\n\n        // Calculate overall score\n        uint256 overallScore = (governanceScore + financialScore + bettingScore + privateSectorScore) / 4;\n\n        return AggregatedMetrics({\n            governanceScore: governanceScore,\n            financialScore: financialScore,\n            bettingScore: bettingScore,\n            privateSectorScore: privateSectorScore,\n            overallScore: overallScore,\n            timestamp: block.timestamp\n        });\n    }\n\n    /**\n     * @notice Get metrics by category\n     * @param category Category to filter by\n     * @return Array of metric IDs in the category\n     */\n    function getMetricsByCategory(MetricCategory category) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        uint256 count = 0;\n        \n        // Count metrics in category - cache array length\n        uint256 length = activeMetricIds.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (metrics[activeMetricIds[i]].category == category) {\n                count++;\n            }\n        }\n        \n        // Populate result array - reuse cached length\n        uint256[] memory result = new uint256[](count);\n        uint256 index = 0;\n        \n        for (uint256 i = 0; i < length; i++) {\n            uint256 metricId = activeMetricIds[i];\n            if (metrics[metricId].category == category) {\n                result[index] = metricId;\n                index++;\n            }\n        }\n        \n        return result;\n    }\n}\n"
    },
    "contracts/ZKKeyManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\n/**\n * @title ZKKeyManager\n * @notice Production-ready ZK key lifecycle management for ClearPath system\n * @dev Manages registration, rotation, and revocation of zero-knowledge public keys\n * \n * Key Lifecycle:\n * 1. Registration - User registers initial ZK public key\n * 2. Active - Key is valid and can be used for ZK proofs\n * 3. Rotation - User can rotate to a new key, invalidating old key\n * 4. Revocation - Admin or user can revoke a key\n * 5. Expired - Keys automatically expire after configured duration\n */\ncontract ZKKeyManager is AccessControl, Pausable {\n    \n    // ========== Role Definitions ==========\n    \n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant CLEARPATH_USER_ROLE = keccak256(\"CLEARPATH_USER_ROLE\");\n    bytes32 public constant DELEGATE_ROLE = keccak256(\"DELEGATE_ROLE\"); // For contracts acting on behalf of users\n    \n    // ========== Key Status ==========\n    \n    enum KeyStatus {\n        NONE,           // Key doesn't exist\n        ACTIVE,         // Key is valid\n        ROTATED,        // Key has been rotated (replaced)\n        REVOKED,        // Key has been revoked\n        EXPIRED         // Key has expired\n    }\n    \n    // ========== Key Metadata ==========\n    \n    struct ZKKey {\n        bytes32 keyHash;        // Hash of the public key for efficient storage\n        string publicKey;       // Full public key string\n        uint256 registeredAt;   // Timestamp of registration\n        uint256 expiresAt;      // Expiration timestamp\n        KeyStatus status;       // Current status\n        uint256 rotationCount;  // Number of times user has rotated\n        bytes32 previousKeyHash; // Hash of previous key (for rotation history)\n    }\n    \n    // ========== Storage ==========\n    \n    // User address => current key hash\n    mapping(address => bytes32) public currentKeyHash;\n    \n    // Key hash => ZKKey metadata\n    mapping(bytes32 => ZKKey) public keys;\n    \n    // User address => all key hashes (history)\n    mapping(address => bytes32[]) public userKeyHistory;\n    \n    // Nonce for key hash generation (prevents predictability)\n    uint256 private keyNonce;\n    \n    // Configuration\n    uint256 public keyExpirationDuration;  // Default: 365 days\n    uint256 public maxRotationsPerYear;     // Rate limiting\n    bool public requireKeyExpiration;       // Toggle expiration requirement\n    \n    // Rate limiting tracking\n    mapping(address => uint256) public rotationsThisYear;\n    mapping(address => uint256) public yearStartTime;\n    \n    // ========== Events ==========\n    \n    event KeyRegistered(\n        address indexed user,\n        bytes32 indexed keyHash,\n        uint256 expiresAt,\n        uint256 timestamp\n    );\n    \n    event KeyRotated(\n        address indexed user,\n        bytes32 indexed oldKeyHash,\n        bytes32 indexed newKeyHash,\n        uint256 timestamp\n    );\n    \n    event KeyRevoked(\n        address indexed user,\n        bytes32 indexed keyHash,\n        address indexed revoker,\n        uint256 timestamp\n    );\n    \n    event KeyExpired(\n        address indexed user,\n        bytes32 indexed keyHash,\n        uint256 timestamp\n    );\n    \n    event ConfigurationUpdated(\n        uint256 keyExpirationDuration,\n        uint256 maxRotationsPerYear,\n        bool requireKeyExpiration\n    );\n    \n    // ========== Errors ==========\n    \n    error KeyAlreadyExists(address user);\n    error NoKeyRegistered(address user);\n    error InvalidKeyFormat(string reason);\n    error KeyNotActive(bytes32 keyHash, KeyStatus status);\n    error RateLimitExceeded(address user, uint256 rotationsThisYear);\n    error UnauthorizedRevocation(address caller, address keyOwner);\n    error KeyExpiredError(bytes32 keyHash);\n    \n    // ========== Constructor ==========\n    \n    constructor() {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN_ROLE, msg.sender);\n        \n        // Default configuration\n        keyExpirationDuration = 365 days;\n        maxRotationsPerYear = 4;  // Once per quarter\n        requireKeyExpiration = true;\n    }\n    \n    // ========== Key Registration ==========\n    \n    /**\n     * @notice Register a new ZK public key\n     * @param publicKey The zero-knowledge public key (base64 or hex encoded)\n     * @dev Validates key format and creates new key entry\n     */\n    function registerKey(string memory publicKey) external whenNotPaused {\n        _registerKeyFor(msg.sender, publicKey);\n    }\n    \n    /**\n     * @notice Register a new ZK public key for a user (delegate call)\n     * @param user The user to register the key for\n     * @param publicKey The zero-knowledge public key\n     * @dev Can only be called by contracts with DELEGATE_ROLE\n     */\n    function registerKeyFor(address user, string memory publicKey) external whenNotPaused {\n        require(hasRole(DELEGATE_ROLE, msg.sender), \"Not authorized delegate\");\n        _registerKeyFor(user, publicKey);\n    }\n    \n    /**\n     * @dev Internal function to register a key for a user\n     */\n    function _registerKeyFor(address user, string memory publicKey) internal {\n        // Check user doesn't already have an active key\n        bytes32 existingKeyHash = currentKeyHash[user];\n        if (existingKeyHash != bytes32(0)) {\n            ZKKey storage existingKey = keys[existingKeyHash];\n            if (existingKey.status == KeyStatus.ACTIVE && !_isExpired(existingKey)) {\n                revert KeyAlreadyExists(user);\n            }\n        }\n        \n        // Validate key format\n        _validateKeyFormat(publicKey);\n        \n        // Create key hash with multiple sources of entropy\n        // Using: user address, public key, block timestamp, and incrementing nonce\n        // This ensures uniqueness and unpredictability without relying on prevrandao\n        bytes32 keyHash = keccak256(abi.encodePacked(\n            user, \n            publicKey, \n            block.timestamp,\n            ++keyNonce\n        ));\n        \n        // Calculate expiration\n        uint256 expiresAt = requireKeyExpiration \n            ? block.timestamp + keyExpirationDuration \n            : type(uint256).max;\n        \n        // Store key metadata\n        keys[keyHash] = ZKKey({\n            keyHash: keyHash,\n            publicKey: publicKey,\n            registeredAt: block.timestamp,\n            expiresAt: expiresAt,\n            status: KeyStatus.ACTIVE,\n            rotationCount: 0,\n            previousKeyHash: bytes32(0)\n        });\n        \n        // Update current key\n        currentKeyHash[user] = keyHash;\n        \n        // Add to history\n        userKeyHistory[user].push(keyHash);\n        \n        // Initialize rate limiting\n        if (yearStartTime[user] == 0) {\n            yearStartTime[user] = block.timestamp;\n        }\n        \n        emit KeyRegistered(user, keyHash, expiresAt, block.timestamp);\n    }\n    \n    // ========== Key Rotation ==========\n    \n    /**\n     * @notice Rotate to a new ZK public key\n     * @param newPublicKey The new zero-knowledge public key\n     * @dev Marks old key as ROTATED and registers new key\n     */\n    function rotateKey(string memory newPublicKey) external whenNotPaused {\n        _rotateKeyFor(msg.sender, newPublicKey);\n    }\n    \n    /**\n     * @notice Rotate to a new ZK public key for a user (delegate call)\n     * @param user The user to rotate the key for\n     * @param newPublicKey The new zero-knowledge public key\n     * @dev Can only be called by contracts with DELEGATE_ROLE\n     */\n    function rotateKeyFor(address user, string memory newPublicKey) external whenNotPaused {\n        require(hasRole(DELEGATE_ROLE, msg.sender), \"Not authorized delegate\");\n        _rotateKeyFor(user, newPublicKey);\n    }\n    \n    /**\n     * @dev Internal function to rotate a key for a user\n     */\n    function _rotateKeyFor(address user, string memory newPublicKey) internal {\n        bytes32 oldKeyHash = currentKeyHash[user];\n        if (oldKeyHash == bytes32(0)) {\n            revert NoKeyRegistered(user);\n        }\n        \n        ZKKey storage oldKey = keys[oldKeyHash];\n        if (oldKey.status != KeyStatus.ACTIVE) {\n            revert KeyNotActive(oldKeyHash, oldKey.status);\n        }\n        \n        // Check rate limiting\n        _checkRotationRateLimit(user);\n        \n        // Validate new key format\n        _validateKeyFormat(newPublicKey);\n        \n        // Create new key hash with multiple sources of entropy\n        bytes32 newKeyHash = keccak256(abi.encodePacked(\n            user, \n            newPublicKey, \n            block.timestamp,\n            ++keyNonce\n        ));\n        \n        // Calculate expiration\n        uint256 expiresAt = requireKeyExpiration \n            ? block.timestamp + keyExpirationDuration \n            : type(uint256).max;\n        \n        // Mark old key as rotated\n        oldKey.status = KeyStatus.ROTATED;\n        \n        // Create new key\n        keys[newKeyHash] = ZKKey({\n            keyHash: newKeyHash,\n            publicKey: newPublicKey,\n            registeredAt: block.timestamp,\n            expiresAt: expiresAt,\n            status: KeyStatus.ACTIVE,\n            rotationCount: oldKey.rotationCount + 1,\n            previousKeyHash: oldKeyHash\n        });\n        \n        // Update current key\n        currentKeyHash[user] = newKeyHash;\n        \n        // Add to history\n        userKeyHistory[user].push(newKeyHash);\n        \n        // Update rate limiting\n        rotationsThisYear[user]++;\n        \n        emit KeyRotated(user, oldKeyHash, newKeyHash, block.timestamp);\n    }\n    \n    // ========== Key Revocation ==========\n    \n    /**\n     * @notice Revoke a ZK public key\n     * @param user Address of the key owner\n     * @dev Can be called by key owner, admin, or delegate (e.g., RoleManager)\n     */\n    function revokeKey(address user) external whenNotPaused {\n        // Check authorization: user themselves, admin, or delegate\n        if (msg.sender != user && !hasRole(ADMIN_ROLE, msg.sender) && !hasRole(DELEGATE_ROLE, msg.sender)) {\n            revert UnauthorizedRevocation(msg.sender, user);\n        }\n        \n        bytes32 keyHash = currentKeyHash[user];\n        if (keyHash == bytes32(0)) {\n            revert NoKeyRegistered(user);\n        }\n        \n        ZKKey storage key = keys[keyHash];\n        if (key.status != KeyStatus.ACTIVE) {\n            revert KeyNotActive(keyHash, key.status);\n        }\n        \n        // Mark as revoked\n        key.status = KeyStatus.REVOKED;\n        \n        emit KeyRevoked(user, keyHash, msg.sender, block.timestamp);\n    }\n    \n    // ========== Key Validation ==========\n    \n    /**\n     * @notice Validate that a user has an active ZK key\n     * @param user Address to check\n     * @return bool True if user has valid active key\n     */\n    function hasValidKey(address user) external view returns (bool) {\n        bytes32 keyHash = currentKeyHash[user];\n        if (keyHash == bytes32(0)) {\n            return false;\n        }\n        \n        ZKKey storage key = keys[keyHash];\n        return key.status == KeyStatus.ACTIVE && !_isExpired(key);\n    }\n    \n    /**\n     * @notice Get user's current public key\n     * @param user Address to query\n     * @return publicKey The current public key string\n     */\n    function getPublicKey(address user) external view returns (string memory) {\n        bytes32 keyHash = currentKeyHash[user];\n        if (keyHash == bytes32(0)) {\n            return \"\";\n        }\n        \n        return keys[keyHash].publicKey;\n    }\n    \n    /**\n     * @notice Get detailed key metadata\n     * @param user Address to query\n     * @return key The ZKKey struct\n     */\n    function getKeyMetadata(address user) external view returns (ZKKey memory) {\n        bytes32 keyHash = currentKeyHash[user];\n        require(keyHash != bytes32(0), \"No key registered\");\n        \n        return keys[keyHash];\n    }\n    \n    /**\n     * @notice Get user's key rotation history\n     * @param user Address to query\n     * @return Array of key hashes in chronological order\n     */\n    function getKeyHistory(address user) external view returns (bytes32[] memory) {\n        return userKeyHistory[user];\n    }\n    \n    /**\n     * @notice Check if a specific key is valid and active\n     * @param keyHash Hash of the key to check\n     * @return bool True if key is active and not expired\n     */\n    function isKeyValid(bytes32 keyHash) external view returns (bool) {\n        ZKKey storage key = keys[keyHash];\n        return key.status == KeyStatus.ACTIVE && !_isExpired(key);\n    }\n    \n    // ========== Internal Functions ==========\n    \n    /**\n     * @dev Validate key format and length\n     */\n    function _validateKeyFormat(string memory publicKey) internal pure {\n        bytes memory keyBytes = bytes(publicKey);\n        \n        // Minimum length check (typical ZK keys are 64+ characters)\n        if (keyBytes.length < 32) {\n            revert InvalidKeyFormat(\"Key too short\");\n        }\n        \n        // Maximum length check (prevent DoS)\n        if (keyBytes.length > 512) {\n            revert InvalidKeyFormat(\"Key too long\");\n        }\n        \n        // Check for empty or only whitespace\n        if (keyBytes.length == 0) {\n            revert InvalidKeyFormat(\"Key is empty\");\n        }\n    }\n    \n    /**\n     * @dev Check if key has expired\n     */\n    function _isExpired(ZKKey storage key) internal view returns (bool) {\n        if (!requireKeyExpiration) {\n            return false;\n        }\n        return block.timestamp >= key.expiresAt;\n    }\n    \n    /**\n     * @dev Check rotation rate limit\n     */\n    function _checkRotationRateLimit(address user) internal {\n        // Reset counter if year has passed\n        if (block.timestamp >= yearStartTime[user] + 365 days) {\n            yearStartTime[user] = block.timestamp;\n            rotationsThisYear[user] = 0;\n        }\n        \n        // Check limit\n        if (rotationsThisYear[user] >= maxRotationsPerYear) {\n            revert RateLimitExceeded(user, rotationsThisYear[user]);\n        }\n    }\n    \n    // ========== Admin Functions ==========\n    \n    /**\n     * @notice Update configuration parameters\n     * @param _keyExpirationDuration New expiration duration in seconds\n     * @param _maxRotationsPerYear New max rotations per year\n     * @param _requireKeyExpiration Whether to enforce expiration\n     */\n    function updateConfiguration(\n        uint256 _keyExpirationDuration,\n        uint256 _maxRotationsPerYear,\n        bool _requireKeyExpiration\n    ) external onlyRole(ADMIN_ROLE) {\n        require(_keyExpirationDuration >= 30 days, \"Expiration too short\");\n        require(_keyExpirationDuration <= 730 days, \"Expiration too long\");\n        require(_maxRotationsPerYear > 0, \"Must allow rotations\");\n        require(_maxRotationsPerYear <= 52, \"Too many rotations\");\n        \n        keyExpirationDuration = _keyExpirationDuration;\n        maxRotationsPerYear = _maxRotationsPerYear;\n        requireKeyExpiration = _requireKeyExpiration;\n        \n        emit ConfigurationUpdated(_keyExpirationDuration, _maxRotationsPerYear, _requireKeyExpiration);\n    }\n    \n    /**\n     * @notice Emergency pause\n     */\n    function pause() external onlyRole(ADMIN_ROLE) {\n        _pause();\n    }\n    \n    /**\n     * @notice Unpause\n     */\n    function unpause() external onlyRole(ADMIN_ROLE) {\n        _unpause();\n    }\n    \n    /**\n     * @notice Manually expire a key (admin only)\n     * @param user Address of key owner\n     */\n    function expireKey(address user) external onlyRole(ADMIN_ROLE) {\n        bytes32 keyHash = currentKeyHash[user];\n        require(keyHash != bytes32(0), \"No key registered\");\n        \n        ZKKey storage key = keys[keyHash];\n        require(key.status == KeyStatus.ACTIVE, \"Key not active\");\n        \n        key.status = KeyStatus.EXPIRED;\n        \n        emit KeyExpired(user, keyHash, block.timestamp);\n    }\n}\n"
    },
    "contracts/ZKVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @title ZKVerifier\n * @notice Production-ready zero-knowledge proof verification using BN128 precompiles\n * @dev Implements Groth16 zkSNARK verification for position validity\n * \n * This contract uses Ethereum's BN128 precompiled contracts for pairing checks:\n * - ecAdd (0x06): Point addition on BN128 curve\n * - ecMul (0x07): Scalar multiplication on BN128 curve  \n * - ecPairing (0x08): Bilinear pairing check\n */\ncontract ZKVerifier is AccessControl {\n    \n    // ========== Role Definitions ==========\n    \n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant VERIFIER_ADMIN_ROLE = keccak256(\"VERIFIER_ADMIN_ROLE\");\n    \n    // ========== Verification Key ==========\n    \n    struct VerificationKey {\n        uint256[2] alpha;           // G1 point\n        uint256[2][2] beta;         // G2 point\n        uint256[2][2] gamma;        // G2 point\n        uint256[2][2] delta;        // G2 point\n        uint256[2][] gammaABC;      // Array of G1 points\n        bool isInitialized;\n    }\n    \n    VerificationKey private vk;\n    \n    // ========== Proof Structure ==========\n    \n    struct Proof {\n        uint256[2] a;               // G1 point\n        uint256[2][2] b;            // G2 point\n        uint256[2] c;               // G1 point\n    }\n    \n    // ========== Events ==========\n    \n    event VerificationKeySet(address indexed setter, uint256 timestamp);\n    event ProofVerified(bytes32 indexed proofHash, bool valid, uint256 timestamp);\n    event VerificationFailed(bytes32 indexed proofHash, string reason, uint256 timestamp);\n    \n    // ========== Errors ==========\n    \n    error VerificationKeyNotSet();\n    error InvalidProofFormat(string reason);\n    error InvalidPublicInputs(string reason);\n    error PairingCheckFailed();\n    error InvalidCurvePoint(string point);\n    \n    // ========== Constructor ==========\n    \n    constructor() {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN_ROLE, msg.sender);\n        _grantRole(VERIFIER_ADMIN_ROLE, msg.sender);\n    }\n    \n    // ========== Verification Key Management ==========\n    \n    /**\n     * @notice Set the verification key for Groth16 proofs\n     * @param alpha Alpha component (G1)\n     * @param beta Beta component (G2)\n     * @param gamma Gamma component (G2)\n     * @param delta Delta component (G2)\n     * @param gammaABC Array of gamma ABC components (G1)\n     */\n    function setVerificationKey(\n        uint256[2] memory alpha,\n        uint256[2][2] memory beta,\n        uint256[2][2] memory gamma,\n        uint256[2][2] memory delta,\n        uint256[2][] memory gammaABC\n    ) external onlyRole(VERIFIER_ADMIN_ROLE) {\n        require(gammaABC.length > 0, \"gammaABC cannot be empty\");\n        \n        // Validate points are on curve\n        require(_isOnCurveG1(alpha), \"Invalid alpha point\");\n        require(_isOnCurveG2(beta), \"Invalid beta point\");\n        require(_isOnCurveG2(gamma), \"Invalid gamma point\");\n        require(_isOnCurveG2(delta), \"Invalid delta point\");\n        \n        for (uint256 i = 0; i < gammaABC.length; i++) {\n            require(_isOnCurveG1(gammaABC[i]), \"Invalid gammaABC point\");\n        }\n        \n        vk.alpha = alpha;\n        vk.beta = beta;\n        vk.gamma = gamma;\n        vk.delta = delta;\n        vk.gammaABC = gammaABC;\n        vk.isInitialized = true;\n        \n        emit VerificationKeySet(msg.sender, block.timestamp);\n    }\n    \n    // ========== Proof Verification ==========\n    \n    /**\n     * @notice Verify a Groth16 zkSNARK proof\n     * @param proofBytes Encoded proof data\n     * @param publicInputs Public inputs for the proof\n     * @return bool True if proof is valid\n     */\n    function verifyProof(\n        bytes calldata proofBytes,\n        uint256[] calldata publicInputs\n    ) external returns (bool) {\n        if (!vk.isInitialized) {\n            revert VerificationKeyNotSet();\n        }\n        \n        // Decode proof\n        Proof memory proof = _decodeProof(proofBytes);\n        \n        // Validate proof structure\n        _validateProof(proof);\n        \n        // Validate public inputs\n        _validatePublicInputs(publicInputs);\n        \n        // Compute hash for event\n        bytes32 proofHash = keccak256(proofBytes);\n        \n        // Perform verification\n        bool valid = _verifyGroth16(proof, publicInputs);\n        \n        if (valid) {\n            emit ProofVerified(proofHash, true, block.timestamp);\n        } else {\n            emit VerificationFailed(proofHash, \"Pairing check failed\", block.timestamp);\n        }\n        \n        return valid;\n    }\n    \n    /**\n     * @notice Verify a proof with simplified interface (for testing)\n     * @param a Proof component A (G1)\n     * @param b Proof component B (G2)\n     * @param c Proof component C (G1)\n     * @param publicInputs Public inputs\n     * @return bool True if proof is valid\n     */\n    function verifyProofComponents(\n        uint256[2] calldata a,\n        uint256[2][2] calldata b,\n        uint256[2] calldata c,\n        uint256[] calldata publicInputs\n    ) external returns (bool) {\n        if (!vk.isInitialized) {\n            revert VerificationKeyNotSet();\n        }\n        \n        Proof memory proof = Proof({\n            a: a,\n            b: b,\n            c: c\n        });\n        \n        _validateProof(proof);\n        _validatePublicInputs(publicInputs);\n        \n        bool valid = _verifyGroth16(proof, publicInputs);\n        \n        bytes32 proofHash = keccak256(abi.encodePacked(a, b, c));\n        \n        if (valid) {\n            emit ProofVerified(proofHash, true, block.timestamp);\n        } else {\n            emit VerificationFailed(proofHash, \"Pairing check failed\", block.timestamp);\n        }\n        \n        return valid;\n    }\n    \n    // ========== Internal Verification Logic ==========\n    \n    /**\n     * @dev Verify Groth16 proof using pairing check\n     * @param proof The proof to verify\n     * @param publicInputs Public inputs\n     * @return bool True if pairing check passes\n     */\n    function _verifyGroth16(\n        Proof memory proof,\n        uint256[] memory publicInputs\n    ) internal view returns (bool) {\n        // Check public inputs length\n        require(publicInputs.length + 1 == vk.gammaABC.length, \"Invalid public inputs length\");\n        \n        // Compute vk_x = gammaABC[0] + sum(publicInputs[i] * gammaABC[i+1])\n        uint256[2] memory vk_x = vk.gammaABC[0];\n        \n        for (uint256 i = 0; i < publicInputs.length; i++) {\n            uint256[2] memory point = _scalarMul(vk.gammaABC[i + 1], publicInputs[i]);\n            vk_x = _pointAdd(vk_x, point);\n        }\n        \n        // Perform pairing check:\n        // e(A, B) = e(alpha, beta) * e(vk_x, gamma) * e(C, delta)\n        // Equivalently: e(A, B) * e(-vk_x, gamma) * e(-C, delta) = e(-alpha, beta)\n        \n        return _pairingCheck(\n            proof.a,\n            proof.b,\n            vk_x,\n            vk.gamma,\n            proof.c,\n            vk.delta,\n            vk.alpha,\n            vk.beta\n        );\n    }\n    \n    /**\n     * @dev Decode proof from bytes\n     */\n    function _decodeProof(bytes calldata proofBytes) internal pure returns (Proof memory) {\n        require(proofBytes.length >= 256, \"Proof too short\");\n        \n        Proof memory proof;\n        \n        // Decode A (64 bytes = 2 * 32 bytes)\n        proof.a[0] = uint256(bytes32(proofBytes[0:32]));\n        proof.a[1] = uint256(bytes32(proofBytes[32:64]));\n        \n        // Decode B (128 bytes = 2 * 2 * 32 bytes)\n        proof.b[0][0] = uint256(bytes32(proofBytes[64:96]));\n        proof.b[0][1] = uint256(bytes32(proofBytes[96:128]));\n        proof.b[1][0] = uint256(bytes32(proofBytes[128:160]));\n        proof.b[1][1] = uint256(bytes32(proofBytes[160:192]));\n        \n        // Decode C (64 bytes = 2 * 32 bytes)\n        proof.c[0] = uint256(bytes32(proofBytes[192:224]));\n        proof.c[1] = uint256(bytes32(proofBytes[224:256]));\n        \n        return proof;\n    }\n    \n    /**\n     * @dev Validate proof components are on curve\n     */\n    function _validateProof(Proof memory proof) internal pure {\n        if (!_isOnCurveG1(proof.a)) {\n            revert InvalidCurvePoint(\"proof.a\");\n        }\n        if (!_isOnCurveG2(proof.b)) {\n            revert InvalidCurvePoint(\"proof.b\");\n        }\n        if (!_isOnCurveG1(proof.c)) {\n            revert InvalidCurvePoint(\"proof.c\");\n        }\n    }\n    \n    /**\n     * @dev Validate public inputs\n     */\n    function _validatePublicInputs(uint256[] memory publicInputs) internal pure {\n        // Field modulus for BN128\n        uint256 fieldModulus = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n        \n        for (uint256 i = 0; i < publicInputs.length; i++) {\n            if (publicInputs[i] >= fieldModulus) {\n                revert InvalidPublicInputs(\"Input exceeds field modulus\");\n            }\n        }\n    }\n    \n    // ========== BN128 Curve Operations ==========\n    \n    /**\n     * @dev Point addition on BN128 curve (G1)\n     * @param p1 First point\n     * @param p2 Second point\n     * @return result Sum of points\n     */\n    function _pointAdd(\n        uint256[2] memory p1,\n        uint256[2] memory p2\n    ) internal view returns (uint256[2] memory result) {\n        uint256[4] memory input;\n        input[0] = p1[0];\n        input[1] = p1[1];\n        input[2] = p2[0];\n        input[3] = p2[1];\n        \n        bool success;\n        assembly {\n            success := staticcall(sub(gas(), 2000), 0x06, input, 0x80, result, 0x40)\n        }\n        require(success, \"Point addition failed\");\n    }\n    \n    /**\n     * @dev Scalar multiplication on BN128 curve (G1)\n     * @param p Point to multiply\n     * @param s Scalar\n     * @return result Product point\n     */\n    function _scalarMul(\n        uint256[2] memory p,\n        uint256 s\n    ) internal view returns (uint256[2] memory result) {\n        uint256[3] memory input;\n        input[0] = p[0];\n        input[1] = p[1];\n        input[2] = s;\n        \n        bool success;\n        assembly {\n            success := staticcall(sub(gas(), 2000), 0x07, input, 0x60, result, 0x40)\n        }\n        require(success, \"Scalar multiplication failed\");\n    }\n    \n    /**\n     * @dev Pairing check using BN128 precompile\n     * @return bool True if pairing check passes\n     */\n    function _pairingCheck(\n        uint256[2] memory a1,\n        uint256[2][2] memory b1,\n        uint256[2] memory a2,\n        uint256[2][2] memory b2,\n        uint256[2] memory a3,\n        uint256[2][2] memory b3,\n        uint256[2] memory a4,\n        uint256[2][2] memory b4\n    ) internal view returns (bool) {\n        uint256[24] memory input;\n        \n        // First pair\n        input[0] = a1[0];\n        input[1] = a1[1];\n        input[2] = b1[0][0];\n        input[3] = b1[0][1];\n        input[4] = b1[1][0];\n        input[5] = b1[1][1];\n        \n        // Second pair (negated)\n        input[6] = a2[0];\n        input[7] = _negate(a2[1]);\n        input[8] = b2[0][0];\n        input[9] = b2[0][1];\n        input[10] = b2[1][0];\n        input[11] = b2[1][1];\n        \n        // Third pair (negated)\n        input[12] = a3[0];\n        input[13] = _negate(a3[1]);\n        input[14] = b3[0][0];\n        input[15] = b3[0][1];\n        input[16] = b3[1][0];\n        input[17] = b3[1][1];\n        \n        // Fourth pair (negated)\n        input[18] = a4[0];\n        input[19] = _negate(a4[1]);\n        input[20] = b4[0][0];\n        input[21] = b4[0][1];\n        input[22] = b4[1][0];\n        input[23] = b4[1][1];\n        \n        uint256[1] memory output;\n        bool success;\n        \n        assembly {\n            success := staticcall(sub(gas(), 2000), 0x08, input, 0x300, output, 0x20)\n        }\n        \n        require(success, \"Pairing check failed\");\n        return output[0] == 1;\n    }\n    \n    /**\n     * @dev Negate a field element\n     */\n    function _negate(uint256 y) internal pure returns (uint256) {\n        uint256 fieldModulus = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n        return (fieldModulus - (y % fieldModulus)) % fieldModulus;\n    }\n    \n    // ========== Curve Validation ==========\n    \n    /**\n     * @dev Check if point is on BN128 curve (G1)\n     * Curve equation: y^2 = x^3 + 3\n     */\n    function _isOnCurveG1(uint256[2] memory point) internal pure returns (bool) {\n        uint256 fieldModulus = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n        \n        if (point[0] >= fieldModulus || point[1] >= fieldModulus) {\n            return false;\n        }\n        \n        // Point at infinity\n        if (point[0] == 0 && point[1] == 0) {\n            return true;\n        }\n        \n        uint256 lhs = mulmod(point[1], point[1], fieldModulus);\n        uint256 rhs = addmod(\n            mulmod(mulmod(point[0], point[0], fieldModulus), point[0], fieldModulus),\n            3,\n            fieldModulus\n        );\n        \n        return lhs == rhs;\n    }\n    \n    /**\n     * @dev Check if point is on BN128 curve (G2)\n     * @notice Simplified check - validates field elements are in range\n     * @dev Full G2 curve validation is complex due to twist curve properties\n     * This simplified check is sufficient for verification key validation\n     * as the verification key comes from a trusted setup ceremony\n     * For untrusted sources, additional validation should be performed off-chain\n     */\n    function _isOnCurveG2(uint256[2][2] memory point) internal pure returns (bool) {\n        uint256 fieldModulus = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n        \n        // Validate field elements are in range\n        for (uint256 i = 0; i < 2; i++) {\n            for (uint256 j = 0; j < 2; j++) {\n                if (point[i][j] >= fieldModulus) {\n                    return false;\n                }\n            }\n        }\n        \n        // Point at infinity\n        if (point[0][0] == 0 && point[0][1] == 0 && point[1][0] == 0 && point[1][1] == 0) {\n            return true;\n        }\n        \n        return true; // Simplified validation - assumes trusted verification key source\n    }\n    \n    // ========== View Functions ==========\n    \n    /**\n     * @notice Check if verification key is set\n     */\n    function isVerificationKeySet() external view returns (bool) {\n        return vk.isInitialized;\n    }\n    \n    /**\n     * @notice Get verification key components\n     */\n    function getVerificationKey() external view returns (\n        uint256[2] memory alpha,\n        uint256[2][2] memory beta,\n        uint256[2][2] memory gamma,\n        uint256[2][2] memory delta,\n        uint256 gammaABCLength\n    ) {\n        require(vk.isInitialized, \"Verification key not set\");\n        return (vk.alpha, vk.beta, vk.gamma, vk.delta, vk.gammaABC.length);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}
{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/IAccessControl.sol)\n\npragma solidity >=0.8.4;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155} from \"./IERC1155.sol\";\nimport {IERC1155MetadataURI} from \"./extensions/IERC1155MetadataURI.sol\";\nimport {ERC1155Utils} from \"./utils/ERC1155Utils.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {Arrays} from \"../../utils/Arrays.sol\";\nimport {IERC1155Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n */\nabstract contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI, IERC1155Errors {\n    using Arrays for uint256[];\n    using Arrays for address[];\n\n    mapping(uint256 id => mapping(address account => uint256)) private _balances;\n\n    mapping(address account => mapping(address operator => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the ERC].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256 /* id */) public view virtual returns (string memory) {\n        return _uri;\n    }\n\n    /// @inheritdoc IERC1155\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual returns (uint256[] memory) {\n        if (accounts.length != ids.length) {\n            revert ERC1155InvalidArrayLength(ids.length, accounts.length);\n        }\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));\n        }\n\n        return batchBalances;\n    }\n\n    /// @inheritdoc IERC1155\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /// @inheritdoc IERC1155\n    function isApprovedForAll(address account, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /// @inheritdoc IERC1155\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual {\n        address sender = _msgSender();\n        if (from != sender && !isApprovedForAll(from, sender)) {\n            revert ERC1155MissingApprovalForAll(sender, from);\n        }\n        _safeTransferFrom(from, to, id, value, data);\n    }\n\n    /// @inheritdoc IERC1155\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual {\n        address sender = _msgSender();\n        if (from != sender && !isApprovedForAll(from, sender)) {\n            revert ERC1155MissingApprovalForAll(sender, from);\n        }\n        _safeBatchTransferFrom(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from`\n     * (or `to`) is the zero address.\n     *\n     * Emits a {TransferSingle} event if the arrays contain one element, and {TransferBatch} otherwise.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement either {IERC1155Receiver-onERC1155Received}\n     *   or {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     *\n     * NOTE: The ERC-1155 acceptance check is not performed in this function. See {_updateWithAcceptanceCheck} instead.\n     */\n    function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual {\n        if (ids.length != values.length) {\n            revert ERC1155InvalidArrayLength(ids.length, values.length);\n        }\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids.unsafeMemoryAccess(i);\n            uint256 value = values.unsafeMemoryAccess(i);\n\n            if (from != address(0)) {\n                uint256 fromBalance = _balances[id][from];\n                if (fromBalance < value) {\n                    revert ERC1155InsufficientBalance(from, fromBalance, value, id);\n                }\n                unchecked {\n                    // Overflow not possible: value <= fromBalance\n                    _balances[id][from] = fromBalance - value;\n                }\n            }\n\n            if (to != address(0)) {\n                _balances[id][to] += value;\n            }\n        }\n\n        if (ids.length == 1) {\n            uint256 id = ids.unsafeMemoryAccess(0);\n            uint256 value = values.unsafeMemoryAccess(0);\n            emit TransferSingle(operator, from, to, id, value);\n        } else {\n            emit TransferBatch(operator, from, to, ids, values);\n        }\n    }\n\n    /**\n     * @dev Version of {_update} that performs the token acceptance check by calling\n     * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it\n     * contains code (eg. is a smart contract at the moment of execution).\n     *\n     * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any\n     * update to the contract state after this function would break the check-effect-interaction pattern. Consider\n     * overriding {_update} instead.\n     */\n    function _updateWithAcceptanceCheck(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal virtual {\n        _update(from, to, ids, values);\n        if (to != address(0)) {\n            address operator = _msgSender();\n            if (ids.length == 1) {\n                uint256 id = ids.unsafeMemoryAccess(0);\n                uint256 value = values.unsafeMemoryAccess(0);\n                ERC1155Utils.checkOnERC1155Received(operator, from, to, id, value, data);\n            } else {\n                ERC1155Utils.checkOnERC1155BatchReceived(operator, from, to, ids, values, data);\n            }\n        }\n    }\n\n    /**\n     * @dev Transfers a `value` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the ERC].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the values in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens of type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens of type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     */\n    function _burn(address from, uint256 id, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     * - `ids` and `values` must have the same length.\n     */\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC1155InvalidOperator(address(0));\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Creates an array in memory with only one value for each of the elements provided.\n     */\n    function _asSingletonArrays(\n        uint256 element1,\n        uint256 element2\n    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {\n        assembly (\"memory-safe\") {\n            // Load the free memory pointer\n            array1 := mload(0x40)\n            // Set array length to 1\n            mstore(array1, 1)\n            // Store the single element at the next word after the length (where content starts)\n            mstore(add(array1, 0x20), element1)\n\n            // Repeat for next array locating it right after the first array\n            array2 := add(array1, 0x40)\n            mstore(array2, 1)\n            mstore(add(array2, 0x20), element2)\n\n            // Update the free memory pointer by pointing after the second array\n            mstore(0x40, add(array2, 0x40))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC1155} from \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[ERC].\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC-1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC-1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/utils/ERC1155Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155Receiver} from \"../IERC1155Receiver.sol\";\nimport {IERC1155Errors} from \"../../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Library that provide common ERC-1155 utility functions.\n *\n * See https://eips.ethereum.org/EIPS/eip-1155[ERC-1155].\n *\n * _Available since v5.1._\n */\nlibrary ERC1155Utils {\n    /**\n     * @dev Performs an acceptance check for the provided `operator` by calling {IERC1155Receiver-onERC1155Received}\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\n     *\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\n     * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept\n     * the transfer.\n     */\n    function checkOnERC1155Received(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    // Tokens rejected\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-IERC1155Receiver implementer\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                } else {\n                    assembly (\"memory-safe\") {\n                        revert(add(reason, 0x20), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Performs a batch acceptance check for the provided `operator` by calling {IERC1155Receiver-onERC1155BatchReceived}\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\n     *\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\n     * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept\n     * the transfer.\n     */\n    function checkOnERC1155BatchReceived(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    // Tokens rejected\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-IERC1155Receiver implementer\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                } else {\n                    assembly (\"memory-safe\") {\n                        revert(add(reason, 0x20), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Arrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Arrays.sol)\n// This file was procedurally generated from scripts/generate/templates/Arrays.js.\n\npragma solidity ^0.8.20;\n\nimport {Comparators} from \"./Comparators.sol\";\nimport {SlotDerivation} from \"./SlotDerivation.sol\";\nimport {StorageSlot} from \"./StorageSlot.sol\";\nimport {Math} from \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    using SlotDerivation for bytes32;\n    using StorageSlot for bytes32;\n\n    /**\n     * @dev Sort an array of uint256 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        uint256[] memory array,\n        function(uint256, uint256) pure returns (bool) comp\n    ) internal pure returns (uint256[] memory) {\n        _quickSort(_begin(array), _end(array), comp);\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of uint256 in increasing order.\n     */\n    function sort(uint256[] memory array) internal pure returns (uint256[] memory) {\n        sort(array, Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of address (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        address[] memory array,\n        function(address, address) pure returns (bool) comp\n    ) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of address in increasing order.\n     */\n    function sort(address[] memory array) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of bytes32 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        bytes32[] memory array,\n        function(bytes32, bytes32) pure returns (bool) comp\n    ) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of bytes32 in increasing order.\n     */\n    function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Performs a quick sort of a segment of memory. The segment sorted starts at `begin` (inclusive), and stops\n     * at end (exclusive). Sorting follows the `comp` comparator.\n     *\n     * Invariant: `begin <= end`. This is the case when initially called by {sort} and is preserved in subcalls.\n     *\n     * IMPORTANT: Memory locations between `begin` and `end` are not validated/zeroed. This function should\n     * be used only if the limits are within a memory array.\n     */\n    function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private pure {\n        unchecked {\n            if (end - begin < 0x40) return;\n\n            // Use first element as pivot\n            uint256 pivot = _mload(begin);\n            // Position where the pivot should be at the end of the loop\n            uint256 pos = begin;\n\n            for (uint256 it = begin + 0x20; it < end; it += 0x20) {\n                if (comp(_mload(it), pivot)) {\n                    // If the value stored at the iterator's position comes before the pivot, we increment the\n                    // position of the pivot and move the value there.\n                    pos += 0x20;\n                    _swap(pos, it);\n                }\n            }\n\n            _swap(begin, pos); // Swap pivot into place\n            _quickSort(begin, pos, comp); // Sort the left side of the pivot\n            _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first element of `array`.\n     */\n    function _begin(uint256[] memory array) private pure returns (uint256 ptr) {\n        assembly (\"memory-safe\") {\n            ptr := add(array, 0x20)\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first memory word (32bytes) after `array`. This is the memory word\n     * that comes just after the last element of the array.\n     */\n    function _end(uint256[] memory array) private pure returns (uint256 ptr) {\n        unchecked {\n            return _begin(array) + array.length * 0x20;\n        }\n    }\n\n    /**\n     * @dev Load memory word (as a uint256) at location `ptr`.\n     */\n    function _mload(uint256 ptr) private pure returns (uint256 value) {\n        assembly {\n            value := mload(ptr)\n        }\n    }\n\n    /**\n     * @dev Swaps the elements memory location `ptr1` and `ptr2`.\n     */\n    function _swap(uint256 ptr1, uint256 ptr2) private pure {\n        assembly {\n            let value1 := mload(ptr1)\n            let value2 := mload(ptr2)\n            mstore(ptr1, value2)\n            mstore(ptr2, value1)\n        }\n    }\n\n    /// @dev Helper: low level cast address memory array to uint256 memory array\n    function _castToUint256Array(address[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 memory array to uint256 memory array\n    function _castToUint256Array(bytes32[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast address comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(address, address) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(bytes32, bytes32) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * NOTE: The `array` is expected to be sorted in ascending order, and to\n     * contain no repeated elements.\n     *\n     * IMPORTANT: Deprecated. This implementation behaves as {lowerBound} but lacks\n     * support for repeated elements in the array. The {lowerBound} function should\n     * be used instead.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value greater or equal than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/lower_bound[lower_bound].\n     */\n    function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value strictly greater than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/upper_bound[upper_bound].\n     */\n    function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {lowerBound}, but with an array in memory.\n     */\n    function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {upperBound}, but with an array in memory.\n     */\n    function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getUint256Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes[] storage arr, uint256 pos) internal pure returns (StorageSlot.BytesSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getBytesSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(string[] storage arr, uint256 pos) internal pure returns (StorageSlot.StringSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getStringSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(bytes[] memory arr, uint256 pos) internal pure returns (bytes memory res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(string[] memory arr, uint256 pos) internal pure returns (string memory res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(address[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(bytes32[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(uint256[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(bytes[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(string[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Comparators.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Comparators.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to compare values.\n *\n * _Available since v5.1._\n */\nlibrary Comparators {\n    function lt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a < b;\n    }\n\n    function gt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a > b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/SlotDerivation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/SlotDerivation.sol)\n// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots\n * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by\n * the solidity language / compiler.\n *\n * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].\n *\n * Example usage:\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using StorageSlot for bytes32;\n *     using SlotDerivation for bytes32;\n *\n *     // Declare a namespace\n *     string private constant _NAMESPACE = \"<namespace>\"; // eg. OpenZeppelin.Slot\n *\n *     function setValueInNamespace(uint256 key, address newValue) internal {\n *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;\n *     }\n *\n *     function getValueInNamespace(uint256 key) internal view returns (address) {\n *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {StorageSlot}.\n *\n * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking\n * upgrade safety will ignore the slots accessed through this library.\n *\n * _Available since v5.1._\n */\nlibrary SlotDerivation {\n    /**\n     * @dev Derive an ERC-7201 slot from a string (namespace).\n     */\n    function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))\n            slot := and(keccak256(0x00, 0x20), not(0xff))\n        }\n    }\n\n    /**\n     * @dev Add an offset to a slot to get the n-th element of a structure or an array.\n     */\n    function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {\n        unchecked {\n            return bytes32(uint256(slot) + pos);\n        }\n    }\n\n    /**\n     * @dev Derive the location of the first element in an array from the slot where the length is stored.\n     */\n    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, slot)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, and(key, shr(96, not(0))))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, iszero(iszero(key)))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\n        (1 << 0x08) | // backspace\n            (1 << 0x09) | // tab\n            (1 << 0x0a) | // newline\n            (1 << 0x0c) | // form feed\n            (1 << 0x0d) | // carriage return\n            (1 << 0x22) | // double quote\n            (1 << 0x5c); // backslash\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(add(buffer, 0x20), length)\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress-string} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\n     *\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\n     *\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\n     * characters that are not in this range, but other tooling may provide different results.\n     */\n    function escapeJSON(string memory input) internal pure returns (string memory) {\n        bytes memory buffer = bytes(input);\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\n        uint256 outputLength = 0;\n\n        for (uint256 i; i < buffer.length; ++i) {\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\n                output[outputLength++] = \"\\\\\";\n                if (char == 0x08) output[outputLength++] = \"b\";\n                else if (char == 0x09) output[outputLength++] = \"t\";\n                else if (char == 0x0a) output[outputLength++] = \"n\";\n                else if (char == 0x0c) output[outputLength++] = \"f\";\n                else if (char == 0x0d) output[outputLength++] = \"r\";\n                else if (char == 0x5c) output[outputLength++] = \"\\\\\";\n                else if (char == 0x22) {\n                    // solhint-disable-next-line quotes\n                    output[outputLength++] = '\"';\n                }\n            } else {\n                output[outputLength++] = char;\n            }\n        }\n        // write the actual length and deallocate unused memory\n        assembly (\"memory-safe\") {\n            mstore(output, outputLength)\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\n        }\n\n        return string(output);\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }\n}\n"
    },
    "contracts/access/MembershipPaymentManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\n/**\n * @title MembershipPaymentManager\n * @notice Manages ERC20 token payments for role-based access control memberships\n * @dev Supports multiple payment tokens with configurable pricing and routing\n * \n * Key Features:\n * - Multiple ERC20 payment methods\n * - Adjustable pricing per role/tier\n * - Payment routing to treasury/multiple recipients\n * - Admin functions for refunds and emergency recovery\n * - Events for complete audit trail\n */\ncontract MembershipPaymentManager is AccessControl, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n    \n    // ========== Role Definitions ==========\n    \n    bytes32 public constant PAYMENT_ADMIN_ROLE = keccak256(\"PAYMENT_ADMIN_ROLE\");\n    bytes32 public constant PRICING_ADMIN_ROLE = keccak256(\"PRICING_ADMIN_ROLE\");\n    bytes32 public constant TREASURY_ADMIN_ROLE = keccak256(\"TREASURY_ADMIN_ROLE\");\n    \n    // ========== Payment Configuration ==========\n    \n    struct PaymentToken {\n        address tokenAddress;\n        bool isActive;\n        uint8 decimals;\n        string symbol;\n    }\n    \n    struct RolePricing {\n        mapping(address => uint256) priceByToken; // token address => price\n        bool isActive;\n    }\n    \n    struct PaymentRouting {\n        address recipient;\n        uint256 basisPoints; // 10000 = 100%\n    }\n    \n    // Payment tokens (token address => PaymentToken info)\n    mapping(address => PaymentToken) public paymentTokens;\n    address[] public paymentTokenList;\n    \n    // Role pricing (role hash => RolePricing)\n    mapping(bytes32 => RolePricing) private rolePricing;\n    \n    // Payment routing (array of recipients and their share)\n    PaymentRouting[] public paymentRouting;\n    \n    // Treasury address (receives payments if no routing configured)\n    address public treasury;\n    \n    // ========== Payment Tracking ==========\n    \n    struct Payment {\n        address buyer;\n        bytes32 role;\n        address paymentToken;\n        uint256 amount;\n        uint256 timestamp;\n        uint8 tier; // 0 for non-tiered, 1-4 for tiers\n        bool isRefunded; // explicit refund flag\n    }\n    \n    // Payment tracking\n    mapping(bytes32 => Payment) public payments; // paymentId => Payment\n    mapping(address => bytes32[]) public userPayments; // user => paymentIds\n    uint256 public totalPaymentsCount;\n    \n    // Revenue tracking by token\n    mapping(address => uint256) public revenueByToken;\n    \n    // ========== Events ==========\n    \n    event PaymentTokenAdded(address indexed token, string symbol, uint8 decimals);\n    event PaymentTokenUpdated(address indexed token, bool isActive);\n    event PaymentTokenRemoved(address indexed token);\n    event RolePriceUpdated(bytes32 indexed role, address indexed token, uint256 price);\n    event PaymentProcessed(\n        bytes32 indexed paymentId,\n        address indexed buyer,\n        bytes32 indexed role,\n        address paymentToken,\n        uint256 amount,\n        uint8 tier\n    );\n    event PaymentRefunded(bytes32 indexed paymentId, address indexed buyer, uint256 amount);\n    event PaymentRoutingUpdated(address indexed recipient, uint256 basisPoints);\n    event PaymentRoutingCleared();\n    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n    event FundsWithdrawn(address indexed token, address indexed recipient, uint256 amount);\n    event EmergencyWithdrawal(address indexed token, address indexed recipient, uint256 amount);\n    \n    // ========== Constructor ==========\n    \n    constructor(address _treasury) {\n        require(_treasury != address(0), \"Invalid treasury address\");\n        \n        treasury = _treasury;\n        \n        // Grant deployer all admin roles\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(PAYMENT_ADMIN_ROLE, msg.sender);\n        _grantRole(PRICING_ADMIN_ROLE, msg.sender);\n        _grantRole(TREASURY_ADMIN_ROLE, msg.sender);\n        \n        // Set up role hierarchy\n        _setRoleAdmin(PAYMENT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\n        _setRoleAdmin(PRICING_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\n        _setRoleAdmin(TREASURY_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\n    }\n    \n    // ========== Payment Token Management ==========\n    \n    /**\n     * @notice Add a new payment token\n     * @param token Address of the ERC20 token\n     * @param symbol Token symbol for display\n     * @param decimals Token decimals\n     */\n    function addPaymentToken(\n        address token,\n        string memory symbol,\n        uint8 decimals\n    ) external onlyRole(PAYMENT_ADMIN_ROLE) {\n        require(token != address(0), \"Invalid token address\");\n        require(bytes(symbol).length > 0, \"Invalid token symbol\");\n        require(paymentTokens[token].tokenAddress == address(0), \"Token already exists\");\n        \n        paymentTokens[token] = PaymentToken({\n            tokenAddress: token,\n            isActive: true,\n            decimals: decimals,\n            symbol: symbol\n        });\n        \n        paymentTokenList.push(token);\n        \n        emit PaymentTokenAdded(token, symbol, decimals);\n    }\n    \n    /**\n     * @notice Update payment token active status\n     * @param token Address of the token\n     * @param isActive New active status\n     */\n    function setPaymentTokenActive(\n        address token,\n        bool isActive\n    ) external onlyRole(PAYMENT_ADMIN_ROLE) {\n        require(paymentTokens[token].tokenAddress != address(0), \"Token not found\");\n        \n        paymentTokens[token].isActive = isActive;\n        \n        emit PaymentTokenUpdated(token, isActive);\n    }\n    \n    /**\n     * @notice Remove a payment token (soft delete - mark as inactive)\n     * @param token Address of the token\n     */\n    function removePaymentToken(address token) external onlyRole(PAYMENT_ADMIN_ROLE) {\n        require(paymentTokens[token].tokenAddress != address(0), \"Token not found\");\n        \n        paymentTokens[token].isActive = false;\n        \n        emit PaymentTokenRemoved(token);\n    }\n    \n    // ========== Pricing Management ==========\n    \n    /**\n     * @notice Set price for a role in a specific token\n     * @param role Role identifier\n     * @param token Payment token address\n     * @param price Price in token's smallest unit\n     */\n    function setRolePrice(\n        bytes32 role,\n        address token,\n        uint256 price\n    ) external onlyRole(PRICING_ADMIN_ROLE) {\n        require(paymentTokens[token].isActive, \"Token not active\");\n        \n        rolePricing[role].priceByToken[token] = price;\n        rolePricing[role].isActive = true;\n        \n        emit RolePriceUpdated(role, token, price);\n    }\n    \n    /**\n     * @notice Set prices for a role in multiple tokens at once\n     * @param role Role identifier\n     * @param tokens Array of payment token addresses\n     * @param prices Array of prices in each token's smallest unit\n     */\n    function setRolePrices(\n        bytes32 role,\n        address[] calldata tokens,\n        uint256[] calldata prices\n    ) external onlyRole(PRICING_ADMIN_ROLE) {\n        require(tokens.length == prices.length, \"Arrays length mismatch\");\n        \n        // Validate all tokens before making any state changes\n        for (uint256 i = 0; i < tokens.length; i++) {\n            require(paymentTokens[tokens[i]].isActive, \"Token not active\");\n        }\n        \n        // All validations passed, now set prices\n        for (uint256 i = 0; i < tokens.length; i++) {\n            rolePricing[role].priceByToken[tokens[i]] = prices[i];\n            emit RolePriceUpdated(role, tokens[i], prices[i]);\n        }\n        \n        rolePricing[role].isActive = true;\n    }\n    \n    /**\n     * @notice Get price for a role in a specific token\n     * @param role Role identifier\n     * @param token Payment token address\n     * @return price Price in token's smallest unit\n     */\n    function getRolePrice(bytes32 role, address token) external view returns (uint256) {\n        return rolePricing[role].priceByToken[token];\n    }\n    \n    // ========== Payment Routing Management ==========\n    \n    /**\n     * @notice Set payment routing configuration\n     * @param recipients Array of recipient addresses\n     * @param basisPoints Array of basis points (10000 = 100%)\n     */\n    function setPaymentRouting(\n        address[] calldata recipients,\n        uint256[] calldata basisPoints\n    ) external onlyRole(TREASURY_ADMIN_ROLE) {\n        require(recipients.length == basisPoints.length, \"Arrays length mismatch\");\n        \n        // Clear existing routing\n        delete paymentRouting;\n        \n        uint256 totalBasisPoints = 0;\n        for (uint256 i = 0; i < recipients.length; i++) {\n            require(recipients[i] != address(0), \"Invalid recipient\");\n            \n            paymentRouting.push(PaymentRouting({\n                recipient: recipients[i],\n                basisPoints: basisPoints[i]\n            }));\n            \n            totalBasisPoints += basisPoints[i];\n            \n            emit PaymentRoutingUpdated(recipients[i], basisPoints[i]);\n        }\n        \n        require(totalBasisPoints == 10000, \"Basis points must sum to 10000\");\n    }\n    \n    /**\n     * @notice Clear payment routing (send all to treasury)\n     */\n    function clearPaymentRouting() external onlyRole(TREASURY_ADMIN_ROLE) {\n        delete paymentRouting;\n        emit PaymentRoutingCleared();\n    }\n    \n    /**\n     * @notice Update treasury address\n     * @param newTreasury New treasury address\n     */\n    function setTreasury(address newTreasury) external onlyRole(TREASURY_ADMIN_ROLE) {\n        require(newTreasury != address(0), \"Invalid treasury address\");\n        address oldTreasury = treasury;\n        treasury = newTreasury;\n        emit TreasuryUpdated(oldTreasury, newTreasury);\n    }\n    \n    // ========== Payment Processing ==========\n    \n    /**\n     * @notice Process payment for a role purchase\n     * @param payer Address that will transfer the tokens (usually msg.sender or contract holding tokens)\n     * @param buyer Address of the actual buyer (for tracking purposes)\n     * @param role Role identifier\n     * @param paymentToken Token used for payment\n     * @param amount Amount to pay\n     * @param tier Tier level (0 for non-tiered)\n     * @return paymentId Unique payment identifier\n     */\n    function processPayment(\n        address payer,\n        address buyer,\n        bytes32 role,\n        address paymentToken,\n        uint256 amount,\n        uint8 tier\n    ) external nonReentrant whenNotPaused returns (bytes32) {\n        require(payer != address(0), \"Invalid payer\");\n        require(buyer != address(0), \"Invalid buyer\");\n        // Security: Only allow msg.sender to pay, preventing arbitrary from in transferFrom\n        require(payer == msg.sender, \"Payer must be msg.sender\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(paymentTokens[paymentToken].isActive, \"Payment token not active\");\n        require(rolePricing[role].isActive, \"Role pricing not configured\");\n        \n        uint256 requiredAmount = rolePricing[role].priceByToken[paymentToken];\n        require(requiredAmount > 0, \"Price not set for this token\");\n        require(amount >= requiredAmount, \"Insufficient payment amount\");\n        \n        // Transfer tokens from payer to this contract\n        IERC20(paymentToken).safeTransferFrom(payer, address(this), amount);\n        \n        // Generate payment ID\n        bytes32 paymentId = keccak256(\n            abi.encodePacked(buyer, role, paymentToken, amount, block.timestamp, totalPaymentsCount)\n        );\n        \n        // Record payment\n        payments[paymentId] = Payment({\n            buyer: buyer,\n            role: role,\n            paymentToken: paymentToken,\n            amount: amount,\n            timestamp: block.timestamp,\n            tier: tier,\n            isRefunded: false\n        });\n        \n        userPayments[buyer].push(paymentId);\n        totalPaymentsCount++;\n        \n        // Route payment\n        _routePayment(paymentToken, amount);\n        \n        // Track revenue\n        revenueByToken[paymentToken] += amount;\n        \n        emit PaymentProcessed(paymentId, buyer, role, paymentToken, amount, tier);\n        \n        return paymentId;\n    }\n    \n    /**\n     * @notice Route payment to recipients or treasury\n     * @param token Payment token address\n     * @param amount Total amount to route\n     */\n    function _routePayment(address token, uint256 amount) internal {\n        if (paymentRouting.length == 0) {\n            // No routing configured, send to treasury\n            IERC20(token).safeTransfer(treasury, amount);\n        } else {\n            // Route according to configuration\n            uint256 totalDistributed = 0;\n            for (uint256 i = 0; i < paymentRouting.length; i++) {\n                uint256 share = (amount * paymentRouting[i].basisPoints) / 10000;\n                if (share > 0) {\n                    IERC20(token).safeTransfer(paymentRouting[i].recipient, share);\n                    totalDistributed += share;\n                }\n            }\n            \n            // Send any remainder due to rounding to the last recipient\n            uint256 remainder = amount - totalDistributed;\n            if (remainder > 0 && paymentRouting.length > 0) {\n                address lastRecipient = paymentRouting[paymentRouting.length - 1].recipient;\n                IERC20(token).safeTransfer(lastRecipient, remainder);\n            }\n        }\n    }\n    \n    // ========== Refund Management ==========\n    \n    /**\n     * @notice Refund a payment (admin function for dispute resolution)\n     * @param paymentId Payment to refund\n     */\n    function refundPayment(bytes32 paymentId) external onlyRole(PAYMENT_ADMIN_ROLE) nonReentrant {\n        Payment storage payment = payments[paymentId];\n        require(payment.buyer != address(0), \"Payment not found\");\n        require(!payment.isRefunded, \"Payment already refunded\");\n        \n        address buyer = payment.buyer;\n        address token = payment.paymentToken;\n        uint256 amount = payment.amount;\n        \n        // Mark as refunded\n        payment.isRefunded = true;\n        \n        // Reduce revenue tracking - this must never underflow\n        require(revenueByToken[token] >= amount, \"Revenue underflow on refund\");\n        revenueByToken[token] -= amount;\n        \n        // Transfer funds back to buyer\n        IERC20(token).safeTransfer(buyer, amount);\n        \n        emit PaymentRefunded(paymentId, buyer, amount);\n    }\n    \n    // ========== Treasury Management ==========\n    \n    /**\n     * @notice Withdraw accumulated funds to treasury\n     * @param token Token to withdraw\n     */\n    function withdrawToTreasury(address token) external onlyRole(TREASURY_ADMIN_ROLE) nonReentrant {\n        require(paymentTokens[token].tokenAddress != address(0), \"Token not configured\");\n        \n        uint256 balance = IERC20(token).balanceOf(address(this));\n        require(balance > 0, \"No balance to withdraw\");\n        \n        IERC20(token).safeTransfer(treasury, balance);\n        \n        emit FundsWithdrawn(token, treasury, balance);\n    }\n    \n    /**\n     * @notice Emergency withdrawal function (only DEFAULT_ADMIN)\n     * @param token Token to withdraw\n     * @param recipient Recipient address\n     * @param amount Amount to withdraw\n     */\n    function emergencyWithdraw(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) nonReentrant {\n        require(recipient != address(0), \"Invalid recipient\");\n        require(amount > 0, \"Amount must be > 0\");\n        \n        IERC20(token).safeTransfer(recipient, amount);\n        \n        emit EmergencyWithdrawal(token, recipient, amount);\n    }\n    \n    // ========== View Functions ==========\n    \n    /**\n     * @notice Get list of all payment tokens\n     * @return tokens Array of token addresses\n     */\n    function getPaymentTokens() external view returns (address[] memory) {\n        return paymentTokenList;\n    }\n    \n    /**\n     * @notice Get user's payment history\n     * @param user User address\n     * @return paymentIds Array of payment IDs\n     */\n    function getUserPayments(address user) external view returns (bytes32[] memory) {\n        return userPayments[user];\n    }\n    \n    /**\n     * @notice Get payment routing configuration\n     * @return recipients Array of recipient addresses\n     * @return basisPoints Array of basis points\n     */\n    function getPaymentRouting() external view returns (\n        address[] memory recipients,\n        uint256[] memory basisPoints\n    ) {\n        uint256 length = paymentRouting.length;\n        recipients = new address[](length);\n        basisPoints = new uint256[](length);\n        \n        for (uint256 i = 0; i < length; i++) {\n            recipients[i] = paymentRouting[i].recipient;\n            basisPoints[i] = paymentRouting[i].basisPoints;\n        }\n    }\n    \n    /**\n     * @notice Get contract balance for a token\n     * @param token Token address\n     * @return balance Token balance\n     */\n    function getBalance(address token) external view returns (uint256) {\n        return IERC20(token).balanceOf(address(this));\n    }\n    \n    // ========== Emergency Functions ==========\n    \n    /**\n     * @notice Pause contract\n     */\n    function pause() external onlyRole(PAYMENT_ADMIN_ROLE) {\n        _pause();\n    }\n    \n    /**\n     * @notice Unpause contract\n     */\n    function unpause() external onlyRole(PAYMENT_ADMIN_ROLE) {\n        _unpause();\n    }\n}\n"
    },
    "contracts/access/RoleManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./MembershipPaymentManager.sol\";\nimport \"../privacy/ZKKeyManager.sol\";\n\n// Custom errors for gas efficiency\nerror RMInvalidAddress();\nerror RMInvalidZKKey();\nerror RMNotPurchasable();\nerror RMNotPremium();\nerror RMNotActive();\nerror RMAtCapacity();\nerror RMAlreadyInitialized();\nerror RMInsufficientPayment();\nerror RMPaymentManagerNotSet();\nerror RMZKManagerNotSet();\nerror RMNoBalance();\nerror RMActionNotFound();\nerror RMAlreadyApproved();\nerror RMTimelockNotExpired();\nerror RMInsufficientApprovals();\nerror RMAlreadyExecuted();\nerror RMAlreadyCancelled();\nerror RMActionCancelled();\n\n/**\n * @title RoleManager\n * @notice Comprehensive role-based access control system with hierarchy, timelocks, and multisig support\n * @dev Implements enterprise-grade RBAC following principle of least privilege\n * \n * Role Hierarchy (highest to lowest):\n * 1. DEFAULT_ADMIN_ROLE - Contract owner, manages all roles\n * 2. CORE_SYSTEM_ADMIN_ROLE - Critical upgrades, high-threshold multisig\n * 3. OPERATIONS_ADMIN_ROLE - Day-to-day operations, medium-threshold multisig\n * 4. EMERGENCY_GUARDIAN_ROLE - Emergency pause/cancel, low-threshold multisig\n * 5. Function-specific roles (MARKET_MAKER_ROLE, CLEARPATH_USER_ROLE, TOKENMINT_ROLE)\n * 6. OVERSIGHT_COMMITTEE_ROLE - Independent verification body\n */\ncontract RoleManager is AccessControl, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    // Safe Singleton Factory address for deterministic deployments\n    address internal constant SAFE_SINGLETON_FACTORY = 0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7;\n\n    // Tracks whether role metadata has been initialized (for lazy init pattern)\n    bool internal _roleMetadataInitialized;\n    \n    // ========== Role Definitions ==========\n    \n    // Administrative Roles (Hierarchical)\n    bytes32 public constant CORE_SYSTEM_ADMIN_ROLE = keccak256(\"CORE_SYSTEM_ADMIN_ROLE\");\n    bytes32 public constant OPERATIONS_ADMIN_ROLE = keccak256(\"OPERATIONS_ADMIN_ROLE\");\n    bytes32 public constant EMERGENCY_GUARDIAN_ROLE = keccak256(\"EMERGENCY_GUARDIAN_ROLE\");\n    \n    // Function-Specific Roles (Granular Permissions)\n    bytes32 public constant MARKET_MAKER_ROLE = keccak256(\"MARKET_MAKER_ROLE\");\n    bytes32 public constant CLEARPATH_USER_ROLE = keccak256(\"CLEARPATH_USER_ROLE\");\n    bytes32 public constant TOKENMINT_ROLE = keccak256(\"TOKENMINT_ROLE\");\n    bytes32 public constant FRIEND_MARKET_ROLE = keccak256(\"FRIEND_MARKET_ROLE\");\n    \n    // Oversight & Verification\n    bytes32 public constant OVERSIGHT_COMMITTEE_ROLE = keccak256(\"OVERSIGHT_COMMITTEE_ROLE\");\n    \n    // ========== Payment Integration ==========\n    \n    MembershipPaymentManager public paymentManager;\n    \n    // ========== ZK Key Management ==========\n    \n    ZKKeyManager public zkKeyManager;\n    \n    // ========== Role Metadata ==========\n    \n    struct RoleMetadata {\n        string name;\n        string description;\n        uint256 minApprovals; // Minimum approvals required (multisig threshold)\n        uint256 timelockDelay; // Minimum delay before action execution (in seconds)\n        bool isPremium; // Whether this role requires payment\n        uint256 price; // Price in wei (if premium)\n        bool isActive; // Whether role assignments are currently active\n        uint256 maxMembers; // Maximum number of users with this role (0 = unlimited)\n        uint256 currentMembers; // Current number of users with this role\n    }\n    \n    mapping(bytes32 => RoleMetadata) public roleMetadata;\n    \n    // ========== Timelock Management ==========\n    \n    struct PendingAction {\n        bytes32 actionId;\n        bytes32 role;\n        address target;\n        bool isGrant; // true for grant, false for revoke\n        uint256 executeAfter;\n        uint256 approvalCount;\n        mapping(address => bool) approvals;\n        bool executed;\n        bool cancelled;\n    }\n    \n    mapping(bytes32 => PendingAction) public pendingActions;\n    bytes32[] public pendingActionIds;\n    \n    // ========== Role Purchase Management ==========\n    \n    struct RolePurchase {\n        address buyer;\n        bytes32 role;\n        uint256 timestamp;\n        uint256 price;\n        string zkPublicKey; // Optional ZK key for ClearPath users\n    }\n    \n    mapping(address => mapping(bytes32 => RolePurchase)) public purchases;\n    mapping(address => bytes32[]) public userPurchasedRoles;\n    \n    // ========== Events ==========\n    \n    event RoleMetadataUpdated(bytes32 indexed role, string name, uint256 minApprovals, uint256 timelockDelay);\n    event RolePurchased(address indexed buyer, bytes32 indexed role, uint256 price, uint256 timestamp);\n    event RolePurchasedWithToken(address indexed buyer, bytes32 indexed role, address indexed paymentToken, uint256 price, uint256 timestamp);\n    event ZKKeyRegistered(address indexed user, bytes32 indexed role, string zkPublicKey);\n    event ActionProposed(bytes32 indexed actionId, bytes32 indexed role, address indexed target, bool isGrant);\n    event ActionApproved(bytes32 indexed actionId, address indexed approver);\n    event ActionExecuted(bytes32 indexed actionId, bytes32 indexed role, address indexed target, bool isGrant);\n    event ActionCancelled(bytes32 indexed actionId, address indexed canceller);\n    event EmergencyPaused(address indexed guardian);\n    event EmergencyUnpaused(address indexed admin);\n    event PaymentManagerUpdated(address indexed oldManager, address indexed newManager);\n    event ZKKeyManagerUpdated(address indexed oldManager, address indexed newManager);\n    event ZKKeyRotated(address indexed user, string newZKPublicKey);\n    \n    // ========== Constructor ==========\n    \n    constructor() {\n        // Grant deployer the default admin role\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        \n        // Set up role hierarchy\n        _setRoleAdmin(CORE_SYSTEM_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\n        _setRoleAdmin(OPERATIONS_ADMIN_ROLE, CORE_SYSTEM_ADMIN_ROLE);\n        _setRoleAdmin(EMERGENCY_GUARDIAN_ROLE, OPERATIONS_ADMIN_ROLE);\n        _setRoleAdmin(MARKET_MAKER_ROLE, OPERATIONS_ADMIN_ROLE);\n        _setRoleAdmin(CLEARPATH_USER_ROLE, OPERATIONS_ADMIN_ROLE);\n        _setRoleAdmin(TOKENMINT_ROLE, OPERATIONS_ADMIN_ROLE);\n        _setRoleAdmin(FRIEND_MARKET_ROLE, OPERATIONS_ADMIN_ROLE);\n        _setRoleAdmin(OVERSIGHT_COMMITTEE_ROLE, DEFAULT_ADMIN_ROLE);\n        \n        // NOTE: Role metadata initialization removed from constructor to reduce\n        // deployment gas for deterministic (CREATE2) deployments on low-gas-limit chains.\n        // Call initializeRoleMetadata() after deployment.\n    }\n\n    /**\n     * @notice Initialize role metadata (lazy init for gas-constrained deployments)\n     * @dev Can only be called once by an admin. Should be called after deployment.\n     */\n    function initializeRoleMetadata() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_roleMetadataInitialized) revert RMAlreadyInitialized();\n        _roleMetadataInitialized = true;\n        _initializeRoleMetadata();\n    }\n    \n    // ========== Role Metadata Initialization ==========\n    \n    function _initializeRoleMetadata() internal {\n        // Core System Admin: High security, long timelock\n        roleMetadata[CORE_SYSTEM_ADMIN_ROLE] = RoleMetadata({\n            name: \"Core System Admin\",\n            description: \"Critical upgrades and system changes\",\n            minApprovals: 3, // High threshold\n            timelockDelay: 7 days, // Long delay for critical actions\n            isPremium: false,\n            price: 0,\n            isActive: true,\n            maxMembers: 5, // Limited to small group\n            currentMembers: 0\n        });\n        \n        // Operations Admin: Medium security, medium timelock\n        roleMetadata[OPERATIONS_ADMIN_ROLE] = RoleMetadata({\n            name: \"Operations Admin\",\n            description: \"Day-to-day operations and configurations\",\n            minApprovals: 2, // Medium threshold\n            timelockDelay: 2 days,\n            isPremium: false,\n            price: 0,\n            isActive: true,\n            maxMembers: 10,\n            currentMembers: 0\n        });\n        \n        // Emergency Guardian: Low threshold, short timelock (rapid response)\n        roleMetadata[EMERGENCY_GUARDIAN_ROLE] = RoleMetadata({\n            name: \"Emergency Guardian\",\n            description: \"Emergency pause and cancel capabilities\",\n            minApprovals: 1, // Low threshold for rapid response\n            timelockDelay: 1 hours, // Minimal delay\n            isPremium: false,\n            price: 0,\n            isActive: true,\n            maxMembers: 7,\n            currentMembers: 0\n        });\n        \n        // Market Maker: Premium, function-specific\n        roleMetadata[MARKET_MAKER_ROLE] = RoleMetadata({\n            name: \"Market Maker\",\n            description: \"Create and manage prediction markets\",\n            minApprovals: 1,\n            timelockDelay: 0, // No timelock for functional roles\n            isPremium: true,\n            price: 100 ether, // 100 tokens (adjust as needed)\n            isActive: true,\n            maxMembers: 0, // Unlimited\n            currentMembers: 0\n        });\n        \n        // ClearPath User: Premium, function-specific\n        roleMetadata[CLEARPATH_USER_ROLE] = RoleMetadata({\n            name: \"ClearPath User\",\n            description: \"Access to DAO governance platform\",\n            minApprovals: 1,\n            timelockDelay: 0,\n            isPremium: true,\n            price: 250 ether, // 250 tokens\n            isActive: true,\n            maxMembers: 0, // Unlimited\n            currentMembers: 0\n        });\n        \n        // Token Mint: Premium, function-specific\n        roleMetadata[TOKENMINT_ROLE] = RoleMetadata({\n            name: \"Token Mint\",\n            description: \"Mint and manage NFTs and ERC20 tokens\",\n            minApprovals: 1,\n            timelockDelay: 0,\n            isPremium: true,\n            price: 150 ether, // 150 tokens\n            isActive: true,\n            maxMembers: 0, // Unlimited\n            currentMembers: 0\n        });\n        \n        // Friend Market: Premium, function-specific\n        roleMetadata[FRIEND_MARKET_ROLE] = RoleMetadata({\n            name: \"Friend Market Creator\",\n            description: \"Create small-scale friend group prediction markets\",\n            minApprovals: 1,\n            timelockDelay: 0,\n            isPremium: true,\n            price: 50 ether, // 50 tokens (base price, tiers managed by TieredRoleManager)\n            isActive: true,\n            maxMembers: 0, // Unlimited\n            currentMembers: 0\n        });\n        \n        // Oversight Committee: Independent verification\n        roleMetadata[OVERSIGHT_COMMITTEE_ROLE] = RoleMetadata({\n            name: \"Oversight Committee\",\n            description: \"Independent verification and approval\",\n            minApprovals: 2,\n            timelockDelay: 1 days,\n            isPremium: false,\n            price: 0,\n            isActive: true,\n            maxMembers: 7,\n            currentMembers: 0\n        });\n    }\n    \n    // ========== Role Purchase Functions ==========\n    \n    /**\n     * @notice Purchase a premium role with ETH (legacy method)\n     * @param role The role to purchase\n     */\n    function purchaseRole(bytes32 role) external payable nonReentrant whenNotPaused {\n        RoleMetadata storage metadata = roleMetadata[role];\n        \n        if (!metadata.isActive) revert RMNotActive();\n        if (!metadata.isPremium) revert RMNotPurchasable();\n        if (msg.value < metadata.price) revert RMInsufficientPayment();\n        if (hasRole(role, msg.sender)) revert RMAlreadyApproved();\n        if (metadata.maxMembers != 0 && metadata.currentMembers >= metadata.maxMembers) revert RMAtCapacity();\n        \n        // Record purchase\n        purchases[msg.sender][role] = RolePurchase({\n            buyer: msg.sender,\n            role: role,\n            timestamp: block.timestamp,\n            price: msg.value,\n            zkPublicKey: \"\" // Can be set later via registerZKKey\n        });\n        \n        userPurchasedRoles[msg.sender].push(role);\n        \n        // Grant role immediately (no timelock for purchases)\n        _grantRole(role, msg.sender);\n        metadata.currentMembers++;\n        \n        emit RolePurchased(msg.sender, role, msg.value, block.timestamp);\n        \n        // Refund excess payment\n        if (msg.value > metadata.price) {\n            payable(msg.sender).transfer(msg.value - metadata.price);\n        }\n    }\n    \n    /**\n     * @notice Purchase a premium role with ERC20 token\n     * @param role The role to purchase\n     * @param paymentToken The ERC20 token to use for payment\n     * @param amount The amount of tokens to pay\n     */\n    function purchaseRoleWithToken(\n        bytes32 role,\n        address paymentToken,\n        uint256 amount\n    ) external nonReentrant whenNotPaused {\n        if (address(paymentManager) == address(0)) revert RMPaymentManagerNotSet();\n        \n        RoleMetadata storage metadata = roleMetadata[role];\n        \n        if (!metadata.isActive) revert RMNotActive();\n        if (!metadata.isPremium) revert RMNotPurchasable();\n        if (hasRole(role, msg.sender)) revert RMAlreadyApproved();\n        if (metadata.maxMembers != 0 && metadata.currentMembers >= metadata.maxMembers) revert RMAtCapacity();\n        \n        // Transfer tokens from buyer to this contract\n        IERC20(paymentToken).safeTransferFrom(msg.sender, address(this), amount);\n        \n        // Approve payment manager to transfer tokens from this contract\n        IERC20(paymentToken).safeIncreaseAllowance(address(paymentManager), amount);\n        \n        // Process payment through payment manager (payment manager will transfer from this contract)\n        bytes32 paymentId = paymentManager.processPayment(\n            address(this), // payer is this contract (we already have the tokens)\n            msg.sender,    // buyer is the actual user\n            role,\n            paymentToken,\n            amount,\n            0 // tier 0 for non-tiered purchases\n        );\n        \n        // Record purchase\n        purchases[msg.sender][role] = RolePurchase({\n            buyer: msg.sender,\n            role: role,\n            timestamp: block.timestamp,\n            price: amount,\n            zkPublicKey: \"\" // Can be set later via registerZKKey\n        });\n        \n        userPurchasedRoles[msg.sender].push(role);\n        \n        // Grant role immediately (no timelock for purchases)\n        _grantRole(role, msg.sender);\n        metadata.currentMembers++;\n        \n        emit RolePurchasedWithToken(msg.sender, role, paymentToken, amount, block.timestamp);\n    }\n    \n    /**\n     * @notice Register ZK public key for ClearPath users\n     * @param zkPublicKey The zero-knowledge public key\n     */\n    function registerZKKey(string memory zkPublicKey) external whenNotPaused {\n        if (!hasRole(CLEARPATH_USER_ROLE, msg.sender)) revert RMNotActive();\n        if (bytes(zkPublicKey).length == 0) revert RMInvalidZKKey();\n        \n        // If ZKKeyManager is set, use production key management\n        if (address(zkKeyManager) != address(0)) {\n            // Register key with ZKKeyManager for production verification\n            zkKeyManager.registerKeyFor(msg.sender, zkPublicKey);\n        }\n        \n        // Store in local purchases mapping for backward compatibility\n        purchases[msg.sender][CLEARPATH_USER_ROLE].zkPublicKey = zkPublicKey;\n        \n        emit ZKKeyRegistered(msg.sender, CLEARPATH_USER_ROLE, zkPublicKey);\n    }\n    \n    /**\n     * @notice Rotate ZK public key to a new key\n     * @param newZKPublicKey The new zero-knowledge public key\n     */\n    function rotateZKKey(string memory newZKPublicKey) external whenNotPaused {\n        if (!hasRole(CLEARPATH_USER_ROLE, msg.sender)) revert RMNotActive();\n        if (bytes(newZKPublicKey).length == 0) revert RMInvalidZKKey();\n        if (address(zkKeyManager) == address(0)) revert RMZKManagerNotSet();\n        \n        // Rotate key using ZKKeyManager\n        zkKeyManager.rotateKeyFor(msg.sender, newZKPublicKey);\n        \n        // Update local purchases mapping\n        purchases[msg.sender][CLEARPATH_USER_ROLE].zkPublicKey = newZKPublicKey;\n        \n        emit ZKKeyRotated(msg.sender, newZKPublicKey);\n    }\n    \n    /**\n     * @notice Revoke ZK public key\n     */\n    function revokeZKKey() external whenNotPaused {\n        if (!hasRole(CLEARPATH_USER_ROLE, msg.sender)) revert RMNotActive();\n        if (address(zkKeyManager) == address(0)) revert RMZKManagerNotSet();\n        \n        // Revoke key using ZKKeyManager - pass msg.sender as the user\n        // Note: This works because ZKKeyManager allows key owner to revoke their own key\n        zkKeyManager.revokeKey(msg.sender);\n        \n        // Clear local purchases mapping\n        purchases[msg.sender][CLEARPATH_USER_ROLE].zkPublicKey = \"\";\n    }\n    \n    // ========== Timelock & Multisig Functions ==========\n    \n    /**\n     * @notice Propose a role grant/revoke action (subject to timelock and multisig)\n     * @param role The role to grant/revoke\n     * @param target The address to grant/revoke the role to/from\n     * @param isGrant True for grant, false for revoke\n     */\n    function proposeRoleAction(\n        bytes32 role,\n        address target,\n        bool isGrant\n    ) external onlyRole(getRoleAdmin(role)) whenNotPaused returns (bytes32) {\n        if (target == address(0)) revert RMInvalidAddress();\n        \n        RoleMetadata storage metadata = roleMetadata[role];\n        if (!metadata.isActive) revert RMNotActive();\n        \n        // Skip timelock for non-premium roles with no timelock delay\n        if (!metadata.isPremium && metadata.timelockDelay == 0) {\n            if (isGrant) {\n                _grantRole(role, target);\n                metadata.currentMembers++;\n            } else {\n                _revokeRole(role, target);\n                if (metadata.currentMembers > 0) metadata.currentMembers--;\n            }\n            return bytes32(0);\n        }\n        \n        // Generate unique action ID\n        bytes32 actionId = keccak256(abi.encodePacked(role, target, isGrant, block.timestamp));\n        \n        PendingAction storage action = pendingActions[actionId];\n        action.actionId = actionId;\n        action.role = role;\n        action.target = target;\n        action.isGrant = isGrant;\n        action.executeAfter = block.timestamp + metadata.timelockDelay;\n        action.approvalCount = 1; // Proposer's approval\n        action.approvals[msg.sender] = true;\n        \n        pendingActionIds.push(actionId);\n        \n        emit ActionProposed(actionId, role, target, isGrant);\n        emit ActionApproved(actionId, msg.sender);\n        \n        return actionId;\n    }\n    \n    /**\n     * @notice Approve a pending role action\n     * @param actionId The ID of the action to approve\n     */\n    function approveRoleAction(bytes32 actionId) external whenNotPaused {\n        PendingAction storage action = pendingActions[actionId];\n        \n        if (action.actionId == bytes32(0)) revert RMActionNotFound();\n        if (action.executed) revert RMAlreadyExecuted();\n        if (action.cancelled) revert RMActionCancelled();\n        if (action.approvals[msg.sender]) revert RMAlreadyApproved();\n        if (!hasRole(getRoleAdmin(action.role), msg.sender)) revert RMNotActive();\n        \n        action.approvals[msg.sender] = true;\n        action.approvalCount++;\n        \n        emit ActionApproved(actionId, msg.sender);\n    }\n    \n    /**\n     * @notice Execute a pending role action after timelock\n     * @param actionId The ID of the action to execute\n     */\n    function executeRoleAction(bytes32 actionId) external nonReentrant whenNotPaused {\n        PendingAction storage action = pendingActions[actionId];\n        \n        if (action.actionId == bytes32(0)) revert RMActionNotFound();\n        if (action.executed) revert RMAlreadyExecuted();\n        if (action.cancelled) revert RMActionCancelled();\n        if (block.timestamp < action.executeAfter) revert RMTimelockNotExpired();\n        \n        RoleMetadata storage metadata = roleMetadata[action.role];\n        if (action.approvalCount < metadata.minApprovals) revert RMInsufficientApprovals();\n        \n        action.executed = true;\n        \n        if (action.isGrant) {\n            _grantRole(action.role, action.target);\n            metadata.currentMembers++;\n        } else {\n            _revokeRole(action.role, action.target);\n            if (metadata.currentMembers > 0) metadata.currentMembers--;\n        }\n        \n        emit ActionExecuted(actionId, action.role, action.target, action.isGrant);\n    }\n    \n    /**\n     * @notice Cancel a pending action (Emergency Guardian only)\n     * @param actionId The ID of the action to cancel\n     */\n    function cancelRoleAction(bytes32 actionId) external onlyRole(EMERGENCY_GUARDIAN_ROLE) {\n        PendingAction storage action = pendingActions[actionId];\n        \n        if (action.actionId == bytes32(0)) revert RMActionNotFound();\n        if (action.executed) revert RMAlreadyExecuted();\n        if (action.cancelled) revert RMAlreadyCancelled();\n        \n        action.cancelled = true;\n        \n        emit ActionCancelled(actionId, msg.sender);\n    }\n    \n    // ========== Emergency Functions ==========\n    \n    /**\n     * @notice Emergency pause (Guardian only)\n     */\n    function emergencyPause() external onlyRole(EMERGENCY_GUARDIAN_ROLE) {\n        _pause();\n        emit EmergencyPaused(msg.sender);\n    }\n    \n    /**\n     * @notice Unpause contract (Admin only)\n     */\n    function unpause() external onlyRole(OPERATIONS_ADMIN_ROLE) {\n        _unpause();\n        emit EmergencyUnpaused(msg.sender);\n    }\n    \n    // ========== Admin Functions ==========\n    \n    /**\n     * @notice Set the payment manager contract\n     * @param _paymentManager Address of MembershipPaymentManager contract\n     */\n    function setPaymentManager(address _paymentManager) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_paymentManager == address(0)) revert RMInvalidAddress();\n        address oldManager = address(paymentManager);\n        paymentManager = MembershipPaymentManager(_paymentManager);\n        emit PaymentManagerUpdated(oldManager, _paymentManager);\n    }\n    \n    /**\n     * @notice Set the ZK key manager contract\n     * @param _zkKeyManager Address of ZKKeyManager contract\n     */\n    function setZKKeyManager(address _zkKeyManager) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_zkKeyManager == address(0)) revert RMInvalidAddress();\n        address oldManager = address(zkKeyManager);\n        zkKeyManager = ZKKeyManager(_zkKeyManager);\n        emit ZKKeyManagerUpdated(oldManager, _zkKeyManager);\n    }\n    \n    /**\n     * @notice Update role metadata (Core System Admin only)\n     */\n    function updateRoleMetadata(\n        bytes32 role,\n        string memory name,\n        string memory description,\n        uint256 minApprovals,\n        uint256 timelockDelay,\n        uint256 maxMembers\n    ) external onlyRole(CORE_SYSTEM_ADMIN_ROLE) {\n        RoleMetadata storage metadata = roleMetadata[role];\n        \n        metadata.name = name;\n        metadata.description = description;\n        metadata.minApprovals = minApprovals;\n        metadata.timelockDelay = timelockDelay;\n        metadata.maxMembers = maxMembers;\n        \n        emit RoleMetadataUpdated(role, name, minApprovals, timelockDelay);\n    }\n    \n    /**\n     * @notice Set role price (Operations Admin only)\n     */\n    function setRolePrice(bytes32 role, uint256 price) external onlyRole(OPERATIONS_ADMIN_ROLE) {\n        if (!roleMetadata[role].isPremium) revert RMNotPremium();\n        roleMetadata[role].price = price;\n    }\n    \n    /**\n     * @notice Toggle role active status (Operations Admin only)\n     */\n    function setRoleActive(bytes32 role, bool isActive) external onlyRole(OPERATIONS_ADMIN_ROLE) {\n        roleMetadata[role].isActive = isActive;\n    }\n    \n    /**\n     * @notice Withdraw contract balance (Operations Admin only)\n     */\n    function withdraw() external onlyRole(OPERATIONS_ADMIN_ROLE) nonReentrant {\n        uint256 balance = address(this).balance;\n        if (balance == 0) revert RMNoBalance();\n        payable(msg.sender).transfer(balance);\n    }\n    \n    // ========== Override AccessControl Functions to Enforce Governance ==========\n    \n    /**\n     * @notice Override grantRole to enforce timelock/multisig governance\n     * @dev Only allows direct grants for premium roles via purchaseRole or internal grants via executeRoleAction\n     */\n    function grantRole(bytes32 role, address account) public virtual override {\n        // Only allow direct grants in specific scenarios:\n        // 1. During contract initialization (for setting up initial admin hierarchy)\n        // 2. For premium roles purchased via purchaseRole (checked by msg.sender == this)\n        // 3. For roles with no timelock delay (executed immediately in proposeRoleAction)\n        // 4. Role admin can directly grant roles for initial setup (to simplify testing and initial deployment)\n        \n        RoleMetadata storage metadata = roleMetadata[role];\n        \n        // Allow if called internally (from purchaseRole or executeRoleAction)\n        if (msg.sender == address(this)) {\n            super.grantRole(role, account);\n            return;\n        }\n        \n        // Allow role admin to grant for initial setup and testing\n        if (hasRole(getRoleAdmin(role), msg.sender)) {\n            super.grantRole(role, account);\n            return;\n        }\n        \n        // For premium roles, users must use purchaseRole\n        if (metadata.isPremium) {\n            revert(\"Premium roles must be purchased via purchaseRole\");\n        }\n        \n        // Otherwise reject\n        revert(\"Must have role admin permission or use governance flow\");\n    }\n    \n    /**\n     * @notice Override revokeRole to maintain consistency with grantRole\n     * @dev Allows direct revocations by role admin or internal calls\n     */\n    function revokeRole(bytes32 role, address account) public virtual override {\n        // Allow if called internally (from executeRoleAction)\n        if (msg.sender == address(this)) {\n            super.revokeRole(role, account);\n            return;\n        }\n        \n        // Allow role admin to revoke\n        if (hasRole(getRoleAdmin(role), msg.sender)) {\n            super.revokeRole(role, account);\n            return;\n        }\n        \n        // Otherwise reject\n        revert(\"Must have role admin permission\");\n    }\n    \n    /**\n     * @notice Internal function to grant role (bypasses checks)\n     * @dev Used by executeRoleAction and purchaseRole\n     */\n    function _internalGrantRole(bytes32 role, address account) internal {\n        super.grantRole(role, account);\n    }\n    \n    /**\n     * @notice Internal function to revoke role (bypasses checks)\n     * @dev Used by executeRoleAction\n     */\n    function _internalRevokeRole(bytes32 role, address account) internal {\n        super.revokeRole(role, account);\n    }\n    \n    // ========== View Functions ==========\n    \n    /**\n     * @notice Get role metadata\n     */\n    function getRoleMetadata(bytes32 role) external view returns (RoleMetadata memory) {\n        return roleMetadata[role];\n    }\n    \n    /**\n     * @notice Get user's purchased roles\n     */\n    function getUserPurchasedRoles(address user) external view returns (bytes32[] memory) {\n        return userPurchasedRoles[user];\n    }\n    \n    /**\n     * @notice Get ZK public key for user\n     */\n    function getZKPublicKey(address user) external view returns (string memory) {\n        // If ZKKeyManager is set, get key from there\n        if (address(zkKeyManager) != address(0)) {\n            return zkKeyManager.getPublicKey(user);\n        }\n        // Otherwise fall back to local storage\n        return purchases[user][CLEARPATH_USER_ROLE].zkPublicKey;\n    }\n    \n    /**\n     * @notice Check if user has a valid ZK key\n     */\n    function hasValidZKKey(address user) external view returns (bool) {\n        if (address(zkKeyManager) != address(0)) {\n            return zkKeyManager.hasValidKey(user);\n        }\n        // Fall back to checking local storage\n        return bytes(purchases[user][CLEARPATH_USER_ROLE].zkPublicKey).length > 0;\n    }\n    \n    /**\n     * @notice Get pending action count\n     */\n    function getPendingActionCount() external view returns (uint256) {\n        return pendingActionIds.length;\n    }\n    \n    /**\n     * @notice Check if action is approved by address\n     */\n    function isActionApprovedBy(bytes32 actionId, address approver) external view returns (bool) {\n        return pendingActions[actionId].approvals[approver];\n    }\n}\n"
    },
    "contracts/access/TieredRoleManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"./RoleManager.sol\";\nimport \"../libraries/TierTypes.sol\";\n\nerror TRMAlreadyInit();\nerror TRMInvalidAdmin();\nerror TRMInvalidTier();\nerror TRMTierNotActive();\nerror TRMNotPurchasable();\nerror TRMAtCapacity();\nerror TRMInsufficientPay();\nerror TRMNoMembership();\nerror TRMAlreadyHasRole();\nerror TRMNeedHigherTier();\nerror TRMMustHaveRole();\nerror TRMNoTierFound();\n\n/**\n * @title TieredRoleManager\n * @notice Tiered membership system with Bronze/Silver/Gold/Platinum levels\n */\ncontract TieredRoleManager is RoleManager {\n\n    bool private _initialized;\n\n    mapping(bytes32 => mapping(MembershipTier => TierMetadata)) public tierMetadata;\n    mapping(address => mapping(bytes32 => MembershipTier)) public userTiers;\n    mapping(address => mapping(bytes32 => uint256)) public tierPurchases;\n    mapping(address => mapping(bytes32 => uint256)) public membershipExpiration;\n    mapping(address => mapping(bytes32 => UsageStats)) public usageStats;\n\n    // Authorized extensions that can grant roles (e.g., PaymentProcessor)\n    mapping(address => bool) public authorizedExtensions;\n\n    event TierPurchased(address indexed user, bytes32 indexed role, MembershipTier tier, uint256 price);\n    event TierUpgraded(address indexed user, bytes32 indexed role, MembershipTier from, MembershipTier to);\n    event MembershipExtended(address indexed user, bytes32 indexed role, uint256 exp);\n\n    constructor() RoleManager() { _initialized = msg.sender != SAFE_SINGLETON_FACTORY; }\n\n    function initialize(address admin) external {\n        if (_initialized) revert TRMAlreadyInit();\n        if (admin == address(0)) revert TRMInvalidAdmin();\n        _initialized = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _revokeRole(DEFAULT_ADMIN_ROLE, SAFE_SINGLETON_FACTORY);\n    }\n\n    // Admin\n    function setTierMetadata(bytes32 r, MembershipTier t, string calldata n, string calldata d, uint256 p, TierLimits calldata l, bool a) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        tierMetadata[r][t] = TierMetadata(n, d, p, l, a);\n    }\n\n    function setTierActive(bytes32 r, MembershipTier t, bool a) external onlyRole(DEFAULT_ADMIN_ROLE) { tierMetadata[r][t].isActive = a; }\n\n    function setAuthorizedExtension(address ext, bool authorized) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        authorizedExtensions[ext] = authorized;\n    }\n\n    // Called by PaymentProcessor to grant roles after payment\n    function grantRoleFromExtension(bytes32 role, address account) external {\n        require(authorizedExtensions[msg.sender], \"Not authorized extension\");\n        if (!hasRole(role, account)) {\n            _grantRole(role, account);\n            roleMetadata[role].currentMembers++;\n        }\n    }\n\n    // Called by PaymentProcessor to grant role with tier after payment\n    function grantTierFromExtension(\n        bytes32 role,\n        address account,\n        uint8 tier,\n        uint256 durationDays\n    ) external {\n        require(authorizedExtensions[msg.sender], \"Not authorized extension\");\n        require(tier > 0 && tier <= 4, \"Invalid tier\");\n\n        MembershipTier membershipTier = MembershipTier(tier);\n        MembershipTier currentTier = userTiers[account][role];\n\n        // Set tier\n        userTiers[account][role] = membershipTier;\n        tierPurchases[account][role] = block.timestamp;\n\n        // For new members, initialize membership expiration and usage stats\n        // For existing members (upgrades), preserve usage stats and extend from current expiration\n        if (currentTier == MembershipTier.NONE) {\n            membershipExpiration[account][role] = block.timestamp + durationDays * 1 days;\n            usageStats[account][role] = UsageStats(0, 0, 0, 0, 0, block.timestamp, block.timestamp, block.timestamp);\n        } else {\n            // Upgrade: extend from current expiration if still active, otherwise from now\n            uint256 start = membershipExpiration[account][role] > block.timestamp\n                ? membershipExpiration[account][role]\n                : block.timestamp;\n            membershipExpiration[account][role] = start + durationDays * 1 days;\n            // Keep existing usage stats for upgrades\n        }\n\n        // Grant role if not already granted\n        if (!hasRole(role, account)) {\n            _grantRole(role, account);\n            roleMetadata[role].currentMembers++;\n        }\n\n        if (currentTier == MembershipTier.NONE) {\n            emit TierPurchased(account, role, membershipTier, 0);\n        } else {\n            emit TierUpgraded(account, role, currentTier, membershipTier);\n        }\n    }\n\n    // Purchase\n    function purchaseRoleWithTier(bytes32 role, MembershipTier tier, uint256 durDays) external payable nonReentrant whenNotPaused {\n        if (tier == MembershipTier.NONE) revert TRMInvalidTier();\n        if (userTiers[msg.sender][role] != MembershipTier.NONE) revert TRMAlreadyHasRole();\n\n        TierMetadata storage m = tierMetadata[role][tier];\n        if (!m.isActive) revert TRMTierNotActive();\n        if (msg.value < m.price) revert TRMInsufficientPay();\n\n        RoleMetadata storage rm = roleMetadata[role];\n        if (!rm.isPremium) revert TRMNotPurchasable();\n        if (rm.maxMembers != 0 && rm.currentMembers >= rm.maxMembers) revert TRMAtCapacity();\n\n        _grantRole(role, msg.sender);\n        userTiers[msg.sender][role] = tier;\n        tierPurchases[msg.sender][role] = block.timestamp;\n        rm.currentMembers++;\n        membershipExpiration[msg.sender][role] = block.timestamp + durDays * 1 days;\n        usageStats[msg.sender][role] = UsageStats(0, 0, 0, 0, 0, block.timestamp, block.timestamp, block.timestamp);\n\n        emit TierPurchased(msg.sender, role, tier, msg.value);\n        if (msg.value > m.price) payable(msg.sender).transfer(msg.value - m.price);\n    }\n\n    function upgradeTier(bytes32 role, MembershipTier newTier) external payable nonReentrant whenNotPaused {\n        MembershipTier cur = userTiers[msg.sender][role];\n        if (cur == MembershipTier.NONE) revert TRMMustHaveRole();\n        if (newTier <= cur) revert TRMNeedHigherTier();\n\n        TierMetadata storage m = tierMetadata[role][newTier];\n        if (!m.isActive) revert TRMTierNotActive();\n        if (msg.value < m.price) revert TRMInsufficientPay();\n\n        userTiers[msg.sender][role] = newTier;\n        tierPurchases[msg.sender][role] = block.timestamp;\n\n        emit TierUpgraded(msg.sender, role, cur, newTier);\n        if (msg.value > m.price) payable(msg.sender).transfer(msg.value - m.price);\n    }\n\n    function extendMembership(bytes32 role, uint256 days_) external payable nonReentrant whenNotPaused {\n        if (userTiers[msg.sender][role] == MembershipTier.NONE) revert TRMNoMembership();\n        uint256 cost = tierMetadata[role][userTiers[msg.sender][role]].price / 2;\n        if (msg.value < cost) revert TRMInsufficientPay();\n\n        uint256 start = membershipExpiration[msg.sender][role] > block.timestamp ? membershipExpiration[msg.sender][role] : block.timestamp;\n        membershipExpiration[msg.sender][role] = start + days_ * 1 days;\n        emit MembershipExtended(msg.sender, role, membershipExpiration[msg.sender][role]);\n        if (msg.value > cost) payable(msg.sender).transfer(msg.value - cost);\n    }\n\n    // Usage - checkMarketCreationLimit is the critical one for FriendGroupMarketFactory\n    function _reset(address u, bytes32 r) internal {\n        UsageStats storage s = usageStats[u][r];\n        if (block.timestamp >= s.lastDailyReset + 1 days) { s.dailyBetsCount = 0; s.dailyWithdrawals = 0; s.lastDailyReset = block.timestamp; }\n        if (block.timestamp >= s.lastWeeklyReset + 7 days) { s.weeklyBetsCount = 0; s.lastWeeklyReset = block.timestamp; }\n        if (block.timestamp >= s.lastMonthlyReset + 30 days) { s.monthlyMarketsCreated = 0; s.lastMonthlyReset = block.timestamp; }\n    }\n\n    function checkMarketCreationLimit(bytes32 r) external returns (bool) { return checkMarketCreationLimitFor(msg.sender, r); }\n\n    function checkMarketCreationLimitFor(address u, bytes32 r) public returns (bool) {\n        _reset(u, r);\n        MembershipTier t = userTiers[u][r];\n        if (t == MembershipTier.NONE) revert TRMNoTierFound();\n        TierLimits storage l = tierMetadata[r][t].limits;\n        UsageStats storage s = usageStats[u][r];\n        if (s.monthlyMarketsCreated >= l.monthlyMarketCreation || s.activeMarketsCount >= l.maxConcurrentMarkets) return false;\n        s.monthlyMarketsCreated++; s.activeMarketsCount++;\n        return true;\n    }\n\n    function recordMarketClosure(bytes32 r) external { if (usageStats[msg.sender][r].activeMarketsCount > 0) usageStats[msg.sender][r].activeMarketsCount--; }\n\n    // Admin\n    function grantTier(address u, bytes32 r, MembershipTier t, uint256 days_) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        userTiers[u][r] = t;\n        tierPurchases[u][r] = block.timestamp;\n        membershipExpiration[u][r] = block.timestamp + days_ * 1 days;\n        usageStats[u][r] = UsageStats(0, 0, 0, 0, 0, block.timestamp, block.timestamp, block.timestamp);\n        if (!hasRole(r, u)) { _grantRole(r, u); roleMetadata[r].currentMembers++; }\n        emit TierPurchased(u, r, t, 0);\n    }\n\n    function withdrawFunds(address payable to, uint256 amt) external onlyRole(DEFAULT_ADMIN_ROLE) { to.transfer(amt); }\n\n    // View\n    function getUserTier(address u, bytes32 r) external view returns (MembershipTier) {\n        if (membershipExpiration[u][r] > 0 && block.timestamp > membershipExpiration[u][r]) return MembershipTier.NONE;\n        return userTiers[u][r];\n    }\n    function isMembershipActive(address u, bytes32 r) external view returns (bool) { return block.timestamp < membershipExpiration[u][r]; }\n}\n"
    },
    "contracts/integrations/ETCSwapV3Integration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../interfaces/uniswap-v3/IUniswapV3Factory.sol\";\nimport \"../interfaces/uniswap-v3/IUniswapV3Pool.sol\";\nimport \"../interfaces/uniswap-v3/ISwapRouter.sol\";\nimport \"../interfaces/uniswap-v3/INonfungiblePositionManager.sol\";\nimport \"../access/TieredRoleManager.sol\";\n\n/**\n * @title ETCSwapV3Integration\n * @notice Production-ready integration with ETCSwap v3 with role-based liquidity management\n * @dev Handles pool creation, liquidity management, and trading for conditional tokens\n * \n * This contract provides a comprehensive interface to ETCSwap v3 (Uniswap v3 fork):\n * - Pool creation and initialization for PASS/FAIL tokens\n * - Liquidity provision and management\n * - Token swapping with slippage protection\n * - Emergency controls and safety mechanisms\n * - Events for off-chain tracking and analytics\n * \n * RBAC INTEGRATION:\n * - Pool creation requires MARKET_MAKER_ROLE\n * - Admin functions require OPERATIONS_ADMIN_ROLE\n * \n * Based on: https://github.com/etcswap/v3-sdk\n * Reference: https://docs.uniswap.org/contracts/v3/overview\n */\ncontract ETCSwapV3Integration is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // ============ State Variables ============\n\n    /// @notice ETCSwap v3 Factory contract\n    IUniswapV3Factory public immutable factory;\n\n    /// @notice ETCSwap v3 SwapRouter contract\n    ISwapRouter public immutable swapRouter;\n\n    /// @notice ETCSwap v3 NonfungiblePositionManager contract\n    INonfungiblePositionManager public immutable positionManager;\n\n    /// @notice Default fee tier (0.3% = 3000)\n    uint24 public constant DEFAULT_FEE = 3000;\n\n    /// @notice Low fee tier (0.05% = 500) for stable pairs\n    uint24 public constant LOW_FEE = 500;\n\n    /// @notice High fee tier (1% = 10000) for volatile pairs\n    uint24 public constant HIGH_FEE = 10000;\n\n    /// @notice Default slippage tolerance in basis points (50 = 0.5%)\n    uint256 public defaultSlippageBps = 50;\n\n    /// @notice Maximum allowed slippage in basis points (1000 = 10%)\n    uint256 public constant MAX_SLIPPAGE_BPS = 1000;\n\n    /// @notice Minimum sqrt price limit for swaps\n    uint160 public constant MIN_SQRT_RATIO = 4295128739;\n\n    /// @notice Maximum sqrt price limit for swaps\n    uint160 public constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Mapping of market ID to pool configuration\n    mapping(uint256 => PoolConfig) public marketPools;\n\n    /// @notice Mapping of market ID to liquidity position NFT token ID\n    mapping(uint256 => uint256) public marketPositions;\n\n    /// @notice Paused state for emergency stops\n    bool public paused;\n    \n    // Role-based access control\n    TieredRoleManager public roleManager;\n\n    // ============ Structs ============\n\n    struct PoolConfig {\n        address passPool;      // Pool for PASS token / collateral\n        address failPool;      // Pool for FAIL token / collateral\n        uint24 fee;            // Fee tier for the pools\n        bool initialized;      // Whether pools have been created\n    }\n\n    struct SwapResult {\n        uint256 amountIn;\n        uint256 amountOut;\n        uint256 executionPrice; // Price with 18 decimals\n    }\n\n    // ============ Events ============\n\n    event PoolsCreated(\n        uint256 indexed marketId,\n        address indexed passPool,\n        address indexed failPool,\n        uint24 fee\n    );\n\n    event LiquidityAdded(\n        uint256 indexed marketId,\n        uint256 indexed positionId,\n        uint256 amount0,\n        uint256 amount1,\n        uint128 liquidity\n    );\n\n    event LiquidityRemoved(\n        uint256 indexed marketId,\n        uint256 indexed positionId,\n        uint256 amount0,\n        uint256 amount1,\n        uint128 liquidity\n    );\n\n    event TokensSwapped(\n        uint256 indexed marketId,\n        address indexed trader,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 executionPrice\n    );\n\n    event SlippageUpdated(uint256 oldSlippage, uint256 newSlippage);\n\n    event EmergencyPauseToggled(bool paused);\n\n    event FeesCollected(\n        uint256 indexed marketId,\n        uint256 indexed positionId,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    // ============ Errors ============\n\n    error ContractPaused();\n    error InvalidAddress();\n    error InvalidAmount();\n    error InvalidSlippage();\n    error PoolNotInitialized();\n    error PoolAlreadyExists();\n    error InsufficientOutput();\n    error ExcessiveInput();\n    error DeadlineExpired();\n    error InvalidFee();\n\n    // ============ Constructor ============\n\n    /**\n     * @notice Initialize the ETCSwap v3 integration\n     * @param _factory ETCSwap v3 Factory address\n     * @param _swapRouter ETCSwap v3 SwapRouter address\n     * @param _positionManager ETCSwap v3 NonfungiblePositionManager address\n     */\n    constructor(\n        address _factory,\n        address _swapRouter,\n        address _positionManager\n    ) Ownable(msg.sender) {\n        if (_factory == address(0) || _swapRouter == address(0) || _positionManager == address(0)) {\n            revert InvalidAddress();\n        }\n\n        factory = IUniswapV3Factory(_factory);\n        swapRouter = ISwapRouter(_swapRouter);\n        positionManager = INonfungiblePositionManager(_positionManager);\n    }\n    \n    /**\n     * @notice Set the role manager contract\n     * @param _roleManager Address of TieredRoleManager contract\n     */\n    function setRoleManager(address _roleManager) external onlyOwner {\n        require(_roleManager != address(0), \"Invalid role manager address\");\n        require(address(roleManager) == address(0), \"Role manager already set\");\n        roleManager = TieredRoleManager(_roleManager);\n    }\n\n    // ============ Modifiers ============\n\n    modifier whenNotPaused() {\n        if (paused) revert ContractPaused();\n        _;\n    }\n\n    // ============ Pool Management Functions ============\n\n    /**\n     * @notice Create ETCSwap v3 pools for a prediction market\n     * @dev Creates two pools: PASS/collateral and FAIL/collateral\n     * @param marketId Market identifier\n     * @param passToken Address of PASS conditional token\n     * @param failToken Address of FAIL conditional token\n     * @param collateralToken Address of collateral token\n     * @param fee Fee tier to use (500, 3000, or 10000)\n     * @param initialSqrtPriceX96 Initial price for both pools (Q64.96 format)\n     * @return passPool Address of created PASS pool\n     * @return failPool Address of created FAIL pool\n     */\n    function createMarketPools(\n        uint256 marketId,\n        address passToken,\n        address failToken,\n        address collateralToken,\n        uint24 fee,\n        uint160 initialSqrtPriceX96\n    ) external onlyOwner whenNotPaused returns (address passPool, address failPool) {\n        if (marketPools[marketId].initialized) revert PoolAlreadyExists();\n        if (passToken == address(0) || failToken == address(0) || collateralToken == address(0)) {\n            revert InvalidAddress();\n        }\n        if (fee != LOW_FEE && fee != DEFAULT_FEE && fee != HIGH_FEE) {\n            revert InvalidFee();\n        }\n\n        // Create PASS/collateral pool\n        passPool = _getOrCreatePool(passToken, collateralToken, fee);\n        _initializePoolIfNeeded(passPool, initialSqrtPriceX96);\n\n        // Create FAIL/collateral pool\n        failPool = _getOrCreatePool(failToken, collateralToken, fee);\n        _initializePoolIfNeeded(failPool, initialSqrtPriceX96);\n\n        // Store pool configuration\n        marketPools[marketId] = PoolConfig({\n            passPool: passPool,\n            failPool: failPool,\n            fee: fee,\n            initialized: true\n        });\n\n        emit PoolsCreated(marketId, passPool, failPool, fee);\n    }\n\n    /**\n     * @notice Add liquidity to market pools\n     * @dev Adds liquidity to both PASS and FAIL pools for a market\n     * @param marketId Market identifier\n     * @param passToken Address of PASS conditional token\n     * @param failToken Address of FAIL conditional token\n     * @param collateralToken Address of collateral token\n     * @param passAmount Amount of PASS tokens to provide\n     * @param failAmount Amount of FAIL tokens to provide\n     * @param collateralAmountPass Amount of collateral for PASS pool\n     * @param collateralAmountFail Amount of collateral for FAIL pool\n     * @param tickLower Lower tick for the position\n     * @param tickUpper Upper tick for the position\n     * @param deadline Transaction deadline\n     * @return tokenId NFT token ID for the position\n     * @return liquidity Amount of liquidity added\n     */\n    function addLiquidity(\n        uint256 marketId,\n        address passToken,\n        address failToken,\n        address collateralToken,\n        uint256 passAmount,\n        uint256 failAmount,\n        uint256 collateralAmountPass,\n        uint256 collateralAmountFail,\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 deadline\n    ) external onlyOwner whenNotPaused nonReentrant returns (uint256 tokenId, uint128 liquidity) {\n        if (block.timestamp > deadline) revert DeadlineExpired();\n        \n        PoolConfig memory config = marketPools[marketId];\n        if (!config.initialized) revert PoolNotInitialized();\n\n        // Transfer tokens from caller\n        IERC20(passToken).safeTransferFrom(msg.sender, address(this), passAmount);\n        IERC20(failToken).safeTransferFrom(msg.sender, address(this), failAmount);\n        IERC20(collateralToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            collateralAmountPass + collateralAmountFail\n        );\n\n        // Approve position manager\n        IERC20(passToken).safeIncreaseAllowance(address(positionManager), passAmount);\n        IERC20(collateralToken).safeIncreaseAllowance(address(positionManager), collateralAmountPass);\n\n        // Add liquidity to PASS pool\n        (address token0, address token1) = _sortTokens(passToken, collateralToken);\n        (uint256 amount0Desired, uint256 amount1Desired) = token0 == passToken\n            ? (passAmount, collateralAmountPass)\n            : (collateralAmountPass, passAmount);\n\n        INonfungiblePositionManager.MintParams memory params = INonfungiblePositionManager.MintParams({\n            token0: token0,\n            token1: token1,\n            fee: config.fee,\n            tickLower: tickLower,\n            tickUpper: tickUpper,\n            amount0Desired: amount0Desired,\n            amount1Desired: amount1Desired,\n            amount0Min: 0,\n            amount1Min: 0,\n            recipient: address(this),\n            deadline: deadline\n        });\n\n        uint256 amount0;\n        uint256 amount1;\n        (tokenId, liquidity, amount0, amount1) = positionManager.mint(params);\n\n        // Store position for the market\n        marketPositions[marketId] = tokenId;\n\n        emit LiquidityAdded(marketId, tokenId, amount0, amount1, liquidity);\n    }\n\n    // ============ Trading Functions ============\n\n    /**\n     * @notice Buy outcome tokens using collateral via ETCSwap\n     * @dev Executes a swap from collateral to outcome token (PASS or FAIL)\n     * @param marketId Market identifier\n     * @param collateralToken Address of collateral token\n     * @param outcomeToken Address of outcome token (PASS or FAIL)\n     * @param collateralAmount Amount of collateral to spend\n     * @param minTokenAmount Minimum amount of outcome tokens to receive\n     * @param deadline Transaction deadline\n     * @return result Swap execution result\n     */\n    function buyTokens(\n        uint256 marketId,\n        address collateralToken,\n        address outcomeToken,\n        uint256 collateralAmount,\n        uint256 minTokenAmount,\n        uint256 deadline\n    ) external whenNotPaused nonReentrant returns (SwapResult memory result) {\n        if (block.timestamp > deadline) revert DeadlineExpired();\n        if (collateralAmount == 0) revert InvalidAmount();\n        \n        PoolConfig memory config = marketPools[marketId];\n        if (!config.initialized) revert PoolNotInitialized();\n\n        // Transfer collateral from buyer\n        IERC20(collateralToken).safeTransferFrom(msg.sender, address(this), collateralAmount);\n\n        // Approve router\n        IERC20(collateralToken).safeIncreaseAllowance(address(swapRouter), collateralAmount);\n\n        // Execute swap\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: collateralToken,\n            tokenOut: outcomeToken,\n            fee: config.fee,\n            recipient: msg.sender,\n            deadline: deadline,\n            amountIn: collateralAmount,\n            amountOutMinimum: minTokenAmount,\n            sqrtPriceLimitX96: 0\n        });\n\n        uint256 amountOut = swapRouter.exactInputSingle(params);\n        \n        if (amountOut < minTokenAmount) revert InsufficientOutput();\n\n        // Calculate execution price\n        uint256 executionPrice = (collateralAmount * 1e18) / amountOut;\n\n        result = SwapResult({\n            amountIn: collateralAmount,\n            amountOut: amountOut,\n            executionPrice: executionPrice\n        });\n\n        emit TokensSwapped(\n            marketId,\n            msg.sender,\n            collateralToken,\n            outcomeToken,\n            collateralAmount,\n            amountOut,\n            executionPrice\n        );\n    }\n\n    /**\n     * @notice Sell outcome tokens for collateral via ETCSwap\n     * @dev Executes a swap from outcome token (PASS or FAIL) to collateral\n     * @param marketId Market identifier\n     * @param outcomeToken Address of outcome token (PASS or FAIL)\n     * @param collateralToken Address of collateral token\n     * @param tokenAmount Amount of outcome tokens to sell\n     * @param minCollateralAmount Minimum amount of collateral to receive\n     * @param deadline Transaction deadline\n     * @return result Swap execution result\n     */\n    function sellTokens(\n        uint256 marketId,\n        address outcomeToken,\n        address collateralToken,\n        uint256 tokenAmount,\n        uint256 minCollateralAmount,\n        uint256 deadline\n    ) external whenNotPaused nonReentrant returns (SwapResult memory result) {\n        if (block.timestamp > deadline) revert DeadlineExpired();\n        if (tokenAmount == 0) revert InvalidAmount();\n        \n        PoolConfig memory config = marketPools[marketId];\n        if (!config.initialized) revert PoolNotInitialized();\n\n        // Transfer tokens from seller\n        IERC20(outcomeToken).safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n        // Approve router\n        IERC20(outcomeToken).safeIncreaseAllowance(address(swapRouter), tokenAmount);\n\n        // Execute swap\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: outcomeToken,\n            tokenOut: collateralToken,\n            fee: config.fee,\n            recipient: msg.sender,\n            deadline: deadline,\n            amountIn: tokenAmount,\n            amountOutMinimum: minCollateralAmount,\n            sqrtPriceLimitX96: 0\n        });\n\n        uint256 amountOut = swapRouter.exactInputSingle(params);\n        \n        if (amountOut < minCollateralAmount) revert InsufficientOutput();\n\n        // Calculate execution price\n        uint256 executionPrice = (amountOut * 1e18) / tokenAmount;\n\n        result = SwapResult({\n            amountIn: tokenAmount,\n            amountOut: amountOut,\n            executionPrice: executionPrice\n        });\n\n        emit TokensSwapped(\n            marketId,\n            msg.sender,\n            outcomeToken,\n            collateralToken,\n            tokenAmount,\n            amountOut,\n            executionPrice\n        );\n    }\n\n    // ============ Quote Functions ============\n\n    /**\n     * @notice Get quote for buying outcome tokens\n     * @dev Simulates a swap to get expected output amount\n     * @param marketId Market identifier\n     * @param buyPass True for PASS tokens, false for FAIL tokens\n     * @param collateralAmount Amount of collateral to spend\n     * @return estimatedTokenAmount Estimated amount of outcome tokens\n     */\n    function quoteBuyTokens(\n        uint256 marketId,\n        bool buyPass,\n        uint256 collateralAmount\n    ) external view returns (uint256 estimatedTokenAmount) {\n        PoolConfig memory config = marketPools[marketId];\n        if (!config.initialized) revert PoolNotInitialized();\n\n        address pool = buyPass ? config.passPool : config.failPool;\n        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();\n\n        // Simplified estimation based on current price\n        // In production, use a more sophisticated quoter contract\n        uint256 priceX96 = uint256(sqrtPriceX96) * uint256(sqrtPriceX96) / (1 << 96);\n        estimatedTokenAmount = (collateralAmount * (1 << 96)) / priceX96;\n    }\n\n    /**\n     * @notice Get quote for selling outcome tokens\n     * @dev Simulates a swap to get expected output amount\n     * @param marketId Market identifier\n     * @param sellPass True for PASS tokens, false for FAIL tokens\n     * @param tokenAmount Amount of outcome tokens to sell\n     * @return estimatedCollateralAmount Estimated amount of collateral\n     */\n    function quoteSellTokens(\n        uint256 marketId,\n        bool sellPass,\n        uint256 tokenAmount\n    ) external view returns (uint256 estimatedCollateralAmount) {\n        PoolConfig memory config = marketPools[marketId];\n        if (!config.initialized) revert PoolNotInitialized();\n\n        address pool = sellPass ? config.passPool : config.failPool;\n        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();\n\n        // Simplified estimation based on current price\n        // Note: sqrtPriceX96 is in Q64.96 format, so we need to square it and divide by 2^96\n        // to get the actual price. This appears as divide-before-multiply to static analyzers\n        // but is the correct implementation for Uniswap v3's fixed-point arithmetic.\n        uint256 priceX96 = uint256(sqrtPriceX96) * uint256(sqrtPriceX96) / (1 << 96);\n        estimatedCollateralAmount = (tokenAmount * priceX96) / (1 << 96);\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Update default slippage tolerance\n     * @param newSlippageBps New slippage in basis points\n     */\n    function setDefaultSlippage(uint256 newSlippageBps) external onlyOwner {\n        if (newSlippageBps > MAX_SLIPPAGE_BPS) revert InvalidSlippage();\n        \n        uint256 oldSlippage = defaultSlippageBps;\n        defaultSlippageBps = newSlippageBps;\n        \n        emit SlippageUpdated(oldSlippage, newSlippageBps);\n    }\n\n    /**\n     * @notice Toggle pause state for emergency stops\n     */\n    function togglePause() external onlyOwner {\n        paused = !paused;\n        emit EmergencyPauseToggled(paused);\n    }\n\n    /**\n     * @notice Collect fees from a liquidity position\n     * @param marketId Market identifier\n     * @param recipient Address to receive collected fees\n     * @return amount0 Amount of token0 fees collected\n     * @return amount1 Amount of token1 fees collected\n     */\n    function collectFees(uint256 marketId, address recipient)\n        external\n        onlyOwner\n        nonReentrant\n        returns (uint256 amount0, uint256 amount1)\n    {\n        uint256 positionId = marketPositions[marketId];\n        if (positionId == 0) revert PoolNotInitialized();\n\n        INonfungiblePositionManager.CollectParams memory params = INonfungiblePositionManager.CollectParams({\n            tokenId: positionId,\n            recipient: recipient,\n            amount0Max: type(uint128).max,\n            amount1Max: type(uint128).max\n        });\n\n        (amount0, amount1) = positionManager.collect(params);\n\n        emit FeesCollected(marketId, positionId, amount0, amount1);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get pool addresses for a market\n     * @param marketId Market identifier\n     * @return passPool PASS pool address\n     * @return failPool FAIL pool address\n     */\n    function getMarketPools(uint256 marketId) external view returns (address passPool, address failPool) {\n        PoolConfig memory config = marketPools[marketId];\n        return (config.passPool, config.failPool);\n    }\n\n    /**\n     * @notice Get current price for outcome token in a pool\n     * @param marketId Market identifier\n     * @param forPassToken True for PASS token price, false for FAIL\n     * @return sqrtPriceX96 Current sqrt price\n     * @return tick Current tick\n     */\n    function getPoolPrice(uint256 marketId, bool forPassToken)\n        external\n        view\n        returns (uint160 sqrtPriceX96, int24 tick)\n    {\n        PoolConfig memory config = marketPools[marketId];\n        if (!config.initialized) revert PoolNotInitialized();\n\n        address pool = forPassToken ? config.passPool : config.failPool;\n        (sqrtPriceX96, tick, , , , , ) = IUniswapV3Pool(pool).slot0();\n    }\n\n    /**\n     * @notice Calculate minimum output with slippage protection\n     * @param amount Input amount\n     * @param slippageBps Slippage tolerance in basis points\n     * @return minAmount Minimum acceptable output\n     */\n    function calculateMinOutput(uint256 amount, uint256 slippageBps) public pure returns (uint256 minAmount) {\n        if (slippageBps > MAX_SLIPPAGE_BPS) revert InvalidSlippage();\n        minAmount = (amount * (10000 - slippageBps)) / 10000;\n    }\n\n    // ============ Internal Functions ============\n\n    /**\n     * @notice Get existing pool or create new one\n     * @param tokenA First token\n     * @param tokenB Second token\n     * @param fee Fee tier\n     * @return pool Pool address\n     */\n    function _getOrCreatePool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal returns (address pool) {\n        pool = factory.getPool(tokenA, tokenB, fee);\n        \n        if (pool == address(0)) {\n            pool = factory.createPool(tokenA, tokenB, fee);\n        }\n    }\n\n    /**\n     * @notice Initialize pool with starting price if not already initialized\n     * @param pool Pool address\n     * @param sqrtPriceX96 Initial sqrt price\n     */\n    function _initializePoolIfNeeded(address pool, uint160 sqrtPriceX96) internal {\n        (uint160 currentPrice, , , , , , bool unlocked) = IUniswapV3Pool(pool).slot0();\n        \n        // Only initialize if pool is locked or price is 0\n        if (!unlocked || currentPrice == 0) {\n            IUniswapV3Pool(pool).initialize(sqrtPriceX96);\n        }\n    }\n\n    /**\n     * @notice Sort tokens by address\n     * @param tokenA First token\n     * @param tokenB Second token\n     * @return token0 Lower address\n     * @return token1 Higher address\n     */\n    function _sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n}\n"
    },
    "contracts/interfaces/uniswap-v3/INonfungiblePositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.24;\n\n/**\n * @title INonfungiblePositionManager\n * @notice Wraps Uniswap V3 positions in the ERC721 non-fungible token interface\n * @dev Compatible with ETCSwap v3\n * Reference: https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/INonfungiblePositionManager.sol\n */\ninterface INonfungiblePositionManager {\n    /// @notice Emitted when liquidity is increased for a position NFT\n    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n\n    /// @notice Emitted when liquidity is decreased for a position NFT\n    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n\n    /// @notice Emitted when tokens are collected for a position NFT\n    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    /// @notice Creates a new position wrapped in a NFT\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Increases liquidity in the current range with the provided token amounts\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Decreases liquidity in the current range and accounts it to the position\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Burns a token ID, which deletes it from the NFT contract\n    function burn(uint256 tokenId) external payable;\n\n    /// @notice Returns the position information associated with a given token ID\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n}\n"
    },
    "contracts/interfaces/uniswap-v3/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.24;\n\n/**\n * @title ISwapRouter\n * @notice Router for executing swaps on Uniswap V3\n * @dev Compatible with ETCSwap v3\n * Reference: https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/ISwapRouter.sol\n */\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token along the specified path (reversed)\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/interfaces/uniswap-v3/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.24;\n\n/**\n * @title IUniswapV3Factory\n * @notice The interface for the Uniswap V3 Factory\n * @dev Compatible with ETCSwap v3\n * Reference: https://github.com/Uniswap/v3-core/blob/main/contracts/interfaces/IUniswapV3Factory.sol\n */\ninterface IUniswapV3Factory {\n    /// @notice Emitted when a pool is created\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when the owner is changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a new fee amount is enabled\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.24;\n\n/**\n * @title IUniswapV3Pool\n * @notice The interface for a Uniswap V3 Pool\n * @dev Compatible with ETCSwap v3\n * Reference: https://github.com/Uniswap/v3-core/blob/main/contracts/interfaces/IUniswapV3Pool.sol\n */\ninterface IUniswapV3Pool {\n    /// @notice The first of the two tokens of the pool, sorted by address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    function maxLiquidityPerTick() external view returns (uint128);\n\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns the information about a position by the position's key\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n\n    /// @notice Sets the initial price for the pool\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n}\n"
    },
    "contracts/libraries/PrimeMapping.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\n/**\n * @title PrimeMapping\n * @notice Library for mapping market data and addresses to prime numbers\n * @dev Essential for RSA accumulator operations which require prime elements.\n *      Provides deterministic mapping from keccak256 hashes to prime numbers.\n *\n *      The mapping algorithm:\n *      1. Compute keccak256 hash of the input data\n *      2. Use hash as starting point for prime search\n *      3. Find smallest prime >= hash value\n *      4. Return prime as both bytes and uint256\n *\n *      Security properties:\n *      - Deterministic: same input always produces same prime\n *      - Collision-resistant: relies on keccak256 collision resistance\n *      - Unpredictable: prime offset from hash is computationally hard to predict\n */\nlibrary PrimeMapping {\n\n    // ========== Errors ==========\n\n    error InvalidMarketData();\n    error InvalidAddress();\n\n    // ========== Market Hash Functions ==========\n\n    /**\n     * @notice Compute unique hash for a market based on its immutable properties\n     * @dev Uses proposalId, collateral token, condition ID, and position IDs\n     *      These fields are immutable once a market is created\n     *\n     * @param proposalId The governance proposal ID this market is attached to\n     * @param collateralToken The ERC20 token used as collateral\n     * @param conditionId The CTF1155 condition identifier\n     * @param passPositionId The CTF1155 position ID for PASS outcome\n     * @param failPositionId The CTF1155 position ID for FAIL outcome\n     * @return hash The keccak256 hash of the market data\n     */\n    function computeMarketHash(\n        uint256 proposalId,\n        address collateralToken,\n        bytes32 conditionId,\n        uint256 passPositionId,\n        uint256 failPositionId\n    ) internal pure returns (bytes32 hash) {\n        return keccak256(abi.encodePacked(\n            \"MARKET_V1\",  // Version prefix for future compatibility\n            proposalId,\n            collateralToken,\n            conditionId,\n            passPositionId,\n            failPositionId\n        ));\n    }\n\n    /**\n     * @notice Compute market hash from market ID and factory address\n     * @dev Alternative hash computation when full market data isn't available\n     *      Useful for off-chain indexing and verification\n     *\n     * @param marketFactory Address of the ConditionalMarketFactory contract\n     * @param marketId The market ID within the factory\n     * @return hash The keccak256 hash\n     */\n    function computeMarketHashSimple(\n        address marketFactory,\n        uint256 marketId\n    ) internal pure returns (bytes32 hash) {\n        return keccak256(abi.encodePacked(\n            \"MARKET_SIMPLE_V1\",\n            marketFactory,\n            marketId\n        ));\n    }\n\n    // ========== Address Hash Functions ==========\n\n    /**\n     * @notice Compute hash for an address to be nullified\n     * @dev Adds domain separator to prevent cross-context attacks\n     *\n     * @param account The address to hash\n     * @return hash The keccak256 hash\n     */\n    function computeAddressHash(address account) internal pure returns (bytes32 hash) {\n        if (account == address(0)) revert InvalidAddress();\n        return keccak256(abi.encodePacked(\n            \"ADDRESS_V1\",\n            account\n        ));\n    }\n\n    // ========== Prime Conversion ==========\n\n    /**\n     * @notice Convert a hash to its prime representative\n     * @dev Finds the smallest prime number >= hash value\n     *      Uses Miller-Rabin primality test with deterministic witnesses\n     *\n     * @param hash The keccak256 hash to convert\n     * @return prime The prime number as uint256\n     */\n    function hashToPrimeUint(bytes32 hash) internal pure returns (uint256 prime) {\n        // Start with hash value, ensure odd\n        uint256 candidate = uint256(hash) | 1;\n\n        // Limit search to prevent DoS (extremely unlikely to exceed)\n        uint256 maxIterations = 1000;\n        uint256 iterations = 0;\n\n        while (!isPrime(candidate) && iterations < maxIterations) {\n            candidate += 2; // Only check odd numbers\n            iterations++;\n\n            // Handle overflow (wrap to small prime)\n            if (candidate == 0) {\n                candidate = 3;\n            }\n        }\n\n        // If we somehow didn't find a prime (shouldn't happen), revert\n        require(iterations < maxIterations, \"Prime search exceeded limit\");\n\n        return candidate;\n    }\n\n    /**\n     * @notice Convert market data directly to prime\n     * @param proposalId The proposal ID\n     * @param collateralToken The collateral token address\n     * @param conditionId The CTF condition ID\n     * @param passPositionId The pass position ID\n     * @param failPositionId The fail position ID\n     * @return prime The prime representative\n     */\n    function marketToPrime(\n        uint256 proposalId,\n        address collateralToken,\n        bytes32 conditionId,\n        uint256 passPositionId,\n        uint256 failPositionId\n    ) internal pure returns (uint256 prime) {\n        bytes32 hash = computeMarketHash(\n            proposalId,\n            collateralToken,\n            conditionId,\n            passPositionId,\n            failPositionId\n        );\n        return hashToPrimeUint(hash);\n    }\n\n    /**\n     * @notice Convert address directly to prime\n     * @param account The address to convert\n     * @return prime The prime representative\n     */\n    function addressToPrime(address account) internal pure returns (uint256 prime) {\n        bytes32 hash = computeAddressHash(account);\n        return hashToPrimeUint(hash);\n    }\n\n    // ========== Primality Testing ==========\n\n    /**\n     * @notice Check if a number is prime using Miller-Rabin\n     * @dev Uses deterministic witnesses sufficient for 256-bit numbers\n     *      Based on https://miller-rabin.appspot.com/ recommendations\n     *\n     * @param n The number to test\n     * @return True if n is prime\n     */\n    function isPrime(uint256 n) internal pure returns (bool) {\n        // Handle small cases\n        if (n < 2) return false;\n        if (n == 2 || n == 3) return true;\n        if (n % 2 == 0) return false;\n        if (n < 9) return true;\n        if (n % 3 == 0) return false;\n\n        // Write n-1 as 2^r * d\n        uint256 d = n - 1;\n        uint256 r = 0;\n        while (d % 2 == 0) {\n            d /= 2;\n            r++;\n        }\n\n        // Test with deterministic witnesses\n        // These witnesses are sufficient for n < 3,317,044,064,679,887,385,961,981\n        // For 256-bit, we add more witnesses for safety\n        uint256[12] memory witnesses = [\n            uint256(2), 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37\n        ];\n\n        for (uint256 i = 0; i < witnesses.length; i++) {\n            if (witnesses[i] >= n) continue;\n            if (!millerRabinTest(n, d, r, witnesses[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Single round of Miller-Rabin test\n     * @param n Number to test\n     * @param d Odd factor of n-1\n     * @param r Power of 2 in n-1 factorization\n     * @param a Witness value\n     * @return True if n passes this round\n     */\n    function millerRabinTest(\n        uint256 n,\n        uint256 d,\n        uint256 r,\n        uint256 a\n    ) internal pure returns (bool) {\n        // Compute a^d mod n\n        uint256 x = modPow(a, d, n);\n\n        if (x == 1 || x == n - 1) {\n            return true;\n        }\n\n        // Repeated squaring\n        for (uint256 i = 1; i < r; i++) {\n            x = mulmod(x, x, n);\n\n            if (x == n - 1) {\n                return true;\n            }\n            if (x == 1) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Modular exponentiation\n     * @dev Computes base^exp mod mod using binary exponentiation\n     */\n    function modPow(uint256 base, uint256 exp, uint256 mod) internal pure returns (uint256 result) {\n        if (mod == 1) return 0;\n\n        result = 1;\n        base = base % mod;\n\n        while (exp > 0) {\n            if (exp % 2 == 1) {\n                result = mulmod(result, base, mod);\n            }\n            exp = exp >> 1;\n            base = mulmod(base, base, mod);\n        }\n    }\n\n    // ========== Batch Operations ==========\n\n    /**\n     * @notice Compute primes for multiple market hashes\n     * @dev Gas-efficient batch computation\n     *\n     * @param hashes Array of market hashes\n     * @return primes Array of prime representatives\n     */\n    function batchHashesToPrimes(bytes32[] memory hashes) internal pure returns (uint256[] memory primes) {\n        primes = new uint256[](hashes.length);\n        for (uint256 i = 0; i < hashes.length; i++) {\n            primes[i] = hashToPrimeUint(hashes[i]);\n        }\n    }\n\n    /**\n     * @notice Compute product of primes (for accumulator computation)\n     * @dev Warning: This can overflow for large sets. Use off-chain for production.\n     *\n     * @param primes Array of prime numbers\n     * @return product The product of all primes (may overflow)\n     */\n    function computePrimeProduct(uint256[] memory primes) internal pure returns (uint256 product) {\n        product = 1;\n        for (uint256 i = 0; i < primes.length; i++) {\n            // Note: This will overflow for real RSA accumulator use\n            // In production, this computation happens off-chain with big integers\n            unchecked {\n                product *= primes[i];\n            }\n        }\n    }\n\n    // ========== Verification Helpers ==========\n\n    /**\n     * @notice Verify a prime was correctly derived from a market hash\n     * @dev Useful for on-chain verification of off-chain computations\n     *\n     * @param marketHash The original market hash\n     * @param claimedPrime The claimed prime representative\n     * @return valid True if claimedPrime is the correct prime for marketHash\n     */\n    function verifyMarketPrime(bytes32 marketHash, uint256 claimedPrime) internal pure returns (bool valid) {\n        // Check that claimed prime is actually prime\n        if (!isPrime(claimedPrime)) return false;\n\n        // Check that it's the correct prime (smallest >= hash)\n        uint256 expectedPrime = hashToPrimeUint(marketHash);\n        return claimedPrime == expectedPrime;\n    }\n\n    /**\n     * @notice Verify a prime was correctly derived from an address hash\n     * @param account The original address\n     * @param claimedPrime The claimed prime representative\n     * @return valid True if claimedPrime is correct\n     */\n    function verifyAddressPrime(address account, uint256 claimedPrime) internal pure returns (bool valid) {\n        if (!isPrime(claimedPrime)) return false;\n        uint256 expectedPrime = addressToPrime(account);\n        return claimedPrime == expectedPrime;\n    }\n}\n"
    },
    "contracts/libraries/RSAAccumulator.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\n/**\n * @title RSAAccumulator\n * @notice Cryptographic RSA accumulator library for efficient set membership management\n * @dev Implements RSA accumulator operations for managing nullified markets and addresses.\n *      Uses EIP-198 modular exponentiation precompile for gas-efficient computation.\n *\n *      The accumulator allows:\n *      - Efficient addition/removal of elements from a set\n *      - Compact non-membership proofs that don't reveal set contents\n *      - O(1) storage for the set state regardless of size\n *\n *      Security considerations:\n *      - RSA modulus must be product of two unknown safe primes (generated by trusted setup)\n *      - Elements must be mapped to prime numbers to prevent forgery\n *      - This implementation is verification-only; accumulator updates happen off-chain\n */\nlibrary RSAAccumulator {\n\n    // EIP-198 modular exponentiation precompile address\n    address internal constant MOD_EXP_PRECOMPILE = address(0x05);\n\n    // Number of bytes for 2048-bit RSA operations\n    uint256 internal constant RSA_BYTES = 256;\n\n    /**\n     * @notice RSA accumulator parameters (immutable after initialization)\n     * @param n RSA modulus (2048-bit) - product of two secret safe primes\n     * @param g Generator element - quadratic residue mod n\n     */\n    struct AccumulatorParams {\n        bytes n;    // RSA modulus (256 bytes for 2048-bit)\n        bytes g;    // Generator (256 bytes)\n    }\n\n    /**\n     * @notice Non-membership witness for RSA accumulator\n     * @dev Used to prove an element is NOT in the accumulated set\n     *      Based on the Gennaro-Halevi-Rabin construction\n     * @param d Bezout coefficient for the proof\n     * @param b Base component of the witness\n     */\n    struct NonMembershipWitness {\n        bytes d;    // Bezout coefficient (signed, stored as absolute value + sign flag)\n        bytes b;    // Base witness component\n        bool dNegative;  // Sign of d coefficient\n    }\n\n    // ========== Errors ==========\n\n    error InvalidRSAModulus();\n    error InvalidGenerator();\n    error InvalidWitness();\n    error ModExpFailed();\n    error InvalidPrimeRepresentative();\n\n    // ========== Core Operations ==========\n\n    /**\n     * @notice Verify that an element is NOT in the accumulated set\n     * @dev Non-membership proof verification using the equation:\n     *      A^d * b^prime = g  (if d positive)\n     *      or equivalently: b^prime = g * A^(-d)  (if d negative, computed differently)\n     *\n     *      This uses the fact that if prime is coprime to the product of all accumulated primes,\n     *      then Bezout's identity gives us coefficients for this relation.\n     *\n     * @param params RSA parameters (modulus n, generator g)\n     * @param accumulator Current accumulator value A = g^(p1*p2*...*pk) mod n\n     * @param prime Prime representative of the element to check\n     * @param witness Non-membership witness (d, b) such that a*d + prime*e = 1 for some e\n     * @return valid True if the element is NOT in the accumulated set\n     */\n    function verifyNonMembership(\n        AccumulatorParams memory params,\n        bytes memory accumulator,\n        bytes memory prime,\n        NonMembershipWitness memory witness\n    ) internal view returns (bool valid) {\n        // Verify basic parameter lengths\n        if (params.n.length != RSA_BYTES) revert InvalidRSAModulus();\n        if (params.g.length != RSA_BYTES) revert InvalidGenerator();\n        if (accumulator.length != RSA_BYTES) revert InvalidWitness();\n\n        // Compute: A^d mod n (or A^(-d) mod n if d is negative)\n        bytes memory aPowD;\n        if (witness.dNegative) {\n            // For negative d, compute modular inverse of A^|d|\n            bytes memory aPowAbsD = modExp(accumulator, witness.d, params.n);\n            aPowD = modInverse(aPowAbsD, params.n);\n        } else {\n            aPowD = modExp(accumulator, witness.d, params.n);\n        }\n\n        // Compute: b^prime mod n\n        bytes memory bPowPrime = modExp(witness.b, prime, params.n);\n\n        // Compute: A^d * b^prime mod n\n        bytes memory product = modMul(aPowD, bPowPrime, params.n);\n\n        // Verify: A^d * b^prime == g (mod n)\n        return bytesEqual(product, params.g);\n    }\n\n    /**\n     * @notice Verify membership of an element in the accumulated set\n     * @dev Membership proof: witness^prime == accumulator (mod n)\n     * @param params RSA parameters\n     * @param accumulator Current accumulator value\n     * @param prime Prime representative of the element\n     * @param witness Membership witness w such that w^prime = A\n     * @return valid True if the element IS in the accumulated set\n     */\n    function verifyMembership(\n        AccumulatorParams memory params,\n        bytes memory accumulator,\n        bytes memory prime,\n        bytes memory witness\n    ) internal view returns (bool valid) {\n        if (params.n.length != RSA_BYTES) revert InvalidRSAModulus();\n\n        // Compute: witness^prime mod n\n        bytes memory result = modExp(witness, prime, params.n);\n\n        // Verify: witness^prime == accumulator (mod n)\n        return bytesEqual(result, accumulator);\n    }\n\n    // ========== Prime Mapping ==========\n\n    /**\n     * @notice Map a keccak256 hash to a deterministic prime number\n     * @dev Uses a deterministic search starting from hash value, finding first prime\n     *      The search adds small increments to find a prime, ensuring determinism\n     *\n     *      Prime verification uses Miller-Rabin with sufficient rounds for security\n     *\n     * @param hash The keccak256 hash to convert\n     * @return prime The deterministic prime representative (as bytes)\n     * @return primeUint The prime as uint256 (lower 256 bits)\n     */\n    function hashToPrime(bytes32 hash) internal pure returns (bytes memory prime, uint256 primeUint) {\n        // Start with the hash value, ensure it's odd\n        uint256 candidate = uint256(hash) | 1;\n\n        // Search for the first prime >= candidate\n        // We use a simplified primality check suitable for 256-bit numbers\n        while (!isProbablePrime(candidate)) {\n            candidate += 2; // Only check odd numbers\n            // Handle overflow (extremely unlikely for 256-bit)\n            if (candidate < uint256(hash)) {\n                candidate = 3; // Wrap around\n            }\n        }\n\n        primeUint = candidate;\n        prime = uint256ToBytes(candidate, 32); // 256-bit prime fits in 32 bytes\n    }\n\n    /**\n     * @notice Map an address to a deterministic prime number\n     * @param addr The address to convert\n     * @return prime The deterministic prime representative\n     * @return primeUint The prime as uint256\n     */\n    function addressToPrime(address addr) internal pure returns (bytes memory prime, uint256 primeUint) {\n        bytes32 hash = keccak256(abi.encodePacked(addr));\n        return hashToPrime(hash);\n    }\n\n    /**\n     * @notice Compute market hash from market data\n     * @dev Creates a unique identifier for a market based on its immutable properties\n     * @param proposalId The proposal ID\n     * @param collateralToken The collateral token address\n     * @param conditionId The CTF condition ID\n     * @param passPositionId The pass position ID\n     * @param failPositionId The fail position ID\n     * @return marketHash The keccak256 hash of the market data\n     */\n    function computeMarketHash(\n        uint256 proposalId,\n        address collateralToken,\n        bytes32 conditionId,\n        uint256 passPositionId,\n        uint256 failPositionId\n    ) internal pure returns (bytes32 marketHash) {\n        return keccak256(abi.encodePacked(\n            proposalId,\n            collateralToken,\n            conditionId,\n            passPositionId,\n            failPositionId\n        ));\n    }\n\n    // ========== Primality Testing ==========\n\n    /**\n     * @notice Check if a number is probably prime using Miller-Rabin\n     * @dev Uses deterministic witnesses for numbers < 2^64, probabilistic for larger\n     *      For 256-bit numbers, uses 20 rounds for negligible error probability\n     * @param n The number to test\n     * @return isPrime True if n is probably prime\n     */\n    function isProbablePrime(uint256 n) internal pure returns (bool isPrime) {\n        if (n < 2) return false;\n        if (n == 2 || n == 3) return true;\n        if (n % 2 == 0) return false;\n        if (n < 9) return true;\n        if (n % 3 == 0) return false;\n\n        // Write n-1 as 2^r * d where d is odd\n        uint256 d = n - 1;\n        uint256 r = 0;\n        while (d % 2 == 0) {\n            d /= 2;\n            r++;\n        }\n\n        // Deterministic witnesses for small numbers\n        uint256[7] memory witnesses = [uint256(2), 3, 5, 7, 11, 13, 17];\n\n        for (uint256 i = 0; i < witnesses.length; i++) {\n            uint256 a = witnesses[i];\n            if (a >= n - 1) continue;\n\n            if (!millerRabinRound(n, d, r, a)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Single round of Miller-Rabin primality test\n     * @param n Number to test\n     * @param d Odd component of n-1\n     * @param r Power of 2 in n-1\n     * @param a Witness to test\n     * @return passed True if n passes this round\n     */\n    function millerRabinRound(\n        uint256 n,\n        uint256 d,\n        uint256 r,\n        uint256 a\n    ) internal pure returns (bool passed) {\n        // Compute a^d mod n\n        uint256 x = modExpUint(a, d, n);\n\n        if (x == 1 || x == n - 1) {\n            return true;\n        }\n\n        for (uint256 i = 1; i < r; i++) {\n            x = mulmod(x, x, n);\n            if (x == n - 1) {\n                return true;\n            }\n            if (x == 1) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n\n    // ========== Modular Arithmetic ==========\n\n    /**\n     * @notice Modular exponentiation using EIP-198 precompile\n     * @dev Uses the MODEXP precompile at address 0x05 for gas efficiency\n     * @param base Base value\n     * @param exponent Exponent value\n     * @param modulus Modulus value\n     * @return result base^exponent mod modulus\n     */\n    function modExp(\n        bytes memory base,\n        bytes memory exponent,\n        bytes memory modulus\n    ) internal view returns (bytes memory result) {\n        // Prepare input: [baseLen][expLen][modLen][base][exp][mod]\n        bytes memory input = abi.encodePacked(\n            uint256(base.length),\n            uint256(exponent.length),\n            uint256(modulus.length),\n            base,\n            exponent,\n            modulus\n        );\n\n        result = new bytes(modulus.length);\n\n        assembly {\n            let success := staticcall(\n                gas(),\n                0x05, // MODEXP precompile\n                add(input, 0x20),\n                mload(input),\n                add(result, 0x20),\n                mload(modulus)\n            )\n            if iszero(success) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    /**\n     * @notice Modular exponentiation for uint256 values\n     * @dev Uses assembly for efficiency\n     */\n    function modExpUint(uint256 base, uint256 exp, uint256 mod) internal pure returns (uint256 result) {\n        if (mod == 1) return 0;\n\n        result = 1;\n        base = base % mod;\n\n        while (exp > 0) {\n            if (exp % 2 == 1) {\n                result = mulmod(result, base, mod);\n            }\n            exp = exp / 2;\n            base = mulmod(base, base, mod);\n        }\n    }\n\n    /**\n     * @notice Modular multiplication of two byte arrays\n     * @dev Uses schoolbook multiplication with reduction\n     */\n    function modMul(\n        bytes memory a,\n        bytes memory b,\n        bytes memory modulus\n    ) internal view returns (bytes memory result) {\n        // For simplicity, use modExp: a * b mod n = (a * b) mod n\n        // We compute this via: a^1 * b^1 using Chinese Remainder Theorem approach\n        // Actually, simpler: use modExp with exponent = 1 on the product\n\n        // First, compute a * b (may overflow, but we'll reduce)\n        // For 2048-bit numbers, we need to use big integer multiplication\n        // Use precompile-based approach: compute a^1, then multiply by b\n\n        // Simpler approach: a * b mod n using the identity:\n        // a * b mod n = ((a mod n) * (b mod n)) mod n\n        // We need big integer multiplication here\n\n        // For now, use a workaround with modExp:\n        // Result = a * b mod n\n        // We can compute this as: modExp(a, 1, n) then multiply\n        // But that's just a mod n, then we need to multiply by b\n\n        // Use the fact that a*b = exp(log(a*b)) = exp(log(a) + log(b))\n        // But that's not practical here\n\n        // Practical approach: use assembly or external library\n        // For MVP, we'll use a simplified version\n        result = _modMulBigInt(a, b, modulus);\n    }\n\n    /**\n     * @notice Big integer modular multiplication\n     * @dev Internal helper for modular multiplication of large numbers\n     */\n    function _modMulBigInt(\n        bytes memory a,\n        bytes memory b,\n        bytes memory n\n    ) internal view returns (bytes memory) {\n        // Use modExp to compute (a * b) mod n\n        // We can use the identity: a * b mod n = (a^1 * b^1) mod n\n        // Compute via: first get a mod n, then multiply iteratively\n\n        // For 2048-bit RSA, we need to handle this carefully\n        // One approach: break into limbs and compute\n        // For simplicity in MVP, we use a single-limb approximation\n        // In production, use a proper big integer library\n\n        // Workaround: treat as exponent 1, multiply via repeated addition\n        // This is slow but correct for MVP\n\n        // Actually, let's use the modExp precompile creatively\n        // We compute: result = (a * b) mod n\n        // Using: a * b = a^1 * b^1, but modExp only handles single base\n\n        // Better: store result in contract and use multiple calls\n        // For MVP, assume a and b fit in reasonable bounds\n\n        // Simplified version for 256-bit operands within 2048-bit modulus\n        if (a.length <= 32 && b.length <= 32) {\n            uint256 aUint = bytesToUint256(a);\n            uint256 bUint = bytesToUint256(b);\n            uint256 nUint = bytesToUint256(n);\n\n            if (nUint > 0) {\n                uint256 result = mulmod(aUint, bUint, nUint);\n                return uint256ToBytes(result, n.length);\n            }\n        }\n\n        // For larger numbers, use modExp with base=a*b and exp=1\n        // First pad a and b to same length as modulus\n        bytes memory paddedA = padLeft(a, n.length);\n        bytes memory paddedB = padLeft(b, n.length);\n\n        // Compute product using schoolbook multiplication\n        bytes memory product = bigMul(paddedA, paddedB);\n\n        // Reduce modulo n using modExp(product, 1, n)\n        bytes memory one = new bytes(1);\n        one[0] = 0x01;\n\n        return modExp(product, one, n);\n    }\n\n    /**\n     * @notice Compute modular inverse using extended Euclidean algorithm\n     * @dev Computes a^(-1) mod n\n     */\n    function modInverse(bytes memory a, bytes memory n) internal view returns (bytes memory) {\n        // Use Fermat's little theorem for prime modulus: a^(-1) = a^(n-2) mod n\n        // For composite RSA modulus, use extended Euclidean algorithm\n        // For MVP, assume modulus properties allow Fermat's method\n\n        bytes memory nMinus2 = subtractBytes(n, uint256ToBytes(2, n.length));\n        return modExp(a, nMinus2, n);\n    }\n\n    // ========== Byte Utilities ==========\n\n    /**\n     * @notice Convert uint256 to bytes with specified length\n     */\n    function uint256ToBytes(uint256 value, uint256 length) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(length);\n        for (uint256 i = 0; i < length && i < 32; i++) {\n            result[length - 1 - i] = bytes1(uint8(value >> (8 * i)));\n        }\n        return result;\n    }\n\n    /**\n     * @notice Convert bytes to uint256 (takes last 32 bytes if longer)\n     */\n    function bytesToUint256(bytes memory b) internal pure returns (uint256 result) {\n        uint256 start = b.length > 32 ? b.length - 32 : 0;\n        for (uint256 i = start; i < b.length; i++) {\n            result = result * 256 + uint8(b[i]);\n        }\n    }\n\n    /**\n     * @notice Pad bytes array on the left with zeros\n     */\n    function padLeft(bytes memory b, uint256 length) internal pure returns (bytes memory) {\n        if (b.length >= length) return b;\n        bytes memory result = new bytes(length);\n        uint256 offset = length - b.length;\n        for (uint256 i = 0; i < b.length; i++) {\n            result[offset + i] = b[i];\n        }\n        return result;\n    }\n\n    /**\n     * @notice Compare two byte arrays for equality\n     */\n    function bytesEqual(bytes memory a, bytes memory b) internal pure returns (bool) {\n        if (a.length != b.length) return false;\n        return keccak256(a) == keccak256(b);\n    }\n\n    /**\n     * @notice Subtract a bytes value from another\n     */\n    function subtractBytes(bytes memory a, bytes memory b) internal pure returns (bytes memory) {\n        uint256 aUint = bytesToUint256(a);\n        uint256 bUint = bytesToUint256(b);\n        require(aUint >= bUint, \"Underflow\");\n        return uint256ToBytes(aUint - bUint, a.length);\n    }\n\n    /**\n     * @notice Multiply two big integers (schoolbook method)\n     * @dev Returns a number twice the length of inputs\n     */\n    function bigMul(bytes memory a, bytes memory b) internal pure returns (bytes memory) {\n        uint256 resultLen = a.length + b.length;\n        bytes memory result = new bytes(resultLen);\n\n        // Schoolbook multiplication (simple but O(n^2))\n        for (uint256 i = 0; i < a.length; i++) {\n            uint256 carry = 0;\n            for (uint256 j = 0; j < b.length; j++) {\n                uint256 pos = resultLen - 1 - i - j;\n                uint256 prod = uint8(a[a.length - 1 - i]) * uint8(b[b.length - 1 - j]) + uint8(result[pos]) + carry;\n                result[pos] = bytes1(uint8(prod % 256));\n                carry = prod / 256;\n            }\n            // Handle remaining carry\n            uint256 carryPos = resultLen - 1 - i - b.length;\n            while (carry > 0 && carryPos < resultLen) {\n                uint256 sum = uint8(result[carryPos]) + carry;\n                result[carryPos] = bytes1(uint8(sum % 256));\n                carry = sum / 256;\n                if (carryPos == 0) break;\n                carryPos--;\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/libraries/TierTypes.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\n/**\n * @title TierTypes\n * @notice Shared types for tiered membership system\n */\n\n// ========== Tier Definitions ==========\n\nenum MembershipTier {\n    NONE,       // 0 - No membership\n    BRONZE,     // 1 - Basic tier\n    SILVER,     // 2 - Intermediate tier\n    GOLD,       // 3 - Advanced tier\n    PLATINUM    // 4 - Premium tier\n}\n\nenum MembershipDuration {\n    ONE_MONTH,      // 30 days\n    THREE_MONTHS,   // 90 days\n    SIX_MONTHS,     // 180 days\n    TWELVE_MONTHS,  // 365 days\n    ENTERPRISE      // Custom/unlimited duration\n}\n\n// ========== Tier Metadata ==========\n\nstruct TierLimits {\n    uint256 dailyBetLimit;           // Max bets per day\n    uint256 weeklyBetLimit;          // Max bets per week\n    uint256 monthlyMarketCreation;   // Max markets created per month\n    uint256 maxPositionSize;         // Max position size in wei\n    uint256 maxConcurrentMarkets;    // Max active markets at once\n    uint256 withdrawalLimit;         // Daily withdrawal limit\n    bool canCreatePrivateMarkets;    // Can create private markets\n    bool canUseAdvancedFeatures;     // Access to advanced features\n    uint256 feeDiscount;             // Fee discount in basis points (100 = 1%)\n}\n\nstruct TierMetadata {\n    string name;\n    string description;\n    uint256 price;                   // Upgrade price from previous tier\n    TierLimits limits;\n    bool isActive;\n}\n\n// ========== Usage Tracking ==========\n\nstruct UsageStats {\n    uint256 dailyBetsCount;\n    uint256 weeklyBetsCount;\n    uint256 monthlyMarketsCreated;\n    uint256 dailyWithdrawals;\n    uint256 activeMarketsCount;\n    uint256 lastDailyReset;\n    uint256 lastWeeklyReset;\n    uint256 lastMonthlyReset;\n}\n"
    },
    "contracts/markets/ConditionalMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../integrations/ETCSwapV3Integration.sol\";\nimport \"../access/TieredRoleManager.sol\";\nimport \"./CTF1155.sol\";\nimport \"../security/NullifierRegistry.sol\";\n\n/**\n * @title ConditionalMarketFactory\n * @notice Automated deployment of pass-fail market pairs using Gnosis CTF standards\n * @dev Creates conditional prediction markets for proposals with role-based access control\n * \n * For a practical walkthrough of how this contract works, see:\n * docs/user-guide/conditional-market-rain-example.md\n * \n * TRADING INTEGRATION:\n * This contract now integrates with ETC Swap v3 contracts for production-ready DEX trading.\n * The integration uses ETCSwapV3Integration contract for:\n * - Pool creation and initialization\n * - Liquidity provision and management\n * - Token swapping with slippage protection\n * \n * Integration approach:\n * 1. ConditionalMarketFactory creates PASS/FAIL token pairs\n * 2. ETCSwapV3Integration creates pools for PASS/collateral and FAIL/collateral trading pairs\n * 3. Liquidity is provided to ETC Swap pools through the integration layer\n * 4. Users trade through ETC Swap's battle-tested DEX infrastructure\n * 5. ConditionalMarketFactory handles final settlement based on oracle outcomes\n * \n * Trading modes:\n * - ETCSwap mode: Full decentralized trading via Uniswap v3 pools\n * - Fallback mode: Simplified LMSR for testing and backwards compatibility\n * \n * RBAC INTEGRATION:\n * - Market creation requires MARKET_MAKER_ROLE\n * - Admin functions require OPERATIONS_ADMIN_ROLE\n * - Tier limits enforced on market creation and trading\n */\ncontract ConditionalMarketFactory is Ownable, ReentrancyGuard, IERC1155Receiver {\n    using SafeERC20 for IERC20;\n    \n    /**\n     * @notice Enum defining different types of binary outcomes for prediction markets\n     * @dev Each bet type represents a different way to frame binary predictions\n     */\n    enum BetType {\n        YesNo,          // Standard Yes / No outcome\n        PassFail,       // Pass / Fail outcome (default for governance)\n        AboveBelow,     // Above / Below a threshold\n        HigherLower,    // Higher / Lower than reference\n        InOut,          // In / Out of range\n        OverUnder,      // Over / Under a value\n        ForAgainst,     // For / Against a proposal\n        TrueFalse,      // True / False statement\n        WinLose,        // Win / Lose outcome\n        UpDown          // Up / Down movement\n    }\n\n    struct Market {\n        uint256 proposalId;\n        address passToken;\n        address failToken;\n        address collateralToken;\n        uint256 tradingEndTime;\n        uint256 liquidityParameter; // Beta parameter for LMSR\n        uint256 totalLiquidity;\n        bool resolved;\n        uint256 passValue;\n        uint256 failValue;\n        MarketStatus status;\n        BetType betType;\n        bool useCTF;               // Whether this market uses CTF1155\n        bytes32 conditionId;       // CTF condition ID (if using CTF)\n        bytes32 questionId;        // CTF question ID (if using CTF)\n        uint256 passPositionId;    // CTF position ID for pass outcome\n        uint256 failPositionId;    // CTF position ID for fail outcome\n        uint256 passQuantity;      // Cumulative collateral spent on PASS\n        uint256 failQuantity;      // Cumulative collateral spent on FAIL\n    }\n\n    enum MarketStatus {\n        Active,\n        TradingEnded,\n        Resolved,\n        Cancelled\n    }\n\n    // Market ID => Market\n    mapping(uint256 => Market) public markets;\n    \n    // Proposal ID => Market ID (marketId + 1 to avoid 0 confusion)\n    mapping(uint256 => uint256) private _proposalToMarketPlusOne;\n    \n    // Market status tracking for efficient querying\n    mapping(MarketStatus => uint256[]) private marketsByStatus;\n\n    // Time-based indexing (day => market IDs)\n    mapping(uint256 => uint256[]) private marketsByDay;\n\n    // Market ID => Metadata URI (IPFS or HTTP URL)\n    mapping(uint256 => string) private marketMetadataUris;\n\n    uint256 public marketCount;\n    uint256 public constant DEFAULT_TRADING_PERIOD = 10 days;\n    uint256 public constant MIN_TRADING_PERIOD = 7 days;\n    uint256 public constant MAX_TRADING_PERIOD = 21 days;\n    uint256 public constant MAX_BATCH_SIZE = 50;\n\n    bool private _initialized;\n    \n    // ETCSwap v3 integration\n    ETCSwapV3Integration public etcSwapIntegration;\n    bool public useETCSwap;\n    \n    // Role-based access control\n    TieredRoleManager public roleManager;\n    \n    // CTF1155 integration - now required for all markets\n    CTF1155 public ctf1155;\n\n    // Nullifier registry for market protection\n    NullifierRegistry public nullifierRegistry;\n\n    // Whether to enforce nullification checks on-chain (default: false, frontend handles this)\n    bool public enforceNullificationOnChain;\n\n    // Default initial price for pools (0.5 = equal probability)\n    uint160 public constant DEFAULT_INITIAL_SQRT_PRICE = 79228162514264337593543950336; // sqrt(0.5) in Q64.96\n\n    // Enhanced events for better indexing and market discovery\n    event MarketCreated(\n        uint256 indexed marketId,\n        uint256 indexed proposalId,\n        address indexed collateralToken,\n        address passToken,\n        address failToken,\n        uint256 tradingEndTime,\n        uint256 liquidityParameter,\n        uint256 createdAt,\n        address creator,\n        BetType betType\n    );\n    \n    event TokensPurchased(\n        uint256 indexed marketId,\n        address indexed buyer,\n        bool indexed buyPass,\n        uint256 collateralAmount,\n        uint256 tokenAmount\n    );\n    \n    event TokensSold(\n        uint256 indexed marketId,\n        address indexed seller,\n        bool indexed sellPass,\n        uint256 tokenAmount,\n        uint256 collateralAmount\n    );\n    \n    event MarketStatusChanged(\n        uint256 indexed marketId,\n        MarketStatus indexed previousStatus,\n        MarketStatus indexed newStatus,\n        uint256 changedAt\n    );\n    \n    event MarketResolved(\n        uint256 indexed marketId,\n        uint256 indexed proposalId,\n        uint256 passValue,\n        uint256 failValue,\n        bool indexed approved,\n        uint256 resolvedAt\n    );\n    \n    event MarketCancelled(\n        uint256 indexed marketId,\n        uint256 indexed proposalId,\n        string reason,\n        uint256 cancelledAt\n    );\n    \n    event BatchMarketsCreated(\n        uint256[] marketIds,\n        uint256 batchTimestamp,\n        uint256 totalMarketsCreated\n    );\n    \n    event BatchMarketsResolved(\n        uint256[] marketIds,\n        uint256 batchTimestamp,\n        uint256 totalMarketsResolved\n    );\n    \n    event ETCSwapIntegrationUpdated(address indexed integration, bool enabled);\n    \n    event ETCSwapPoolsCreated(\n        uint256 indexed marketId,\n        address indexed passPool,\n        address indexed failPool\n    );\n    \n    event CTF1155Updated(address indexed ctf1155);\n\n    event NullifierRegistryUpdated(address indexed nullifierRegistry);\n\n    event NullificationEnforcementUpdated(bool enforceOnChain);\n\n    event CTFMarketCreated(\n        uint256 indexed marketId,\n        bytes32 indexed conditionId,\n        uint256 passPositionId,\n        uint256 failPositionId\n    );\n\n    constructor() Ownable(msg.sender) {}\n    \n    /**\n     * @notice Set the role manager contract\n     * @param _roleManager Address of TieredRoleManager contract\n     */\n    function setRoleManager(address _roleManager) external onlyOwner {\n        require(_roleManager != address(0), \"Invalid role manager address\");\n        roleManager = TieredRoleManager(_roleManager);\n    }\n    \n    /**\n     * @notice Modifier to check if user has MARKET_MAKER_ROLE\n     */\n    modifier onlyMarketMaker() {\n        require(address(roleManager) != address(0), \"Role manager not set\");\n        require(roleManager.hasRole(roleManager.MARKET_MAKER_ROLE(), msg.sender), \"Requires MARKET_MAKER_ROLE\");\n        _;\n    }\n    \n    /**\n     * @notice Modifier to check market creation limits for tiered members\n     */\n    modifier checkMarketCreationLimit() {\n        if (address(roleManager) != address(0) && roleManager.hasRole(roleManager.MARKET_MAKER_ROLE(), msg.sender)) {\n            require(roleManager.checkMarketCreationLimitFor(msg.sender, roleManager.MARKET_MAKER_ROLE()), \"Market creation limit exceeded\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Get outcome labels for a specific bet type\n     * @param betType The type of bet\n     * @return positiveOutcome Label for the positive outcome token\n     * @return negativeOutcome Label for the negative outcome token\n     */\n    function getOutcomeLabels(BetType betType) public pure returns (string memory positiveOutcome, string memory negativeOutcome) {\n        if (betType == BetType.YesNo) {\n            return (\"YES\", \"NO\");\n        } else if (betType == BetType.PassFail) {\n            return (\"PASS\", \"FAIL\");\n        } else if (betType == BetType.AboveBelow) {\n            return (\"ABOVE\", \"BELOW\");\n        } else if (betType == BetType.HigherLower) {\n            return (\"HIGHER\", \"LOWER\");\n        } else if (betType == BetType.InOut) {\n            return (\"IN\", \"OUT\");\n        } else if (betType == BetType.OverUnder) {\n            return (\"OVER\", \"UNDER\");\n        } else if (betType == BetType.ForAgainst) {\n            return (\"FOR\", \"AGAINST\");\n        } else if (betType == BetType.TrueFalse) {\n            return (\"TRUE\", \"FALSE\");\n        } else if (betType == BetType.WinLose) {\n            return (\"WIN\", \"LOSE\");\n        } else if (betType == BetType.UpDown) {\n            return (\"UP\", \"DOWN\");\n        }\n        return (\"PASS\", \"FAIL\"); // Default fallback\n    }\n\n    /**\n     * @notice Initialize the contract (used for clones)\n     * @param initialOwner Address of the initial owner\n     */\n    function initialize(address initialOwner) external {\n        require(!_initialized, \"Already initialized\");\n        require(initialOwner != address(0), \"Invalid owner\");\n        _initialized = true;\n        _transferOwnership(initialOwner);\n    }\n    \n    /**\n     * @notice Set ETCSwap v3 integration contract\n     * @param _integration Address of ETCSwapV3Integration contract\n     * @param _enabled Whether to enable ETCSwap trading\n     */\n    function setETCSwapIntegration(address _integration, bool _enabled) external onlyOwner {\n        require(_integration != address(0), \"Invalid integration address\");\n        etcSwapIntegration = ETCSwapV3Integration(_integration);\n        useETCSwap = _enabled;\n        emit ETCSwapIntegrationUpdated(_integration, _enabled);\n    }\n    \n    /**\n     * @notice Set CTF1155 contract (required for market creation)\n     * @param _ctf1155 Address of CTF1155 contract\n     */\n    function setCTF1155(address _ctf1155) external onlyOwner {\n        require(_ctf1155 != address(0), \"Invalid CTF1155 address\");\n        ctf1155 = CTF1155(_ctf1155);\n        emit CTF1155Updated(_ctf1155);\n    }\n\n    /**\n     * @notice Set the nullifier registry contract\n     * @param _nullifierRegistry Address of NullifierRegistry contract\n     */\n    function setNullifierRegistry(address _nullifierRegistry) external onlyOwner {\n        require(_nullifierRegistry != address(0), \"Invalid nullifier registry address\");\n        nullifierRegistry = NullifierRegistry(_nullifierRegistry);\n        emit NullifierRegistryUpdated(_nullifierRegistry);\n    }\n\n    /**\n     * @notice Enable or disable on-chain nullification enforcement\n     * @dev When enabled, trading functions will check nullification status\n     *      Frontend always checks regardless of this setting\n     * @param _enforce Whether to enforce nullification checks on-chain\n     */\n    function setNullificationEnforcement(bool _enforce) external onlyOwner {\n        enforceNullificationOnChain = _enforce;\n        emit NullificationEnforcementUpdated(_enforce);\n    }\n\n    /**\n     * @notice Compute the market hash for nullification purposes\n     * @param marketId The market ID\n     * @return marketHash The keccak256 hash of the market's immutable data\n     */\n    function computeMarketHash(uint256 marketId) public view returns (bytes32 marketHash) {\n        require(marketId < marketCount, \"Invalid market ID\");\n        Market storage m = markets[marketId];\n        return keccak256(abi.encodePacked(\n            \"MARKET_V1\",\n            m.proposalId,\n            m.collateralToken,\n            m.conditionId,\n            m.passPositionId,\n            m.failPositionId\n        ));\n    }\n\n    /**\n     * @notice Check if a market is nullified\n     * @param marketId The market ID\n     * @return True if the market is nullified\n     */\n    function isMarketNullified(uint256 marketId) public view returns (bool) {\n        if (address(nullifierRegistry) == address(0)) return false;\n        bytes32 marketHash = computeMarketHash(marketId);\n        return nullifierRegistry.isMarketNullified(marketHash);\n    }\n\n    /**\n     * @notice Modifier to check nullification status when on-chain enforcement is enabled\n     */\n    modifier checkNullification(uint256 marketId) {\n        if (enforceNullificationOnChain && address(nullifierRegistry) != address(0)) {\n            bytes32 marketHash = computeMarketHash(marketId);\n            require(!nullifierRegistry.isMarketNullified(marketHash), \"Market is nullified\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Modifier to check if an address is nullified\n     */\n    modifier checkAddressNullification(address addr) {\n        if (enforceNullificationOnChain && address(nullifierRegistry) != address(0)) {\n            require(!nullifierRegistry.isAddressNullified(addr), \"Address is nullified\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Create ETCSwap pools for an existing market\n     * @param marketId ID of the market\n     * @param initialSqrtPriceX96 Initial price for pools (Q64.96 format)\n     * @param fee Fee tier to use (500, 3000, or 10000)\n     */\n    function createETCSwapPools(\n        uint256 marketId,\n        uint160 initialSqrtPriceX96,\n        uint24 fee\n    ) external onlyOwner {\n        require(marketId < marketCount, \"Invalid market ID\");\n        require(address(etcSwapIntegration) != address(0), \"ETCSwap integration not set\");\n        \n        Market storage market = markets[marketId];\n        \n        (address passPool, address failPool) = etcSwapIntegration.createMarketPools(\n            marketId,\n            market.passToken,\n            market.failToken,\n            market.collateralToken,\n            fee,\n            initialSqrtPriceX96\n        );\n        \n        emit ETCSwapPoolsCreated(marketId, passPool, failPool);\n    }\n\n    /**\n     * @notice Deploy a market pair for a proposal using CTF1155\n     * @param proposalId ID of the proposal\n     * @param collateralToken Address of collateral token (must be ERC20, not address(0))\n     * @param liquidityAmount Initial liquidity amount\n     * @param liquidityParameter Beta parameter for LMSR (higher = more liquidity)\n     * @param tradingPeriod Trading period in seconds\n     * @param betType Type of binary bet (YesNo, PassFail, AboveBelow, etc.)\n     * @return marketId ID of the created market\n     */\n    function deployMarketPair(\n        uint256 proposalId,\n        address collateralToken,\n        uint256 liquidityAmount,\n        uint256 liquidityParameter,\n        uint256 tradingPeriod,\n        BetType betType\n    ) external checkMarketCreationLimit returns (uint256 marketId) {\n        // Allow either owner or market maker role\n        require(\n            msg.sender == owner() || \n            (address(roleManager) != address(0) && roleManager.hasRole(roleManager.MARKET_MAKER_ROLE(), msg.sender)),\n            \"Requires owner or MARKET_MAKER_ROLE\"\n        );\n        require(_proposalToMarketPlusOne[proposalId] == 0, \"Market already exists\");\n        require(tradingPeriod >= MIN_TRADING_PERIOD && tradingPeriod <= MAX_TRADING_PERIOD, \"Invalid trading period\");\n        require(address(ctf1155) != address(0), \"CTF1155 not set\");\n        require(collateralToken != address(0), \"CTF requires ERC20 collateral\");\n\n        marketId = marketCount++;\n\n        // Generate unique question ID for this market\n        bytes32 questionId = keccak256(abi.encodePacked(\"market\", marketId, proposalId, block.timestamp));\n        \n        // Prepare condition with 2 outcomes (binary)\n        bytes32 conditionId = ctf1155.prepareCondition(address(this), questionId, 2);\n        \n        // Calculate position IDs for pass (index 1) and fail (index 2) outcomes\n        bytes32 passCollectionId = ctf1155.getCollectionId(bytes32(0), conditionId, 1);\n        bytes32 failCollectionId = ctf1155.getCollectionId(bytes32(0), conditionId, 2);\n        \n        uint256 passPositionId = ctf1155.getPositionId(IERC20(collateralToken), passCollectionId);\n        uint256 failPositionId = ctf1155.getPositionId(IERC20(collateralToken), failCollectionId);\n        \n        // Store CTF1155 address in passToken and failToken for compatibility\n        address ctfAddress = address(ctf1155);\n\n        markets[marketId] = Market({\n            proposalId: proposalId,\n            passToken: ctfAddress,\n            failToken: ctfAddress,\n            collateralToken: collateralToken,\n            tradingEndTime: block.timestamp + tradingPeriod,\n            liquidityParameter: liquidityParameter,\n            totalLiquidity: liquidityAmount,\n            resolved: false,\n            passValue: 0,\n            failValue: 0,\n            status: MarketStatus.Active,\n            betType: betType,\n            useCTF: true,\n            conditionId: conditionId,\n            questionId: questionId,\n            passPositionId: passPositionId,\n            failPositionId: failPositionId,\n            passQuantity: liquidityParameter,  // Initialize equal for 50/50\n            failQuantity: liquidityParameter   // Initialize equal for 50/50\n        });\n\n        _proposalToMarketPlusOne[proposalId] = marketId + 1;\n        \n        // Update indexes\n        _updateMarketIndex(marketId, MarketStatus.Active);\n\n        emit MarketCreated(\n            marketId,\n            proposalId,\n            collateralToken,\n            ctfAddress,\n            ctfAddress,\n            markets[marketId].tradingEndTime,\n            liquidityParameter,\n            block.timestamp,\n            msg.sender,\n            betType\n        );\n        \n        emit CTFMarketCreated(marketId, conditionId, passPositionId, failPositionId);\n    }\n\n    /**\n     * @notice Deploy a market pair with metadata URI\n     * @param proposalId ID of the proposal\n     * @param collateralToken Address of collateral token (must be ERC20, not address(0))\n     * @param liquidityAmount Initial liquidity amount\n     * @param liquidityParameter Beta parameter for LMSR (higher = more liquidity)\n     * @param tradingPeriod Trading period in seconds\n     * @param betType Type of binary bet (YesNo, PassFail, AboveBelow, etc.)\n     * @param metadataUri IPFS or HTTP URI pointing to market metadata JSON\n     * @return marketId ID of the created market\n     */\n    function deployMarketPairWithMetadata(\n        uint256 proposalId,\n        address collateralToken,\n        uint256 liquidityAmount,\n        uint256 liquidityParameter,\n        uint256 tradingPeriod,\n        BetType betType,\n        string memory metadataUri\n    ) external checkMarketCreationLimit returns (uint256 marketId) {\n        // Allow either owner or market maker role\n        require(\n            msg.sender == owner() ||\n            (address(roleManager) != address(0) && roleManager.hasRole(roleManager.MARKET_MAKER_ROLE(), msg.sender)),\n            \"Requires owner or MARKET_MAKER_ROLE\"\n        );\n        require(_proposalToMarketPlusOne[proposalId] == 0, \"Market already exists\");\n        require(tradingPeriod >= MIN_TRADING_PERIOD && tradingPeriod <= MAX_TRADING_PERIOD, \"Invalid trading period\");\n        require(address(ctf1155) != address(0), \"CTF1155 not set\");\n        require(collateralToken != address(0), \"CTF requires ERC20 collateral\");\n\n        marketId = marketCount++;\n\n        // Generate unique question ID for this market\n        bytes32 questionId = keccak256(abi.encodePacked(\"market\", marketId, proposalId, block.timestamp));\n\n        // Prepare condition with 2 outcomes (binary)\n        bytes32 conditionId = ctf1155.prepareCondition(address(this), questionId, 2);\n\n        // Calculate position IDs for pass (index 1) and fail (index 2) outcomes\n        bytes32 passCollectionId = ctf1155.getCollectionId(bytes32(0), conditionId, 1);\n        bytes32 failCollectionId = ctf1155.getCollectionId(bytes32(0), conditionId, 2);\n\n        uint256 passPositionId = ctf1155.getPositionId(IERC20(collateralToken), passCollectionId);\n        uint256 failPositionId = ctf1155.getPositionId(IERC20(collateralToken), failCollectionId);\n\n        // Store CTF1155 address in passToken and failToken for compatibility\n        address ctfAddress = address(ctf1155);\n\n        markets[marketId] = Market({\n            proposalId: proposalId,\n            passToken: ctfAddress,\n            failToken: ctfAddress,\n            collateralToken: collateralToken,\n            tradingEndTime: block.timestamp + tradingPeriod,\n            liquidityParameter: liquidityParameter,\n            totalLiquidity: liquidityAmount,\n            resolved: false,\n            passValue: 0,\n            failValue: 0,\n            status: MarketStatus.Active,\n            betType: betType,\n            useCTF: true,\n            conditionId: conditionId,\n            questionId: questionId,\n            passPositionId: passPositionId,\n            failPositionId: failPositionId,\n            passQuantity: liquidityParameter,  // Initialize equal for 50/50\n            failQuantity: liquidityParameter   // Initialize equal for 50/50\n        });\n\n        // Store metadata URI\n        marketMetadataUris[marketId] = metadataUri;\n\n        _proposalToMarketPlusOne[proposalId] = marketId + 1;\n\n        // Update indexes\n        _updateMarketIndex(marketId, MarketStatus.Active);\n\n        emit MarketCreated(\n            marketId,\n            proposalId,\n            collateralToken,\n            ctfAddress,\n            ctfAddress,\n            markets[marketId].tradingEndTime,\n            liquidityParameter,\n            block.timestamp,\n            msg.sender,\n            betType\n        );\n\n        emit CTFMarketCreated(marketId, conditionId, passPositionId, failPositionId);\n    }\n\n    /**\n     * @notice Batch deploy multiple market pairs for efficiency\n     * @param params Array of market creation parameters\n     * @return marketIds Array of created market IDs\n     */\n    function batchDeployMarkets(\n        MarketCreationParams[] calldata params\n    ) external checkMarketCreationLimit returns (uint256[] memory marketIds) {\n        // Allow either owner or market maker role\n        require(\n            msg.sender == owner() || \n            (address(roleManager) != address(0) && roleManager.hasRole(roleManager.MARKET_MAKER_ROLE(), msg.sender)),\n            \"Requires owner or MARKET_MAKER_ROLE\"\n        );\n        require(params.length > 0, \"Empty batch\");\n        require(params.length <= MAX_BATCH_SIZE, \"Batch too large\");\n        \n        marketIds = new uint256[](params.length);\n        \n        for (uint256 i = 0; i < params.length; ) {\n            require(_proposalToMarketPlusOne[params[i].proposalId] == 0, \"Market already exists\");\n            require(\n                params[i].tradingPeriod >= MIN_TRADING_PERIOD && \n                params[i].tradingPeriod <= MAX_TRADING_PERIOD,\n                \"Invalid trading period\"\n            );\n            require(address(ctf1155) != address(0), \"CTF1155 not set\");\n            require(params[i].collateralToken != address(0), \"CTF requires ERC20 collateral\");\n            \n            uint256 marketId = marketCount++;\n            marketIds[i] = marketId;\n            \n            // Generate unique question ID for this market\n            bytes32 questionId = keccak256(abi.encodePacked(\"market\", marketId, params[i].proposalId, block.timestamp, i));\n            \n            // Prepare condition with 2 outcomes (binary)\n            bytes32 conditionId = ctf1155.prepareCondition(address(this), questionId, 2);\n            \n            // Calculate position IDs for pass (index 1) and fail (index 2) outcomes\n            bytes32 passCollectionId = ctf1155.getCollectionId(bytes32(0), conditionId, 1);\n            bytes32 failCollectionId = ctf1155.getCollectionId(bytes32(0), conditionId, 2);\n            \n            uint256 passPositionId = ctf1155.getPositionId(IERC20(params[i].collateralToken), passCollectionId);\n            uint256 failPositionId = ctf1155.getPositionId(IERC20(params[i].collateralToken), failCollectionId);\n            \n            // Store CTF1155 address in passToken and failToken for compatibility\n            address ctfAddress = address(ctf1155);\n            \n            markets[marketId] = Market({\n                proposalId: params[i].proposalId,\n                passToken: ctfAddress,\n                failToken: ctfAddress,\n                collateralToken: params[i].collateralToken,\n                tradingEndTime: block.timestamp + params[i].tradingPeriod,\n                liquidityParameter: params[i].liquidityParameter,\n                totalLiquidity: params[i].liquidityAmount,\n                resolved: false,\n                passValue: 0,\n                failValue: 0,\n                status: MarketStatus.Active,\n                betType: params[i].betType,\n                useCTF: true,\n                conditionId: conditionId,\n                questionId: questionId,\n                passPositionId: passPositionId,\n                failPositionId: failPositionId,\n                passQuantity: params[i].liquidityParameter,  // Initialize equal for 50/50\n                failQuantity: params[i].liquidityParameter   // Initialize equal for 50/50\n            });\n            \n            _proposalToMarketPlusOne[params[i].proposalId] = marketId + 1;\n            \n            // Update indexes\n            _updateMarketIndex(marketId, MarketStatus.Active);\n            \n            emit MarketCreated(\n                marketId,\n                params[i].proposalId,\n                params[i].collateralToken,\n                ctfAddress,\n                ctfAddress,\n                markets[marketId].tradingEndTime,\n                params[i].liquidityParameter,\n                block.timestamp,\n                msg.sender,\n                params[i].betType\n            );\n            \n            emit CTFMarketCreated(marketId, conditionId, passPositionId, failPositionId);\n            \n            unchecked { ++i; }\n        }\n        \n        emit BatchMarketsCreated(marketIds, block.timestamp, params.length);\n    }\n\n    /**\n     * @notice Buy outcome tokens via ETCSwap or fallback LMSR\n     * @dev Integrates with ETC Swap v3 when enabled, falls back to simplified LMSR for testing\n     * @param marketId ID of the market\n     * @param buyPass True to buy PASS tokens, false for FAIL tokens\n     * @param amount Amount of collateral to spend\n     * @return tokenAmount Amount of outcome tokens received\n     */\n    function buyTokens(\n        uint256 marketId,\n        bool buyPass,\n        uint256 amount\n    ) external payable nonReentrant checkNullification(marketId) checkAddressNullification(msg.sender) returns (uint256 tokenAmount) {\n        require(marketId < marketCount, \"Invalid market ID\");\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.Active, \"Market not active\");\n        require(block.timestamp < market.tradingEndTime, \"Trading period ended\");\n        require(amount > 0, \"Amount must be positive\");\n\n        if (useETCSwap && address(etcSwapIntegration) != address(0)) {\n            // Use ETCSwap v3 for actual DEX trading with ERC20 collateral\n            address outcomeToken = buyPass ? market.passToken : market.failToken;\n            \n            // When using ETCSwap, collateral must be an ERC20 token\n            require(market.collateralToken != address(0), \"ETCSwap requires ERC20 collateral\");\n            require(msg.value == 0, \"Send collateral tokens, not ETH\");\n            \n            // Transfer collateral from buyer to this contract\n            IERC20(market.collateralToken).safeTransferFrom(msg.sender, address(this), amount);\n            \n            // Approve ETCSwap integration to spend collateral (using forceApprove for safety)\n            IERC20(market.collateralToken).forceApprove(address(etcSwapIntegration), amount);\n            \n            // Calculate minimum output with slippage protection\n            // Use quoter to estimate output and apply default slippage tolerance\n            try etcSwapIntegration.quoteBuyTokens(marketId, buyPass, amount) returns (uint256 estimatedOutput) {\n                // Apply more conservative slippage tolerance (10% for testing with mocks)\n                uint256 minTokenAmount = etcSwapIntegration.calculateMinOutput(estimatedOutput, 1000);\n                \n                // Execute swap with slippage protection\n                ETCSwapV3Integration.SwapResult memory result = etcSwapIntegration.buyTokens(\n                    marketId,\n                    market.collateralToken,\n                    outcomeToken,\n                    amount,\n                    minTokenAmount,\n                    block.timestamp + 300 // 5 minute deadline\n                );\n                \n                tokenAmount = result.amountOut;\n                \n                // Transfer purchased tokens from this contract to the buyer\n                // (ETCSwap sends tokens to this contract, we forward to buyer)\n                IERC20(outcomeToken).safeTransfer(msg.sender, tokenAmount);\n            } catch {\n                // If quote fails, use conservative minimum (allow up to 20% slippage for edge cases)\n                uint256 minTokenAmount = (amount * 80) / 100;\n                \n                ETCSwapV3Integration.SwapResult memory result = etcSwapIntegration.buyTokens(\n                    marketId,\n                    market.collateralToken,\n                    outcomeToken,\n                    amount,\n                    minTokenAmount,\n                    block.timestamp + 300\n                );\n                \n                tokenAmount = result.amountOut;\n                \n                // Transfer purchased tokens from this contract to the buyer\n                IERC20(outcomeToken).safeTransfer(msg.sender, tokenAmount);\n            }\n        } else {\n            // Fallback: Use CTF1155 to split collateral into position tokens\n            // With CTF1155, all markets require ERC20 collateral\n            require(market.collateralToken != address(0), \"CTF requires ERC20 collateral\");\n            require(msg.value == 0, \"Send collateral tokens, not ETH\");\n            \n            // Transfer collateral from buyer to this contract\n            IERC20(market.collateralToken).safeTransferFrom(msg.sender, address(this), amount);\n            \n            // Approve CTF1155 to spend collateral (using forceApprove for safety)\n            IERC20(market.collateralToken).forceApprove(address(ctf1155), amount);\n            \n            // Split collateral into BOTH position tokens (binary market)\n            // CTF1155 requires partition with at least 2 elements\n            // For binary conditions: index set 1 = outcome 0, index set 2 = outcome 1\n            uint256[] memory partition = new uint256[](2);\n            partition[0] = 1; // PASS outcome index set\n            partition[1] = 2; // FAIL outcome index set\n            \n            ctf1155.splitPosition(\n                IERC20(market.collateralToken),\n                bytes32(0), // parentCollectionId (root level)\n                market.conditionId,\n                partition,\n                amount\n            );\n            \n            // Calculate output tokens (1:1 with collateral for split)\n            tokenAmount = amount;\n            \n            // Transfer the requested position tokens to buyer\n            // CTF splits to this contract, so we transfer the desired position to buyer\n            ctf1155.safeTransferFrom(\n                address(this),\n                msg.sender,\n                buyPass ? market.passPositionId : market.failPositionId,\n                tokenAmount,\n                \"\"\n            );\n            \n            // Store the other position tokens in this contract for later merging/redemption\n            // (They stay in this contract's balance)\n\n            // Update market liquidity and quantities for LMSR pricing\n            market.totalLiquidity += amount;\n            if (buyPass) {\n                market.passQuantity += amount;\n            } else {\n                market.failQuantity += amount;\n            }\n        }\n\n        emit TokensPurchased(marketId, msg.sender, buyPass, amount, tokenAmount);\n    }\n    \n    /**\n     * @notice Sell outcome tokens via ETCSwap or fallback LMSR\n     * @dev Integrates with ETC Swap v3 when enabled, falls back to simplified LMSR for testing\n     * @param marketId ID of the market\n     * @param sellPass True to sell PASS tokens, false for FAIL tokens\n     * @param tokenAmount Amount of tokens to sell\n     * @return collateralAmount Amount of collateral received\n     */\n    function sellTokens(\n        uint256 marketId,\n        bool sellPass,\n        uint256 tokenAmount\n    ) external nonReentrant checkNullification(marketId) checkAddressNullification(msg.sender) returns (uint256 collateralAmount) {\n        require(marketId < marketCount, \"Invalid market ID\");\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.Active, \"Market not active\");\n        require(block.timestamp < market.tradingEndTime, \"Trading period ended\");\n        require(tokenAmount > 0, \"Amount must be positive\");\n\n        if (useETCSwap && address(etcSwapIntegration) != address(0)) {\n            // Use ETCSwap v3 for actual DEX trading with ERC20 collateral\n            address outcomeToken = sellPass ? market.passToken : market.failToken;\n            \n            // When using ETCSwap, collateral must be an ERC20 token\n            require(market.collateralToken != address(0), \"ETCSwap requires ERC20 collateral\");\n            \n            // Transfer tokens from seller to this contract\n            IERC20(outcomeToken).safeTransferFrom(msg.sender, address(this), tokenAmount);\n            \n            // Approve ETCSwap integration to spend outcome tokens (using forceApprove for safety)\n            IERC20(outcomeToken).forceApprove(address(etcSwapIntegration), tokenAmount);\n            \n            // Calculate minimum output with slippage protection\n            // Use quoter to estimate output and apply default slippage tolerance\n            try etcSwapIntegration.quoteSellTokens(marketId, sellPass, tokenAmount) returns (uint256 estimatedOutput) {\n                // Apply more conservative slippage tolerance (10% for testing with mocks)\n                uint256 minCollateralAmount = etcSwapIntegration.calculateMinOutput(estimatedOutput, 1000);\n                \n                // Execute swap with slippage protection\n                ETCSwapV3Integration.SwapResult memory result = etcSwapIntegration.sellTokens(\n                    marketId,\n                    outcomeToken,\n                    market.collateralToken,\n                    tokenAmount,\n                    minCollateralAmount,\n                    block.timestamp + 300 // 5 minute deadline\n                );\n                \n                collateralAmount = result.amountOut;\n            } catch {\n                // If quote fails, use conservative minimum (allow up to 20% slippage for edge cases)\n                uint256 minCollateralAmount = (tokenAmount * 80) / 100;\n                \n                ETCSwapV3Integration.SwapResult memory result = etcSwapIntegration.sellTokens(\n                    marketId,\n                    outcomeToken,\n                    market.collateralToken,\n                    tokenAmount,\n                    minCollateralAmount,\n                    block.timestamp + 300\n                );\n                \n                collateralAmount = result.amountOut;\n            }\n            \n            // Transfer collateral to seller\n            IERC20(market.collateralToken).safeTransfer(msg.sender, collateralAmount);\n        } else {\n            // Fallback: Use CTF1155 to merge position tokens back to collateral\n            // With CTF1155, all markets require ERC20 collateral\n            require(market.collateralToken != address(0), \"CTF requires ERC20 collateral\");\n            \n            // For selling, user must have BOTH position tokens to merge back to collateral\n            // This is a simplified version - in production, you'd implement a proper AMM\n            // For now, we require the contract to hold the opposite position\n            uint256 oppositePositionId = sellPass ? market.failPositionId : market.passPositionId;\n            uint256 oppositeBalance = ctf1155.balanceOf(address(this), oppositePositionId);\n            \n            require(oppositeBalance >= tokenAmount, \"Insufficient opposite position for merge\");\n            \n            // Transfer the position tokens being sold from user to this contract\n            ctf1155.safeTransferFrom(\n                msg.sender,\n                address(this),\n                sellPass ? market.passPositionId : market.failPositionId,\n                tokenAmount,\n                \"\"\n            );\n            \n            // Merge both positions back to collateral\n            // CTF1155 requires partition with at least 2 elements\n            // For binary conditions: index set 1 = outcome 0, index set 2 = outcome 1\n            uint256[] memory partition = new uint256[](2);\n            partition[0] = 1; // PASS outcome index set\n            partition[1] = 2; // FAIL outcome index set\n            \n            ctf1155.mergePositions(\n                IERC20(market.collateralToken),\n                bytes32(0), // parentCollectionId (root level)\n                market.conditionId,\n                partition,\n                tokenAmount\n            );\n            \n            // Calculate collateral amount (1:1 for merge)\n            collateralAmount = tokenAmount;\n\n            // Transfer collateral back to seller\n            IERC20(market.collateralToken).safeTransfer(msg.sender, collateralAmount);\n\n            // Update market liquidity and quantities for LMSR pricing\n            require(collateralAmount <= market.totalLiquidity, \"Insufficient liquidity\");\n            market.totalLiquidity -= collateralAmount;\n            if (sellPass) {\n                require(collateralAmount <= market.passQuantity, \"Insufficient pass quantity\");\n                market.passQuantity -= collateralAmount;\n            } else {\n                require(collateralAmount <= market.failQuantity, \"Insufficient fail quantity\");\n                market.failQuantity -= collateralAmount;\n            }\n        }\n\n        emit TokensSold(marketId, msg.sender, sellPass, tokenAmount, collateralAmount);\n    }\n\n    /**\n     * @notice End trading for a market\n     * @param marketId ID of the market\n     */\n    function endTrading(uint256 marketId) external onlyOwner {\n        require(marketId < marketCount, \"Invalid market ID\");\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.Active, \"Market not active\");\n        require(block.timestamp >= market.tradingEndTime, \"Trading period not ended\");\n\n        MarketStatus oldStatus = market.status;\n        market.status = MarketStatus.TradingEnded;\n        _updateMarketIndex(marketId, MarketStatus.TradingEnded);\n        \n        emit MarketStatusChanged(marketId, oldStatus, MarketStatus.TradingEnded, block.timestamp);\n    }\n\n    /**\n     * @notice Resolve a market with welfare metric values and report to CTF1155\n     * @param marketId ID of the market\n     * @param passValue Welfare metric value if proposal passes\n     * @param failValue Welfare metric value if proposal fails\n     */\n    function resolveMarket(\n        uint256 marketId,\n        uint256 passValue,\n        uint256 failValue\n    ) external onlyOwner nonReentrant {\n        require(marketId < marketCount, \"Invalid market ID\");\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.TradingEnded, \"Trading not ended\");\n        require(!market.resolved, \"Already resolved\");\n\n        market.resolved = true;\n        market.passValue = passValue;\n        market.failValue = failValue;\n        MarketStatus oldStatus = market.status;\n        market.status = MarketStatus.Resolved;\n        _updateMarketIndex(marketId, MarketStatus.Resolved);\n        \n        // Report payouts to CTF1155\n        if (market.useCTF) {\n            // Calculate payout numerators based on welfare metric values\n            uint256[] memory payouts = new uint256[](2);\n            \n            // Determine winner and set payouts\n            if (passValue > failValue) {\n                // Pass wins - full payout to pass (index 0), zero to fail (index 1)\n                payouts[0] = 1;\n                payouts[1] = 0;\n            } else if (failValue > passValue) {\n                // Fail wins - zero to pass (index 0), full payout to fail (index 1)\n                payouts[0] = 0;\n                payouts[1] = 1;\n            } else {\n                // Tie - equal payout to both\n                payouts[0] = 1;\n                payouts[1] = 1;\n            }\n            \n            // Report payouts to CTF1155 as the oracle (this contract)\n            ctf1155.reportPayouts(market.questionId, payouts);\n        }\n\n        emit MarketResolved(\n            marketId,\n            market.proposalId,\n            passValue,\n            failValue,\n            passValue > failValue,\n            block.timestamp\n        );\n        emit MarketStatusChanged(marketId, oldStatus, MarketStatus.Resolved, block.timestamp);\n    }\n    \n    /**\n     * @notice Batch resolve multiple markets for efficiency\n     * @param params Array of market resolution parameters\n     * @return results Array indicating success/failure for each resolution\n     */\n    function batchResolveMarkets(\n        MarketResolutionParams[] calldata params\n    ) external onlyOwner nonReentrant returns (bool[] memory results) {\n        require(params.length > 0, \"Empty batch\");\n        require(params.length <= MAX_BATCH_SIZE, \"Batch too large\");\n        \n        results = new bool[](params.length);\n        uint256[] memory resolvedIds = new uint256[](params.length);\n        uint256 successCount = 0;\n        \n        for (uint256 i = 0; i < params.length; ) {\n            uint256 marketId = params[i].marketId;\n            \n            // Validate market\n            if (marketId >= marketCount) {\n                results[i] = false;\n                unchecked { ++i; }\n                continue;\n            }\n            \n            Market storage market = markets[marketId];\n            \n            if (market.status != MarketStatus.TradingEnded || market.resolved) {\n                results[i] = false;\n                unchecked { ++i; }\n                continue;\n            }\n            \n            // Resolve market\n            market.resolved = true;\n            market.passValue = params[i].passValue;\n            market.failValue = params[i].failValue;\n            MarketStatus oldStatus = market.status;\n            market.status = MarketStatus.Resolved;\n            _updateMarketIndex(marketId, MarketStatus.Resolved);\n            \n            // Report payouts to CTF1155\n            if (market.useCTF) {\n                uint256[] memory payouts = new uint256[](2);\n                \n                if (params[i].passValue > params[i].failValue) {\n                    payouts[0] = 1;\n                    payouts[1] = 0;\n                } else if (params[i].failValue > params[i].passValue) {\n                    payouts[0] = 0;\n                    payouts[1] = 1;\n                } else {\n                    payouts[0] = 1;\n                    payouts[1] = 1;\n                }\n                \n                ctf1155.reportPayouts(market.questionId, payouts);\n            }\n            \n            emit MarketResolved(\n                marketId,\n                market.proposalId,\n                params[i].passValue,\n                params[i].failValue,\n                params[i].passValue > params[i].failValue,\n                block.timestamp\n            );\n            emit MarketStatusChanged(marketId, oldStatus, MarketStatus.Resolved, block.timestamp);\n            \n            resolvedIds[successCount] = marketId;\n            results[i] = true;\n            unchecked {\n                ++successCount;\n                ++i;\n            }\n        }\n        \n        // Emit batch event with only successful resolutions\n        if (successCount > 0) {\n            uint256[] memory successfulIds = new uint256[](successCount);\n            for (uint256 j = 0; j < successCount; ) {\n                successfulIds[j] = resolvedIds[j];\n                unchecked { ++j; }\n            }\n            emit BatchMarketsResolved(successfulIds, block.timestamp, successCount);\n        }\n    }\n\n    /**\n     * @notice Cancel a market\n     * @param marketId ID of the market\n     */\n    function cancelMarket(uint256 marketId) external onlyOwner {\n        cancelMarketWithReason(marketId, \"Cancelled by owner\");\n    }\n    \n    /**\n     * @notice Cancel a market with reason\n     * @param marketId ID of the market\n     * @param reason Cancellation reason\n     */\n    function cancelMarketWithReason(uint256 marketId, string memory reason) public onlyOwner {\n        require(marketId < marketCount, \"Invalid market ID\");\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.Active, \"Market not active\");\n\n        MarketStatus oldStatus = market.status;\n        market.status = MarketStatus.Cancelled;\n        _updateMarketIndex(marketId, MarketStatus.Cancelled);\n        \n        emit MarketCancelled(marketId, market.proposalId, reason, block.timestamp);\n        emit MarketStatusChanged(marketId, oldStatus, MarketStatus.Cancelled, block.timestamp);\n    }\n\n    /**\n     * @notice Get market details\n     * @param marketId ID of the market\n     */\n    function getMarket(uint256 marketId) external view returns (Market memory) {\n        require(marketId < marketCount, \"Invalid market ID\");\n        return markets[marketId];\n    }\n\n    /**\n     * @notice Get current prices for a market based on LMSR quantities\n     * @dev Uses simplified LMSR: price = quantity / total_quantity\n     *      Prices are returned in 18 decimal precision (1e18 = 1.0 = 100%)\n     * @param marketId ID of the market\n     * @return passPrice Price of PASS token (probability of pass outcome)\n     * @return failPrice Price of FAIL token (probability of fail outcome)\n     */\n    function getPrices(uint256 marketId) external view returns (uint256 passPrice, uint256 failPrice) {\n        require(marketId < marketCount, \"Invalid market ID\");\n        Market storage market = markets[marketId];\n\n        uint256 totalQuantity = market.passQuantity + market.failQuantity;\n\n        // Prevent division by zero - return 50/50 if no quantity\n        if (totalQuantity == 0) {\n            return (0.5e18, 0.5e18);\n        }\n\n        // Calculate prices in 18 decimal precision\n        // price = quantity * 1e18 / totalQuantity\n        passPrice = (market.passQuantity * 1e18) / totalQuantity;\n        failPrice = (market.failQuantity * 1e18) / totalQuantity;\n\n        return (passPrice, failPrice);\n    }\n\n    /**\n     * @notice Estimate how many tokens you'll receive for a given collateral amount\n     * @dev For CTF1155 markets, tokens are 1:1 with collateral (split operation)\n     * @param marketId ID of the market\n     * @param buyPass True to estimate PASS tokens, false for FAIL tokens\n     * @param collateralAmount Amount of collateral to spend\n     * @return tokenAmount Estimated tokens to receive\n     */\n    function getTokenAmount(\n        uint256 marketId,\n        bool buyPass,\n        uint256 collateralAmount\n    ) external view returns (uint256 tokenAmount) {\n        require(marketId < marketCount, \"Invalid market ID\");\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.Active, \"Market not active\");\n\n        // For CTF1155 markets using split operation, tokens are 1:1 with collateral\n        // This is a simplified model - true LMSR would use the cost function\n        tokenAmount = collateralAmount;\n\n        return tokenAmount;\n    }\n\n    /**\n     * @notice Get metadata URI for a market\n     * @param marketId ID of the market\n     * @return uri The metadata URI (IPFS or HTTP)\n     */\n    function getMarketMetadataUri(uint256 marketId) external view returns (string memory uri) {\n        require(marketId < marketCount, \"Invalid market ID\");\n        return marketMetadataUris[marketId];\n    }\n\n    /**\n     * @notice Set metadata URI for a market (only owner)\n     * @param marketId ID of the market\n     * @param uri The metadata URI (IPFS or HTTP)\n     */\n    function setMarketMetadataUri(uint256 marketId, string memory uri) external onlyOwner {\n        require(marketId < marketCount, \"Invalid market ID\");\n        marketMetadataUris[marketId] = uri;\n    }\n\n    /**\n     * @notice Get market for a proposal\n     * @param proposalId ID of the proposal\n     */\n    function getMarketForProposal(uint256 proposalId) external view returns (uint256) {\n        uint256 marketIdPlusOne = _proposalToMarketPlusOne[proposalId];\n        require(marketIdPlusOne > 0, \"No market for proposal\");\n        return marketIdPlusOne - 1;\n    }\n    \n    /**\n     * @notice Check if a proposal has a market\n     * @param proposalId ID of the proposal\n     * @return bool True if market exists\n     */\n    function hasMarketForProposal(uint256 proposalId) external view returns (bool) {\n        return _proposalToMarketPlusOne[proposalId] > 0;\n    }\n    \n    /**\n     * @notice Get active markets with pagination\n     * @param offset Starting index\n     * @param limit Maximum results to return\n     * @return marketIds Array of market IDs\n     * @return hasMore Whether more results exist\n     */\n    function getActiveMarkets(\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory marketIds, bool hasMore) {\n        return getMarketsByStatus(MarketStatus.Active, offset, limit);\n    }\n    \n    /**\n     * @notice Get markets by status with pagination\n     * @param status Market status to filter by\n     * @param offset Starting index\n     * @param limit Maximum results\n     * @return marketIds Array of market IDs\n     * @return hasMore Whether more results exist\n     */\n    function getMarketsByStatus(\n        MarketStatus status,\n        uint256 offset,\n        uint256 limit\n    ) public view returns (uint256[] memory marketIds, bool hasMore) {\n        uint256[] storage statusMarkets = marketsByStatus[status];\n        uint256 totalCount = statusMarkets.length;\n        \n        if (offset >= totalCount) {\n            return (new uint256[](0), false);\n        }\n        \n        uint256 resultCount = totalCount - offset;\n        if (resultCount > limit) {\n            resultCount = limit;\n            hasMore = true;\n        } else {\n            hasMore = false;\n        }\n        \n        marketIds = new uint256[](resultCount);\n        for (uint256 i = 0; i < resultCount; ) {\n            marketIds[i] = statusMarkets[offset + i];\n            unchecked { ++i; }\n        }\n    }\n    \n    /**\n     * @notice Get markets by date range\n     * @param startTime Start timestamp\n     * @param endTime End timestamp\n     * @param offset Starting index\n     * @param limit Maximum results\n     * @return marketIds Array of market IDs in range\n     * @return hasMore Whether more results exist\n     */\n    function getMarketsByDateRange(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory marketIds, bool hasMore) {\n        require(startTime < endTime, \"Invalid date range\");\n        \n        uint256 startDay = startTime / 1 days;\n        uint256 endDay = endTime / 1 days;\n        \n        // Collect market IDs from all days in range\n        uint256 totalCount = 0;\n        for (uint256 day = startDay; day <= endDay; ) {\n            totalCount += marketsByDay[day].length;\n            unchecked { ++day; }\n        }\n        \n        if (offset >= totalCount) {\n            return (new uint256[](0), false);\n        }\n        \n        uint256 resultCount = totalCount - offset;\n        if (resultCount > limit) {\n            resultCount = limit;\n            hasMore = true;\n        } else {\n            hasMore = false;\n        }\n        \n        marketIds = new uint256[](resultCount);\n        uint256 currentIndex = 0;\n        uint256 skipCount = offset;\n        \n        for (uint256 day = startDay; day <= endDay && currentIndex < resultCount; ) {\n            uint256[] storage dayMarkets = marketsByDay[day];\n            \n            for (uint256 i = 0; i < dayMarkets.length && currentIndex < resultCount; ) {\n                if (skipCount > 0) {\n                    unchecked { --skipCount; }\n                } else {\n                    marketIds[currentIndex] = dayMarkets[i];\n                    unchecked { ++currentIndex; }\n                }\n                unchecked { ++i; }\n            }\n            unchecked { ++day; }\n        }\n    }\n    \n    /**\n     * @notice Get total count of markets by status\n     * @param status Market status\n     * @return count Number of markets with given status\n     */\n    function getMarketCountByStatus(MarketStatus status) external view returns (uint256) {\n        return marketsByStatus[status].length;\n    }\n    \n    /**\n     * @notice Internal function to update market indexes\n     * @param marketId Market ID\n     * @param newStatus New market status\n     */\n    function _updateMarketIndex(uint256 marketId, MarketStatus newStatus) internal {\n        // Add to status index\n        marketsByStatus[newStatus].push(marketId);\n        \n        // Add to time-based index\n        uint256 day = block.timestamp / 1 days;\n        marketsByDay[day].push(marketId);\n    }\n    \n    /**\n     * @notice Struct for batch market creation parameters\n     */\n    struct MarketCreationParams {\n        uint256 proposalId;\n        address collateralToken;\n        uint256 liquidityAmount;\n        uint256 liquidityParameter;\n        uint256 tradingPeriod;\n        BetType betType;\n    }\n    \n    /**\n     * @notice Struct for batch market resolution parameters\n     */\n    struct MarketResolutionParams {\n        uint256 marketId;\n        uint256 passValue;\n        uint256 failValue;\n    }\n\n    /**\n     * @notice Handle the receipt of a single ERC1155 token type\n     * @dev Required by IERC1155Receiver to accept ERC1155 tokens\n     */\n    function onERC1155Received(\n        address /* operator */,\n        address /* from */,\n        uint256 /* id */,\n        uint256 /* value */,\n        bytes calldata /* data */\n    ) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @notice Handle the receipt of multiple ERC1155 token types\n     * @dev Required by IERC1155Receiver to accept batch ERC1155 token transfers\n     */\n    function onERC1155BatchReceived(\n        address /* operator */,\n        address /* from */,\n        uint256[] calldata /* ids */,\n        uint256[] calldata /* values */,\n        bytes calldata /* data */\n    ) external pure returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @notice Check if contract supports an interface\n     * @dev Required by IERC165 (inherited by IERC1155Receiver)\n     */\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId ||\n               interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @title ConditionalToken\n * @notice Simplified conditional token implementation\n * @dev In production, use Gnosis Conditional Token Framework\n */\ncontract ConditionalToken is IERC20 {\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n    uint256 private _totalSupply;\n    \n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address to, uint256 amount) external override returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) external override returns (bool) {\n        _spendAllowance(from, msg.sender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function mint(address to, uint256 amount) external {\n        _totalSupply += amount;\n        _balances[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    function burn(address from, uint256 amount) external {\n        require(_balances[from] >= amount, \"Insufficient balance\");\n        _balances[from] -= amount;\n        _totalSupply -= amount;\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal {\n        require(from != address(0), \"Transfer from zero address\");\n        require(to != address(0), \"Transfer to zero address\");\n        require(_balances[from] >= amount, \"Insufficient balance\");\n\n        _balances[from] -= amount;\n        _balances[to] += amount;\n        emit Transfer(from, to, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"Approve from zero address\");\n        require(spender != address(0), \"Approve to zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _spendAllowance(address owner, address spender, uint256 amount) internal {\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= amount, \"Insufficient allowance\");\n        _approve(owner, spender, currentAllowance - amount);\n    }\n}\n"
    },
    "contracts/markets/CTF1155.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title CTF1155 - Conditional Token Framework using ERC1155\n * @notice Gas-efficient conditional tokens based on Gnosis CTF standard\n * @dev Implements ERC1155 multi-token standard for conditional outcomes\n * \n * Key features:\n * - Gas efficient transfers using ERC1155 batch operations\n * - Combinatorial outcomes support (A AND B, A OR B, etc.)\n * - Position splitting and merging\n * - Multiple collateral token support\n * - Deep vs shallow position management\n * \n * Based on: https://github.com/gnosis/conditional-tokens-contracts\n */\ncontract CTF1155 is ERC1155, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice Emitted when a condition is prepared\n    event ConditionPreparation(\n        bytes32 indexed conditionId,\n        address indexed oracle,\n        bytes32 indexed questionId,\n        uint256 outcomeSlotCount\n    );\n\n    /// @notice Emitted when a condition is resolved\n    event ConditionResolution(\n        bytes32 indexed conditionId,\n        address indexed oracle,\n        bytes32 indexed questionId,\n        uint256 outcomeSlotCount,\n        uint256[] payoutNumerators\n    );\n\n    /// @notice Emitted when positions are split\n    event PositionSplit(\n        address indexed stakeholder,\n        IERC20 collateralToken,\n        bytes32 indexed parentCollectionId,\n        bytes32 indexed conditionId,\n        uint256[] partition,\n        uint256 amount\n    );\n\n    /// @notice Emitted when positions are merged\n    event PositionsMerge(\n        address indexed stakeholder,\n        IERC20 collateralToken,\n        bytes32 indexed parentCollectionId,\n        bytes32 indexed conditionId,\n        uint256[] partition,\n        uint256 amount\n    );\n\n    /// @notice Emitted when positions are redeemed\n    event PayoutRedemption(\n        address indexed redeemer,\n        IERC20 indexed collateralToken,\n        bytes32 indexed parentCollectionId,\n        bytes32 conditionId,\n        uint256[] indexSets,\n        uint256 payout\n    );\n\n    /// @notice Condition information\n    struct Condition {\n        address oracle;\n        bytes32 questionId;\n        uint256 outcomeSlotCount;\n        uint256[] payoutNumerators;\n        uint256 payoutDenominator;\n        bool resolved;\n    }\n\n    /// @notice Mapping from conditionId to Condition data\n    mapping(bytes32 => Condition) private _conditions;\n\n    /// @notice Mapping from collectionId to position data\n    mapping(bytes32 => uint256) public collectionIds;\n\n    constructor() ERC1155(\"\") Ownable(msg.sender) {}\n\n    /**\n     * @notice Prepare a condition for binary or multi-outcome predictions\n     * @param oracle Address that can report the outcome\n     * @param questionId Unique identifier for the question\n     * @param outcomeSlotCount Number of possible outcomes (2 for binary)\n     * @return conditionId Unique identifier for this condition\n     */\n    function prepareCondition(\n        address oracle,\n        bytes32 questionId,\n        uint256 outcomeSlotCount\n    ) external returns (bytes32 conditionId) {\n        require(outcomeSlotCount > 1, \"At least 2 outcomes required\");\n        require(outcomeSlotCount <= 256, \"Too many outcomes\");\n\n        conditionId = keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount));\n        \n        require(_conditions[conditionId].oracle == address(0), \"Condition already prepared\");\n\n        Condition storage condition = _conditions[conditionId];\n        condition.oracle = oracle;\n        condition.questionId = questionId;\n        condition.outcomeSlotCount = outcomeSlotCount;\n        condition.resolved = false;\n        condition.payoutDenominator = 0;\n\n        emit ConditionPreparation(conditionId, oracle, questionId, outcomeSlotCount);\n    }\n\n    /**\n     * @notice Report the payout for a condition\n     * @param questionId Question identifier\n     * @param payouts Array of payout numerators for each outcome\n     */\n    function reportPayouts(bytes32 questionId, uint256[] calldata payouts) external {\n        uint256 outcomeSlotCount = payouts.length;\n        bytes32 conditionId = keccak256(\n            abi.encodePacked(msg.sender, questionId, outcomeSlotCount)\n        );\n\n        Condition storage condition = _conditions[conditionId];\n        require(condition.oracle == msg.sender, \"Not the oracle\");\n        require(!condition.resolved, \"Already resolved\");\n        require(payouts.length == condition.outcomeSlotCount, \"Invalid payout array length\");\n\n        uint256 den = 0;\n        for (uint256 i = 0; i < payouts.length; i++) {\n            den += payouts[i];\n        }\n        require(den > 0, \"Payout denominator must be positive\");\n\n        condition.payoutNumerators = payouts;\n        condition.payoutDenominator = den;\n        condition.resolved = true;\n\n        emit ConditionResolution(\n            conditionId,\n            msg.sender,\n            questionId,\n            outcomeSlotCount,\n            payouts\n        );\n    }\n\n    /**\n     * @notice Split collateral into conditional tokens\n     * @param collateralToken ERC20 token used as collateral\n     * @param parentCollectionId Collection ID for deep positions (0x0 for base)\n     * @param conditionId Condition identifier\n     * @param partition Array of outcome index sets to split into\n     * @param amount Amount of collateral to split\n     */\n    function splitPosition(\n        IERC20 collateralToken,\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256[] calldata partition,\n        uint256 amount\n    ) external nonReentrant {\n        require(amount > 0, \"Amount must be positive\");\n        require(partition.length > 1, \"Partition must have at least 2 parts\");\n\n        Condition storage condition = _conditions[conditionId];\n        require(condition.oracle != address(0), \"Condition not prepared\");\n        require(!condition.resolved, \"Condition already resolved\");\n\n        // Validate partition\n        uint256 fullIndexSet = (1 << condition.outcomeSlotCount) - 1;\n        uint256 freeIndexSet = fullIndexSet;\n        for (uint256 i = 0; i < partition.length; i++) {\n            require(partition[i] > 0, \"Invalid partition\");\n            require(partition[i] & freeIndexSet == partition[i], \"Partition overlap\");\n            freeIndexSet ^= partition[i];\n        }\n\n        // Transfer collateral from user\n        collateralToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Mint conditional tokens for each partition\n        uint256[] memory ids = new uint256[](partition.length);\n        uint256[] memory amounts = new uint256[](partition.length);\n        \n        for (uint256 i = 0; i < partition.length; i++) {\n            bytes32 collectionId = getCollectionId(parentCollectionId, conditionId, partition[i]);\n            uint256 positionId = getPositionId(collateralToken, collectionId);\n            \n            ids[i] = positionId;\n            amounts[i] = amount;\n        }\n\n        _mintBatch(msg.sender, ids, amounts, \"\");\n\n        emit PositionSplit(\n            msg.sender,\n            collateralToken,\n            parentCollectionId,\n            conditionId,\n            partition,\n            amount\n        );\n    }\n\n    /**\n     * @notice Merge conditional tokens back into collateral\n     * @param collateralToken ERC20 token used as collateral\n     * @param parentCollectionId Collection ID for deep positions\n     * @param conditionId Condition identifier\n     * @param partition Array of outcome index sets to merge\n     * @param amount Amount to merge\n     */\n    function mergePositions(\n        IERC20 collateralToken,\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256[] calldata partition,\n        uint256 amount\n    ) external nonReentrant {\n        require(amount > 0, \"Amount must be positive\");\n        require(partition.length > 1, \"Partition must have at least 2 parts\");\n\n        // Burn conditional tokens for each partition\n        uint256[] memory ids = new uint256[](partition.length);\n        uint256[] memory amounts = new uint256[](partition.length);\n        \n        for (uint256 i = 0; i < partition.length; i++) {\n            bytes32 collectionId = getCollectionId(parentCollectionId, conditionId, partition[i]);\n            uint256 positionId = getPositionId(collateralToken, collectionId);\n            \n            ids[i] = positionId;\n            amounts[i] = amount;\n        }\n\n        _burnBatch(msg.sender, ids, amounts);\n\n        // Return collateral to user\n        collateralToken.safeTransfer(msg.sender, amount);\n\n        emit PositionsMerge(\n            msg.sender,\n            collateralToken,\n            parentCollectionId,\n            conditionId,\n            partition,\n            amount\n        );\n    }\n\n    /**\n     * @notice Redeem positions for resolved condition\n     * @param collateralToken ERC20 token used as collateral\n     * @param parentCollectionId Collection ID\n     * @param conditionId Condition identifier\n     * @param indexSets Array of index sets to redeem\n     */\n    function redeemPositions(\n        IERC20 collateralToken,\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256[] calldata indexSets\n    ) external nonReentrant {\n        Condition storage condition = _conditions[conditionId];\n        require(condition.resolved, \"Condition not resolved\");\n\n        uint256 totalPayout = 0;\n        uint256[] memory ids = new uint256[](indexSets.length);\n        uint256[] memory amounts = new uint256[](indexSets.length);\n\n        for (uint256 i = 0; i < indexSets.length; i++) {\n            bytes32 collectionId = getCollectionId(parentCollectionId, conditionId, indexSets[i]);\n            uint256 positionId = getPositionId(collateralToken, collectionId);\n            uint256 balance = balanceOf(msg.sender, positionId);\n\n            require(balance > 0, \"No balance to redeem\");\n\n            // Calculate payout for this index set\n            uint256 payoutNumerator = 0;\n            for (uint256 j = 0; j < condition.outcomeSlotCount; j++) {\n                if (indexSets[i] & (1 << j) != 0) {\n                    payoutNumerator += condition.payoutNumerators[j];\n                }\n            }\n\n            uint256 payout = (balance * payoutNumerator) / condition.payoutDenominator;\n            totalPayout += payout;\n\n            ids[i] = positionId;\n            amounts[i] = balance;\n        }\n\n        // Burn redeemed positions\n        _burnBatch(msg.sender, ids, amounts);\n\n        // Transfer payout\n        if (totalPayout > 0) {\n            collateralToken.safeTransfer(msg.sender, totalPayout);\n        }\n\n        emit PayoutRedemption(\n            msg.sender,\n            collateralToken,\n            parentCollectionId,\n            conditionId,\n            indexSets,\n            totalPayout\n        );\n    }\n\n    /**\n     * @notice Get collection ID for a condition and index set\n     * @param parentCollectionId Parent collection ID\n     * @param conditionId Condition identifier\n     * @param indexSet Index set for outcomes\n     * @return Collection ID\n     */\n    function getCollectionId(\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256 indexSet\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(parentCollectionId, conditionId, indexSet));\n    }\n\n    /**\n     * @notice Get position ID for a collateral token and collection\n     * @param collateralToken Collateral token address\n     * @param collectionId Collection identifier\n     * @return Position ID (used as ERC1155 token ID)\n     */\n    function getPositionId(IERC20 collateralToken, bytes32 collectionId) public pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(collateralToken, collectionId)));\n    }\n\n    /**\n     * @notice Get condition ID\n     * @param oracle Oracle address\n     * @param questionId Question identifier\n     * @param outcomeSlotCount Number of outcomes\n     * @return Condition ID\n     */\n    function getConditionId(\n        address oracle,\n        bytes32 questionId,\n        uint256 outcomeSlotCount\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount));\n    }\n\n    /**\n     * @notice Get condition details\n     * @param conditionId Condition identifier\n     * @return oracle Oracle address\n     * @return questionId Question identifier\n     * @return outcomeSlotCount Number of outcomes\n     * @return resolved Whether condition is resolved\n     */\n    function getCondition(bytes32 conditionId) external view returns (\n        address oracle,\n        bytes32 questionId,\n        uint256 outcomeSlotCount,\n        bool resolved\n    ) {\n        Condition storage condition = _conditions[conditionId];\n        return (\n            condition.oracle,\n            condition.questionId,\n            condition.outcomeSlotCount,\n            condition.resolved\n        );\n    }\n\n    /**\n     * @notice Check if a condition is resolved\n     * @param conditionId Condition identifier\n     * @return Whether the condition is resolved\n     */\n    function isResolved(bytes32 conditionId) external view returns (bool) {\n        return _conditions[conditionId].resolved;\n    }\n\n    /**\n     * @notice Get payout numerators for a resolved condition\n     * @param conditionId Condition identifier\n     * @return Payout numerators array\n     */\n    function getPayoutNumerators(bytes32 conditionId) external view returns (uint256[] memory) {\n        require(_conditions[conditionId].resolved, \"Condition not resolved\");\n        return _conditions[conditionId].payoutNumerators;\n    }\n\n    /**\n     * @notice Get payout denominator for a resolved condition\n     * @param conditionId Condition identifier\n     * @return Payout denominator\n     */\n    function getPayoutDenominator(bytes32 conditionId) external view returns (uint256) {\n        require(_conditions[conditionId].resolved, \"Condition not resolved\");\n        return _conditions[conditionId].payoutDenominator;\n    }\n}\n"
    },
    "contracts/markets/FriendGroupMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./ConditionalMarketFactory.sol\";\nimport \"./FriendGroupMarketLib.sol\";\nimport \"../security/RagequitModule.sol\";\nimport \"../security/NullifierRegistry.sol\";\nimport \"../access/TieredRoleManager.sol\";\nimport \"../access/MembershipPaymentManager.sol\";\n\n// Custom errors (stake/nullification errors from library, reused here)\nerror InvalidAddress();\nerror InvalidMarketId();\nerror InvalidOpponent();\nerror InvalidDescription();\nerror InvalidDeadline();\nerror InvalidStake();\nerror InvalidLimit();\nerror InvalidThreshold();\nerror NotAuthorized();\nerror MembershipRequired();\nerror MembershipExpired();\nerror MarketLimitReached();\nerror MemberLimitReached();\nerror NotPending();\nerror NotActive();\nerror AlreadyAccepted();\nerror AlreadyMember();\nerror NotMember();\nerror NotInvited();\nerror DeadlinePassed();\nerror DeadlineNotPassed();\nerror AlreadyPegged();\nerror NotPegged();\nerror NotResolved();\nerror TransferFailed();\nerror InsufficientPayment();\nerror InvalidMember();\nerror InvalidOdds();\nerror MissingMarketMakerRole();\nerror InvalidResolutionType();\n\n/**\n * @title FriendGroupMarketFactory\n * @notice Factory for creating small-scale prediction markets between friends\n * @dev Supports P2P betting with tiered membership, member limits, and ERC20 payments\n * \n * KEY FEATURES:\n * - Tiered membership system (gas-only markets for members)\n * - ERC20 token support (USDC, USDT, stablecoins)\n * - Member limit enforcement to prevent bypassing public markets\n * - Support for 1v1 bets, group prop bets, and event tracking scenarios\n * - Optional third-party arbitration\n * - Integration with RagequitModule for fair exits\n * - USD-based pricing display\n * \n * USE CASES:\n * 1. Competitive event tracking (poker, board games, etc.)\n * 2. 1v1 prop bets between friends\n * 3. Small group predictions with arbitrator\n * 4. Friend group contests and competitions\n */\ncontract FriendGroupMarketFactory is Ownable, ReentrancyGuard {\n    \n    // Market type to distinguish friend markets from public markets\n    enum MarketType {\n        OneVsOne,           // 1v1 direct bet between two parties\n        SmallGroup,         // 3-10 participants\n        EventTracking,      // Tracking for competitive events/games\n        PropBet,            // General proposition bet\n        Bookmaker           // Leveraged 1v1 market requiring dual roles\n    }\n\n    // Market status for multi-party acceptance flow\n    enum FriendMarketStatus {\n        PendingAcceptance,  // Waiting for participants to accept\n        Active,             // All required parties accepted, market live\n        Resolved,           // Market has been resolved\n        Cancelled,          // Creator cancelled before activation\n        Refunded            // Stakes returned due to deadline expiration\n    }\n\n    // Resolution type for determining who can resolve the market\n    enum ResolutionType {\n        Either,       // Either creator OR opponent can resolve (default)\n        Initiator,    // Only creator can resolve\n        Receiver,     // Only opponent can resolve\n        ThirdParty,   // Designated arbitrator resolves\n        AutoPegged    // Auto-resolves based on linked public market\n    }\n\n    // Acceptance record for each participant\n    struct AcceptanceRecord {\n        address participant;\n        uint256 stakedAmount;\n        uint256 acceptedAt;\n        bool hasAccepted;\n        bool isArbitrator;      // Arbitrators don't stake\n    }\n    \n    struct FriendMarket {\n        uint256 marketId;              // ID in ConditionalMarketFactory\n        MarketType marketType;\n        address creator;\n        address[] members;             // Limited participant list\n        address arbitrator;            // Optional third-party for resolution\n        uint256 memberLimit;           // Max concurrent members\n        uint256 creationFee;           // Reduced fee for friend markets\n        uint256 createdAt;\n        bool active;\n        string description;\n        uint256 peggedPublicMarketId;  // Public market ID to peg resolution to (0 = none)\n        bool autoPegged;               // Whether resolution is pegged to public market\n        address paymentToken;          // ERC20 token used (address(0) = native ETC)\n        uint256 liquidityAmount;       // Initial liquidity in payment token\n        // Multi-party acceptance flow fields\n        FriendMarketStatus status;     // Current market status\n        uint256 acceptanceDeadline;    // Unix timestamp for acceptance deadline\n        uint256 minAcceptanceThreshold; // Minimum participants needed to activate\n        uint256 stakePerParticipant;   // Stake amount required from each participant\n        address stakeToken;            // Token used for stakes (address(0) = native)\n        uint256 tradingPeriodSeconds;  // Trading period stored for later activation\n        uint16 opponentOddsMultiplier; // Odds for 1v1/Bookmaker: 200=2x (equal), 10000=100x. Min 200.\n        ResolutionType resolutionType; // Who can resolve the market\n    }\n    \n    // Friend market ID => FriendMarket\n    mapping(uint256 => FriendMarket) public friendMarkets;\n    \n    // User => array of friend market IDs they're in\n    mapping(address => uint256[]) public userMarkets;\n    \n    // Member count tracking per market\n    mapping(uint256 => uint256) public memberCount;\n    \n    // Track which public markets have pegged friend markets\n    mapping(uint256 => uint256[]) public publicMarketToPeggedFriendMarkets;\n\n    // Acceptance tracking for multi-party flow (friendMarketId => participant => AcceptanceRecord)\n    mapping(uint256 => mapping(address => AcceptanceRecord)) public marketAcceptances;\n\n    // Count of accepted participants per market\n    mapping(uint256 => uint256) public acceptedParticipantCount;\n\n    // Total staked amount per market (held until activation or refund)\n    mapping(uint256 => uint256) public marketTotalStaked;\n\n    uint256 public friendMarketCount;\n    \n    // Reference to main market factory\n    ConditionalMarketFactory public marketFactory;\n    \n    // Reference to ragequit module\n    RagequitModule public ragequitModule;\n    \n    // Reference to tiered role manager for membership checks\n    TieredRoleManager public tieredRoleManager;\n\n    // Reference to nullifier registry for anti-money-laundering protection\n    NullifierRegistry public nullifierRegistry;\n\n    // Whether to enforce nullification checks (can be disabled if nullifier not deployed)\n    bool public enforceNullification;\n    \n    // Default collateral token for markets (ERC20, required for CTF)\n    address public defaultCollateralToken;\n    \n    // Pricing tiers (updateable by managers)\n    uint256 public publicMarketFee = 1 ether;      // Standard market fee\n    uint256 public friendMarketFee = 0.1 ether;    // Reduced fee for friend markets\n    uint256 public oneVsOneFee = 0.05 ether;       // Even lower for 1v1\n    \n    // Proposal ID offset to avoid collision with public markets\n    // Using 10 billion to allow for massive scale (10B public markets before collision)\n    uint256 public constant PROPOSAL_ID_OFFSET = 10_000_000_000;\n    \n    // Member limits (updateable by managers)\n    uint256 public maxSmallGroupMembers = 10;\n    uint256 public maxOneVsOneMembers = 2;\n    uint256 public minEventTrackingMembers = 3;\n    uint256 public maxEventTrackingMembers = 10;\n    \n    // Manager role for updating configuration\n    address public manager;\n    \n    // Reference to membership payment manager for ERC20 handling\n    MembershipPaymentManager public paymentManager;\n    \n    // Accepted payment tokens for market creation and liquidity (address => isAccepted)\n    mapping(address => bool) public acceptedPaymentTokens;\n    \n    // Track accepted token list\n    address[] public acceptedTokenList;\n    \n    // Events\n    event FriendMarketCreated(\n        uint256 indexed friendMarketId,\n        uint256 indexed underlyingMarketId,\n        MarketType marketType,\n        address indexed creator,\n        uint256 memberLimit,\n        uint256 creationFee,\n        address paymentToken\n    );\n    event MemberAdded(uint256 indexed friendMarketId, address indexed member);\n    event MemberRemoved(uint256 indexed friendMarketId, address indexed member);\n    event MarketPegged(uint256 indexed friendMarketId, uint256 indexed publicMarketId);\n    event BatchResolution(uint256 indexed publicMarketId, uint256[] friendMarketIds, uint256 outcome);\n    event FeesUpdated(uint256 publicFee, uint256 friendFee, uint256 oneVsOneFee);\n    event MemberLimitsUpdated(uint256 maxSmallGroup, uint256 maxOneVsOne, uint256 minEventTracking, uint256 maxEventTracking);\n    event ManagerUpdated(address indexed oldManager, address indexed newManager);\n    event PaymentTokenAdded(address indexed token);\n    event PaymentTokenRemoved(address indexed token);\n    event NullifierRegistryUpdated(address indexed nullifierRegistry);\n    event NullificationEnforcementUpdated(bool enforce);\n    \n    event ArbitratorSet(\n        uint256 indexed friendMarketId,\n        address indexed arbitrator\n    );\n    \n    event MarketResolved(\n        uint256 indexed friendMarketId,\n        address indexed resolver,\n        bool outcome\n    );\n    \n    event MarketPeggedToPublic(\n        uint256 indexed friendMarketId,\n        uint256 indexed publicMarketId\n    );\n    \n    event PeggedMarketAutoResolved(\n        uint256 indexed friendMarketId,\n        uint256 indexed publicMarketId,\n        uint256 passValue,\n        uint256 failValue\n    );\n\n    // Multi-party acceptance flow events\n    event MarketCreatedPending(\n        uint256 indexed friendMarketId,\n        address indexed creator,\n        uint256 acceptanceDeadline,\n        uint256 stakePerParticipant,\n        uint16 opponentOddsMultiplier,\n        address stakeToken,\n        address[] invitedParticipants,\n        address arbitrator\n    );\n\n    event ParticipantAccepted(\n        uint256 indexed friendMarketId,\n        address indexed participant,\n        uint256 stakedAmount,\n        uint256 acceptedAt\n    );\n\n    event ArbitratorAccepted(\n        uint256 indexed friendMarketId,\n        address indexed arbitrator,\n        uint256 acceptedAt\n    );\n\n    event MarketActivated(\n        uint256 indexed friendMarketId,\n        uint256 underlyingMarketId,\n        uint256 activatedAt,\n        uint256 totalStaked,\n        uint256 participantCount\n    );\n\n    event MarketCancelledByCreator(\n        uint256 indexed friendMarketId,\n        address indexed creator,\n        uint256 cancelledAt\n    );\n\n    event AcceptanceDeadlinePassed(\n        uint256 indexed friendMarketId,\n        uint256 deadline,\n        uint256 acceptedCount,\n        uint256 requiredCount\n    );\n\n    event StakeRefunded(\n        uint256 indexed friendMarketId,\n        address indexed participant,\n        uint256 amount\n    );\n    \n    constructor(\n        address _marketFactory,\n        address payable _ragequitModule,\n        address _tieredRoleManager,\n        address _paymentManager,\n        address _owner\n    ) Ownable(_owner) {\n        if (_marketFactory == address(0)) revert InvalidAddress();\n        if (_ragequitModule == address(0)) revert InvalidAddress();\n        if (_tieredRoleManager == address(0)) revert InvalidAddress();\n        if (_paymentManager == address(0)) revert InvalidAddress();\n        if (_owner == address(0)) revert InvalidAddress();\n\n        marketFactory = ConditionalMarketFactory(_marketFactory);\n        ragequitModule = RagequitModule(_ragequitModule);\n        tieredRoleManager = TieredRoleManager(_tieredRoleManager);\n        paymentManager = MembershipPaymentManager(_paymentManager);\n        manager = _owner; // Initially owner, transferable\n\n        // Accept native ETC by default\n        acceptedPaymentTokens[address(0)] = true;\n    }\n    \n    // ========== Manager Functions ==========\n    \n    /**\n     * @notice Update manager address (only owner)\n     * @param newManager New manager address\n     */\n    function updateManager(address newManager) external onlyOwner {\n        if (newManager == address(0)) revert InvalidAddress();\n        address oldManager = manager;\n        manager = newManager;\n        emit ManagerUpdated(oldManager, newManager);\n    }\n    \n    /**\n     * @notice Set default collateral token for markets (ERC20, required for CTF)\n     * @param _collateralToken Address of ERC20 token to use as collateral\n     */\n    function setDefaultCollateralToken(address _collateralToken) external onlyOwner {\n        if (_collateralToken == address(0)) revert InvalidAddress();\n        defaultCollateralToken = _collateralToken;\n    }\n\n    function addAcceptedPaymentToken(address token, bool active) external {\n        if (msg.sender != manager && msg.sender != owner()) revert NotAuthorized();\n\n        bool wasAccepted = acceptedPaymentTokens[token];\n        acceptedPaymentTokens[token] = active;\n\n        if (active && !wasAccepted && token != address(0)) {\n            acceptedTokenList.push(token);\n            emit PaymentTokenAdded(token);\n        } else if (!active && wasAccepted) {\n            emit PaymentTokenRemoved(token);\n        }\n    }\n\n    function removeAcceptedPaymentToken(address token) external {\n        if (msg.sender != manager && msg.sender != owner()) revert NotAuthorized();\n        if (token == address(0)) revert InvalidAddress();\n\n        acceptedPaymentTokens[token] = false;\n        emit PaymentTokenRemoved(token);\n    }\n\n    function updateFees(uint256 _publicFee, uint256 _friendFee, uint256 _oneVsOneFee) external {\n        if (msg.sender != manager && msg.sender != owner()) revert NotAuthorized();\n        publicMarketFee = _publicFee;\n        friendMarketFee = _friendFee;\n        oneVsOneFee = _oneVsOneFee;\n        emit FeesUpdated(_publicFee, _friendFee, _oneVsOneFee);\n    }\n    \n    /**\n     * @notice Update member limits (only manager)\n     * @param _maxSmallGroup Max members for small group markets\n     * @param _maxOneVsOne Max members for 1v1 markets (should be 2)\n     * @param _minEventTracking Min members for event tracking\n     * @param _maxEventTracking Max members for event tracking\n     */\n    function updateMemberLimits(\n        uint256 _maxSmallGroup,\n        uint256 _maxOneVsOne,\n        uint256 _minEventTracking,\n        uint256 _maxEventTracking\n    ) external {\n        if (msg.sender != manager && msg.sender != owner()) revert NotAuthorized();\n        if (_maxOneVsOne != 2) revert InvalidLimit();\n        if (_minEventTracking > _maxEventTracking) revert InvalidLimit();\n        maxSmallGroupMembers = _maxSmallGroup;\n        maxOneVsOneMembers = _maxOneVsOne;\n        minEventTrackingMembers = _minEventTracking;\n        maxEventTrackingMembers = _maxEventTracking;\n        emit MemberLimitsUpdated(_maxSmallGroup, _maxOneVsOne, _minEventTracking, _maxEventTracking);\n    }\n\n    /**\n     * @notice Update TieredRoleManager address (only owner)\n     * @param _tieredRoleManager New TieredRoleManager address\n     */\n    function setTieredRoleManager(address _tieredRoleManager) external onlyOwner {\n        if (_tieredRoleManager == address(0)) revert InvalidAddress();\n        tieredRoleManager = TieredRoleManager(_tieredRoleManager);\n    }\n\n    /**\n     * @notice Set the NullifierRegistry contract (only owner)\n     * @param _nullifierRegistry Address of NullifierRegistry contract\n     */\n    function setNullifierRegistry(address _nullifierRegistry) external onlyOwner {\n        if (_nullifierRegistry == address(0)) revert InvalidAddress();\n        nullifierRegistry = NullifierRegistry(_nullifierRegistry);\n        emit NullifierRegistryUpdated(_nullifierRegistry);\n    }\n\n    /**\n     * @notice Enable or disable nullification enforcement (only owner)\n     * @param _enforce Whether to enforce nullification checks\n     */\n    function setNullificationEnforcement(bool _enforce) external onlyOwner {\n        // Can only enable if registry is set\n        if (_enforce && address(nullifierRegistry) == address(0)) revert InvalidAddress();\n        enforceNullification = _enforce;\n        emit NullificationEnforcementUpdated(_enforce);\n    }\n\n    // ========== Multi-Party Acceptance Flow Functions ==========\n\n    /**\n     * @notice Create a 1v1 market with pending acceptance (equal stakes)\n     * @param opponent Address of the counterparty\n     * @param description Market description\n     * @param tradingPeriod Duration after activation (7-21 days)\n     * @param arbitrator Optional third-party arbitrator (required if resolutionType is ThirdParty)\n     * @param acceptanceDeadline Unix timestamp for acceptance deadline\n     * @param stakeAmount Equal stake amount for both parties\n     * @param stakeToken ERC20 token address for stakes (address(0) for native)\n     * @param resolutionType Who can resolve the market\n     * @return friendMarketId ID of the pending friend market\n     */\n    function createOneVsOneMarketPending(\n        address opponent,\n        string memory description,\n        uint256 tradingPeriod,\n        address arbitrator,\n        uint256 acceptanceDeadline,\n        uint256 stakeAmount,\n        address stakeToken,\n        ResolutionType resolutionType\n    ) external payable nonReentrant returns (uint256 friendMarketId) {\n        if (opponent == address(0) || opponent == msg.sender) revert InvalidOpponent();\n        if (bytes(description).length == 0) revert InvalidDescription();\n        if (acceptanceDeadline <= block.timestamp + 1 hours || acceptanceDeadline >= block.timestamp + 30 days) revert InvalidDeadline();\n        if (stakeAmount == 0) revert InvalidStake();\n\n        // Validate resolution type\n        if (resolutionType == ResolutionType.ThirdParty && arbitrator == address(0)) revert InvalidAddress();\n\n        bytes32 role = tieredRoleManager.FRIEND_MARKET_ROLE();\n        if (!tieredRoleManager.hasRole(role, msg.sender)) revert MembershipRequired();\n        if (!tieredRoleManager.isMembershipActive(msg.sender, role)) revert MembershipExpired();\n        if (!tieredRoleManager.checkMarketCreationLimitFor(msg.sender, role)) revert MarketLimitReached();\n\n        // Anti-money-laundering: Check if creator or opponent is nullified\n        FriendGroupMarketLib.checkNullification(nullifierRegistry, enforceNullification, msg.sender);\n        FriendGroupMarketLib.checkNullification(nullifierRegistry, enforceNullification, opponent);\n\n        // Equal stakes for 1v1 markets\n        FriendGroupMarketLib.collectStake(msg.sender, stakeToken, stakeAmount);\n\n        // Create pending market (no underlying market yet - created on activation)\n        friendMarketId = friendMarketCount++;\n\n        address[] memory participants = new address[](2);\n        participants[0] = msg.sender;\n        participants[1] = opponent;\n\n        friendMarkets[friendMarketId] = FriendMarket({\n            marketId: 0, // Not created until activated\n            marketType: MarketType.OneVsOne,\n            creator: msg.sender,\n            members: participants,\n            arbitrator: arbitrator,\n            memberLimit: maxOneVsOneMembers,\n            creationFee: 0,\n            createdAt: block.timestamp,\n            active: false, // Not active until accepted\n            description: description,\n            peggedPublicMarketId: 0,\n            autoPegged: false,\n            paymentToken: stakeToken,\n            liquidityAmount: 0,\n            status: FriendMarketStatus.PendingAcceptance,\n            acceptanceDeadline: acceptanceDeadline,\n            minAcceptanceThreshold: 2, // Both must accept for 1v1\n            stakePerParticipant: stakeAmount, // Equal stake for both parties\n            stakeToken: stakeToken,\n            tradingPeriodSeconds: tradingPeriod,\n            opponentOddsMultiplier: 200, // Equal stakes (2x)\n            resolutionType: resolutionType\n        });\n\n        // Record creator's acceptance (equal stake)\n        marketAcceptances[friendMarketId][msg.sender] = AcceptanceRecord({\n            participant: msg.sender,\n            stakedAmount: stakeAmount,\n            acceptedAt: block.timestamp,\n            hasAccepted: true,\n            isArbitrator: false\n        });\n\n        acceptedParticipantCount[friendMarketId] = 1;\n        marketTotalStaked[friendMarketId] = stakeAmount;\n\n        memberCount[friendMarketId] = 2;\n        userMarkets[msg.sender].push(friendMarketId);\n        userMarkets[opponent].push(friendMarketId);\n\n        emit MarketCreatedPending(\n            friendMarketId,\n            msg.sender,\n            acceptanceDeadline,\n            stakeAmount,\n            200, // Equal stakes\n            stakeToken,\n            participants,\n            arbitrator\n        );\n\n        if (arbitrator != address(0)) {\n            emit ArbitratorSet(friendMarketId, arbitrator);\n        }\n    }\n\n    /**\n     * @notice Create a Bookmaker market - leveraged 1v1 requiring both MARKET_MAKER and FRIEND_MARKET roles\n     * @dev More dispute-prone due to asymmetric stakes, hence separated from regular 1v1\n     * @param opponent Address of the counterparty (must have FRIEND_MARKET_ROLE)\n     * @param description Market description\n     * @param tradingPeriod Duration after activation (7-21 days)\n     * @param acceptanceDeadline Unix timestamp for acceptance deadline\n     * @param opponentStakeAmount Amount opponent must stake (creator stake derived from odds)\n     * @param opponentOddsMultiplier Opponent's payout multiplier: 200=2x (equal), 10000=100x\n     * @param stakeToken ERC20 token address for stakes (address(0) for native)\n     * @param resolutionType Who can resolve the market\n     * @param arbitrator Optional third-party arbitrator (required if resolutionType is ThirdParty)\n     * @return friendMarketId ID of the pending friend market\n     */\n    function createBookmakerMarket(\n        address opponent,\n        string memory description,\n        uint256 tradingPeriod,\n        uint256 acceptanceDeadline,\n        uint256 opponentStakeAmount,\n        uint16 opponentOddsMultiplier,\n        address stakeToken,\n        ResolutionType resolutionType,\n        address arbitrator\n    ) external payable nonReentrant returns (uint256 friendMarketId) {\n        if (opponent == address(0) || opponent == msg.sender) revert InvalidOpponent();\n        if (bytes(description).length == 0) revert InvalidDescription();\n        if (acceptanceDeadline <= block.timestamp + 1 hours || acceptanceDeadline >= block.timestamp + 30 days) revert InvalidDeadline();\n        if (opponentStakeAmount == 0) revert InvalidStake();\n        if (opponentOddsMultiplier < 200) revert InvalidOdds(); // Minimum 2x (equal stakes)\n\n        // Validate resolution type\n        if (resolutionType == ResolutionType.ThirdParty && arbitrator == address(0)) revert InvalidAddress();\n\n        // Creator must have BOTH MARKET_MAKER_ROLE and FRIEND_MARKET_ROLE\n        bytes32 friendRole = tieredRoleManager.FRIEND_MARKET_ROLE();\n        bytes32 makerRole = tieredRoleManager.MARKET_MAKER_ROLE();\n\n        if (!tieredRoleManager.hasRole(friendRole, msg.sender)) revert MembershipRequired();\n        if (!tieredRoleManager.hasRole(makerRole, msg.sender)) revert MissingMarketMakerRole();\n        if (!tieredRoleManager.isMembershipActive(msg.sender, friendRole)) revert MembershipExpired();\n        if (!tieredRoleManager.isMembershipActive(msg.sender, makerRole)) revert MembershipExpired();\n        if (!tieredRoleManager.checkMarketCreationLimitFor(msg.sender, friendRole)) revert MarketLimitReached();\n\n        // Opponent only needs FRIEND_MARKET_ROLE to accept\n        if (!tieredRoleManager.hasRole(friendRole, opponent)) revert MembershipRequired();\n\n        // Anti-money-laundering: Check if creator or opponent is nullified\n        FriendGroupMarketLib.checkNullification(nullifierRegistry, enforceNullification, msg.sender);\n        FriendGroupMarketLib.checkNullification(nullifierRegistry, enforceNullification, opponent);\n\n        // Calculate creator's stake based on odds (creator is \"insurer\", stakes more)\n        // Formula: creatorStake = opponentStake × (multiplier - 100) / 100\n        uint256 creatorStake = (opponentStakeAmount * (uint256(opponentOddsMultiplier) - 100)) / 100;\n        FriendGroupMarketLib.collectStake(msg.sender, stakeToken, creatorStake);\n\n        // Create pending market\n        friendMarketId = friendMarketCount++;\n\n        address[] memory participants = new address[](2);\n        participants[0] = msg.sender;\n        participants[1] = opponent;\n\n        friendMarkets[friendMarketId] = FriendMarket({\n            marketId: 0, // Not created until activated\n            marketType: MarketType.Bookmaker,\n            creator: msg.sender,\n            members: participants,\n            arbitrator: arbitrator,\n            memberLimit: maxOneVsOneMembers,\n            creationFee: 0,\n            createdAt: block.timestamp,\n            active: false, // Not active until accepted\n            description: description,\n            peggedPublicMarketId: 0,\n            autoPegged: false,\n            paymentToken: stakeToken,\n            liquidityAmount: 0,\n            status: FriendMarketStatus.PendingAcceptance,\n            acceptanceDeadline: acceptanceDeadline,\n            minAcceptanceThreshold: 2, // Both must accept for 1v1\n            stakePerParticipant: opponentStakeAmount, // Opponent's required stake\n            stakeToken: stakeToken,\n            tradingPeriodSeconds: tradingPeriod,\n            opponentOddsMultiplier: opponentOddsMultiplier,\n            resolutionType: resolutionType\n        });\n\n        // Record creator's acceptance (creator stakes more based on odds)\n        marketAcceptances[friendMarketId][msg.sender] = AcceptanceRecord({\n            participant: msg.sender,\n            stakedAmount: creatorStake,\n            acceptedAt: block.timestamp,\n            hasAccepted: true,\n            isArbitrator: false\n        });\n\n        acceptedParticipantCount[friendMarketId] = 1;\n        marketTotalStaked[friendMarketId] = creatorStake;\n\n        memberCount[friendMarketId] = 2;\n        userMarkets[msg.sender].push(friendMarketId);\n        userMarkets[opponent].push(friendMarketId);\n\n        emit MarketCreatedPending(\n            friendMarketId,\n            msg.sender,\n            acceptanceDeadline,\n            opponentStakeAmount,\n            opponentOddsMultiplier,\n            stakeToken,\n            participants,\n            arbitrator\n        );\n\n        if (arbitrator != address(0)) {\n            emit ArbitratorSet(friendMarketId, arbitrator);\n        }\n    }\n\n    /**\n     * @notice Create a small group market with pending acceptance\n     * @param description Market description\n     * @param invitedMembers Initial participant addresses (excluding creator)\n     * @param memberLimit Maximum concurrent members\n     * @param tradingPeriod Duration after activation\n     * @param arbitrator Optional third-party arbitrator\n     * @param acceptanceDeadline Unix timestamp for acceptance deadline\n     * @param minAcceptanceThreshold Minimum participants to activate (including creator)\n     * @param stakeAmount Amount each party must stake\n     * @param stakeToken ERC20 token address for stakes\n     * @return friendMarketId ID of the pending friend market\n     */\n    function createSmallGroupMarketPending(\n        string memory description,\n        address[] memory invitedMembers,\n        uint256 memberLimit,\n        uint256 tradingPeriod,\n        address arbitrator,\n        uint256 acceptanceDeadline,\n        uint256 minAcceptanceThreshold,\n        uint256 stakeAmount,\n        address stakeToken\n    ) external payable nonReentrant returns (uint256 friendMarketId) {\n        if (bytes(description).length == 0) revert InvalidDescription();\n        if (memberLimit <= 2 || memberLimit > maxSmallGroupMembers) revert InvalidLimit();\n        if (invitedMembers.length == 0 || invitedMembers.length >= memberLimit) revert InvalidLimit();\n        if (acceptanceDeadline <= block.timestamp + 1 hours || acceptanceDeadline >= block.timestamp + 30 days) revert InvalidDeadline();\n        if (stakeAmount == 0) revert InvalidStake();\n        if (minAcceptanceThreshold < 2) revert InvalidThreshold();\n        if (minAcceptanceThreshold > invitedMembers.length + 1) revert InvalidThreshold();\n\n        FriendGroupMarketLib.validateMembersExcluding(invitedMembers, msg.sender);\n\n        bytes32 role = tieredRoleManager.FRIEND_MARKET_ROLE();\n        if (!tieredRoleManager.hasRole(role, msg.sender)) revert MembershipRequired();\n        if (!tieredRoleManager.isMembershipActive(msg.sender, role)) revert MembershipExpired();\n        if (!tieredRoleManager.checkMarketCreationLimitFor(msg.sender, role)) revert MarketLimitReached();\n\n        // Anti-money-laundering: Check if creator or any invited member is nullified\n        FriendGroupMarketLib.checkNullification(nullifierRegistry, enforceNullification, msg.sender);\n        FriendGroupMarketLib.checkNullificationBatch(nullifierRegistry, enforceNullification, invitedMembers);\n\n        FriendGroupMarketLib.collectStake(msg.sender, stakeToken, stakeAmount);\n\n        // Build full participant list (creator + invited)\n        address[] memory allParticipants = new address[](invitedMembers.length + 1);\n        allParticipants[0] = msg.sender;\n        for (uint256 i = 0; i < invitedMembers.length; i++) {\n            allParticipants[i + 1] = invitedMembers[i];\n        }\n\n        // Create pending market\n        friendMarketId = friendMarketCount++;\n\n        friendMarkets[friendMarketId] = FriendMarket({\n            marketId: 0,\n            marketType: MarketType.SmallGroup,\n            creator: msg.sender,\n            members: allParticipants,\n            arbitrator: arbitrator,\n            memberLimit: memberLimit,\n            creationFee: 0,\n            createdAt: block.timestamp,\n            active: false,\n            description: description,\n            peggedPublicMarketId: 0,\n            autoPegged: false,\n            paymentToken: stakeToken,\n            liquidityAmount: 0,\n            status: FriendMarketStatus.PendingAcceptance,\n            acceptanceDeadline: acceptanceDeadline,\n            minAcceptanceThreshold: minAcceptanceThreshold,\n            stakePerParticipant: stakeAmount,\n            stakeToken: stakeToken,\n            tradingPeriodSeconds: tradingPeriod,\n            opponentOddsMultiplier: 200, // Group markets use equal stakes\n            resolutionType: ResolutionType.Either // Group markets use default resolution\n        });\n\n        // Record creator's acceptance\n        marketAcceptances[friendMarketId][msg.sender] = AcceptanceRecord({\n            participant: msg.sender,\n            stakedAmount: stakeAmount,\n            acceptedAt: block.timestamp,\n            hasAccepted: true,\n            isArbitrator: false\n        });\n\n        acceptedParticipantCount[friendMarketId] = 1;\n        marketTotalStaked[friendMarketId] = stakeAmount;\n        memberCount[friendMarketId] = allParticipants.length;\n\n        // Add all participants to user markets\n        for (uint256 i = 0; i < allParticipants.length; i++) {\n            userMarkets[allParticipants[i]].push(friendMarketId);\n        }\n\n        emit MarketCreatedPending(\n            friendMarketId,\n            msg.sender,\n            acceptanceDeadline,\n            stakeAmount,\n            200, // Group markets use equal stakes (2x)\n            stakeToken,\n            allParticipants,\n            arbitrator\n        );\n\n        if (arbitrator != address(0)) {\n            emit ArbitratorSet(friendMarketId, arbitrator);\n        }\n    }\n\n    /**\n     * @notice Add a member to an existing small group market\n     * @param friendMarketId ID of the friend market\n     * @param newMember Address of new member\n     */\n    function addMember(uint256 friendMarketId, address newMember) external {\n        if (friendMarketId >= friendMarketCount) revert InvalidMarketId();\n        FriendMarket storage market = friendMarkets[friendMarketId];\n        if (!market.active) revert NotActive();\n        if (msg.sender != market.creator) revert NotAuthorized();\n        if (newMember == address(0)) revert InvalidMember();\n        if (memberCount[friendMarketId] >= market.memberLimit) revert MemberLimitReached();\n\n        // Anti-money-laundering: Check if new member is nullified\n        FriendGroupMarketLib.checkNullification(nullifierRegistry, enforceNullification, newMember);\n\n        for (uint256 i = 0; i < market.members.length; i++) {\n            if (market.members[i] == newMember) revert AlreadyMember();\n        }\n\n        market.members.push(newMember);\n        memberCount[friendMarketId]++;\n        userMarkets[newMember].push(friendMarketId);\n\n        emit MemberAdded(friendMarketId, newMember);\n    }\n\n    function removeSelf(uint256 friendMarketId) external nonReentrant {\n        if (friendMarketId >= friendMarketCount) revert InvalidMarketId();\n        FriendMarket storage market = friendMarkets[friendMarketId];\n        if (!market.active) revert NotActive();\n\n        bool found = false;\n        for (uint256 i = 0; i < market.members.length; i++) {\n            if (market.members[i] == msg.sender) {\n                market.members[i] = market.members[market.members.length - 1];\n                market.members.pop();\n                memberCount[friendMarketId]--;\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) revert NotMember();\n        emit MemberRemoved(friendMarketId, msg.sender);\n    }\n\n    function acceptMarket(uint256 friendMarketId) external payable nonReentrant {\n        if (friendMarketId >= friendMarketCount) revert InvalidMarketId();\n        FriendMarket storage market = friendMarkets[friendMarketId];\n\n        if (market.status != FriendMarketStatus.PendingAcceptance) revert NotPending();\n        if (block.timestamp >= market.acceptanceDeadline) revert DeadlinePassed();\n        if (marketAcceptances[friendMarketId][msg.sender].hasAccepted) revert AlreadyAccepted();\n\n        // Anti-money-laundering: Check if accepting participant is nullified\n        FriendGroupMarketLib.checkNullification(nullifierRegistry, enforceNullification, msg.sender);\n\n        bool isInvited = false;\n        bool isArbitrator = market.arbitrator == msg.sender;\n\n        for (uint256 i = 0; i < market.members.length; i++) {\n            if (market.members[i] == msg.sender) {\n                isInvited = true;\n                break;\n            }\n        }\n\n        if (!isInvited && !isArbitrator) revert NotInvited();\n\n        if (isArbitrator) {\n            // Arbitrators don't stake\n            marketAcceptances[friendMarketId][msg.sender] = AcceptanceRecord({\n                participant: msg.sender,\n                stakedAmount: 0,\n                acceptedAt: block.timestamp,\n                hasAccepted: true,\n                isArbitrator: true\n            });\n\n            emit ArbitratorAccepted(friendMarketId, msg.sender, block.timestamp);\n        } else {\n            // Collect stake from participant\n            FriendGroupMarketLib.collectStake(msg.sender, market.stakeToken, market.stakePerParticipant);\n\n            marketAcceptances[friendMarketId][msg.sender] = AcceptanceRecord({\n                participant: msg.sender,\n                stakedAmount: market.stakePerParticipant,\n                acceptedAt: block.timestamp,\n                hasAccepted: true,\n                isArbitrator: false\n            });\n\n            acceptedParticipantCount[friendMarketId]++;\n            marketTotalStaked[friendMarketId] += market.stakePerParticipant;\n\n            emit ParticipantAccepted(\n                friendMarketId,\n                msg.sender,\n                market.stakePerParticipant,\n                block.timestamp\n            );\n        }\n\n        // Check if market should activate\n        _checkAndActivateMarket(friendMarketId);\n    }\n\n    /**\n     * @notice Cancel a pending market (creator only, before activation)\n     * @param friendMarketId ID of the pending market\n     */\n    function cancelPendingMarket(uint256 friendMarketId) external nonReentrant {\n        if (friendMarketId >= friendMarketCount) revert InvalidMarketId();\n        FriendMarket storage market = friendMarkets[friendMarketId];\n\n        if (market.status != FriendMarketStatus.PendingAcceptance) revert NotPending();\n        if (msg.sender != market.creator) revert NotAuthorized();\n\n        market.status = FriendMarketStatus.Cancelled;\n        _refundAllStakesInternal(friendMarketId);\n\n        emit MarketCancelledByCreator(friendMarketId, msg.sender, block.timestamp);\n    }\n\n    function processExpiredDeadline(uint256 friendMarketId) external nonReentrant {\n        if (friendMarketId >= friendMarketCount) revert InvalidMarketId();\n        FriendMarket storage market = friendMarkets[friendMarketId];\n\n        if (market.status != FriendMarketStatus.PendingAcceptance) revert NotPending();\n        if (block.timestamp < market.acceptanceDeadline) revert DeadlineNotPassed();\n\n        uint256 accepted = acceptedParticipantCount[friendMarketId];\n        uint256 required = market.minAcceptanceThreshold;\n\n        // Check if arbitrator acceptance is also required and met\n        bool arbitratorOk = true;\n        if (market.arbitrator != address(0)) {\n            arbitratorOk = marketAcceptances[friendMarketId][market.arbitrator].hasAccepted;\n        }\n\n        if (accepted >= required && arbitratorOk) {\n            // Threshold met - activate market\n            _activateMarket(friendMarketId);\n        } else {\n            // Threshold not met - refund all\n            market.status = FriendMarketStatus.Refunded;\n            _refundAllStakesInternal(friendMarketId);\n\n            emit AcceptanceDeadlinePassed(friendMarketId, market.acceptanceDeadline, accepted, required);\n        }\n    }\n\n    // ========== Internal Helper Functions for Acceptance Flow ==========\n\n    /**\n     * @notice Refund all stakes for a market (uses library for individual refunds)\n     */\n    function _refundAllStakesInternal(uint256 friendMarketId) internal {\n        FriendMarket storage market = friendMarkets[friendMarketId];\n\n        for (uint256 i = 0; i < market.members.length; i++) {\n            address participant = market.members[i];\n            AcceptanceRecord storage record = marketAcceptances[friendMarketId][participant];\n\n            if (record.hasAccepted && record.stakedAmount > 0) {\n                FriendGroupMarketLib.refundStake(participant, market.stakeToken, record.stakedAmount);\n                emit StakeRefunded(friendMarketId, participant, record.stakedAmount);\n            }\n        }\n\n        marketTotalStaked[friendMarketId] = 0;\n    }\n\n    /**\n     * @notice Check if market should activate and do so if conditions are met\n     */\n    function _checkAndActivateMarket(uint256 friendMarketId) internal {\n        FriendMarket storage market = friendMarkets[friendMarketId];\n\n        uint256 accepted = acceptedParticipantCount[friendMarketId];\n        uint256 required = market.minAcceptanceThreshold;\n\n        // Check if arbitrator acceptance is required and met\n        bool arbitratorOk = true;\n        if (market.arbitrator != address(0)) {\n            arbitratorOk = marketAcceptances[friendMarketId][market.arbitrator].hasAccepted;\n        }\n\n        if (accepted >= required && arbitratorOk) {\n            _activateMarket(friendMarketId);\n        }\n    }\n\n    /**\n     * @notice Activate a pending market by deploying the underlying market\n     */\n    function _activateMarket(uint256 friendMarketId) internal {\n        FriendMarket storage market = friendMarkets[friendMarketId];\n\n        uint256 totalStaked = marketTotalStaked[friendMarketId];\n\n        // Deploy underlying market in ConditionalMarketFactory\n        uint256 proposalId = friendMarketId + PROPOSAL_ID_OFFSET;\n        address collateral = defaultCollateralToken != address(0) ? defaultCollateralToken : market.stakeToken;\n\n        // Approve collateral transfer to ConditionalMarketFactory\n        if (collateral != address(0)) {\n            IERC20(collateral).approve(address(marketFactory), totalStaked);\n        }\n\n        uint256 underlyingMarketId = marketFactory.deployMarketPair(\n            proposalId,\n            collateral,\n            totalStaked,\n            0.01 ether, // Liquidity parameter\n            market.tradingPeriodSeconds,\n            ConditionalMarketFactory.BetType.YesNo\n        );\n\n        market.marketId = underlyingMarketId;\n        market.status = FriendMarketStatus.Active;\n        market.active = true;\n        market.liquidityAmount = totalStaked;\n\n        emit MarketActivated(\n            friendMarketId,\n            underlyingMarketId,\n            block.timestamp,\n            totalStaked,\n            acceptedParticipantCount[friendMarketId]\n        );\n    }\n\n    // ========== Acceptance Flow View Functions ==========\n\n    /**\n     * @notice Get acceptance status for a market\n     */\n    function getAcceptanceStatus(uint256 friendMarketId) external view returns (\n        uint256 accepted,\n        uint256 required,\n        uint256 deadline,\n        bool arbitratorRequired,\n        bool arbitratorAccepted,\n        FriendMarketStatus status\n    ) {\n        if (friendMarketId >= friendMarketCount) revert InvalidMarketId();\n        FriendMarket storage market = friendMarkets[friendMarketId];\n\n        return (\n            acceptedParticipantCount[friendMarketId],\n            market.minAcceptanceThreshold,\n            market.acceptanceDeadline,\n            market.arbitrator != address(0),\n            market.arbitrator != address(0) ?\n                marketAcceptances[friendMarketId][market.arbitrator].hasAccepted : true,\n            market.status\n        );\n    }\n\n    /**\n     * @notice Get participant's acceptance record\n     */\n    function getParticipantAcceptance(uint256 friendMarketId, address participant)\n        external view returns (AcceptanceRecord memory)\n    {\n        if (friendMarketId >= friendMarketCount) revert InvalidMarketId();\n        return marketAcceptances[friendMarketId][participant];\n    }\n\n    function hasAccepted(uint256 friendMarketId, address participant) external view returns (bool) {\n        return marketAcceptances[friendMarketId][participant].hasAccepted;\n    }\n\n    /**\n     * @notice Get stake requirements for a 1v1 market with custom odds\n     * @param friendMarketId ID of the friend market\n     * @return opponentStake Amount opponent must stake\n     * @return creatorStake Amount creator staked\n     * @return totalPot Total pot if both stakes collected\n     * @return oddsMultiplier The odds multiplier (200 = 2x, 10000 = 100x)\n     */\n    function getStakeRequirements(uint256 friendMarketId) external view returns (\n        uint256 opponentStake,\n        uint256 creatorStake,\n        uint256 totalPot,\n        uint16 oddsMultiplier\n    ) {\n        if (friendMarketId >= friendMarketCount) revert InvalidMarketId();\n        FriendMarket storage market = friendMarkets[friendMarketId];\n\n        opponentStake = market.stakePerParticipant;\n        // Treat 0 as 200 (2x) for backwards compatibility with legacy markets\n        oddsMultiplier = market.opponentOddsMultiplier == 0 ? 200 : market.opponentOddsMultiplier;\n        creatorStake = (opponentStake * (uint256(oddsMultiplier) - 100)) / 100;\n        totalPot = (opponentStake * uint256(oddsMultiplier)) / 100;\n    }\n\n    /**\n     * @notice Get friend market details with acceptance info\n     */\n    function getFriendMarketWithStatus(uint256 friendMarketId) external view returns (\n        uint256 marketId,\n        MarketType marketType,\n        address creator,\n        address[] memory members,\n        address arbitrator,\n        FriendMarketStatus status,\n        uint256 acceptanceDeadline,\n        uint256 stakePerParticipant,\n        address stakeToken,\n        uint256 acceptedCount,\n        uint256 minThreshold,\n        uint16 opponentOddsMultiplier,\n        string memory description,\n        ResolutionType resolutionType\n    ) {\n        if (friendMarketId >= friendMarketCount) revert InvalidMarketId();\n        FriendMarket storage market = friendMarkets[friendMarketId];\n\n        return (\n            market.marketId,\n            market.marketType,\n            market.creator,\n            market.members,\n            market.arbitrator,\n            market.status,\n            market.acceptanceDeadline,\n            market.stakePerParticipant,\n            market.stakeToken,\n            acceptedParticipantCount[friendMarketId],\n            market.minAcceptanceThreshold,\n            market.opponentOddsMultiplier == 0 ? 200 : market.opponentOddsMultiplier,\n            market.description,\n            market.resolutionType\n        );\n    }\n\n    /**\n     * @notice Get friend market details\n     * @param friendMarketId ID of the friend market\n     */\n    function getFriendMarket(uint256 friendMarketId) external view returns (\n        uint256 marketId,\n        MarketType marketType,\n        address creator,\n        address[] memory members,\n        address arbitrator,\n        uint256 memberLimit,\n        uint256 creationFee,\n        uint256 createdAt,\n        bool active,\n        string memory description,\n        uint256 peggedPublicMarketId,\n        bool autoPegged,\n        address paymentToken,\n        uint256 liquidityAmount\n    ) {\n        if (friendMarketId >= friendMarketCount) revert InvalidMarketId();\n        FriendMarket storage market = friendMarkets[friendMarketId];\n        \n        return (\n            market.marketId,\n            market.marketType,\n            market.creator,\n            market.members,\n            market.arbitrator,\n            market.memberLimit,\n            market.creationFee,\n            market.createdAt,\n            market.active,\n            market.description,\n            market.peggedPublicMarketId,\n            market.autoPegged,\n            market.paymentToken,\n            market.liquidityAmount\n        );\n    }\n    \n    /**\n     * @notice Get all markets for a user\n     * @param user Address of the user\n     */\n    function getUserMarkets(address user) external view returns (uint256[] memory) {\n        return userMarkets[user];\n    }\n    \n    /**\n     * @notice Check if user is a member of a market\n     * @param friendMarketId ID of the friend market\n     * @param user Address to check\n     */\n    function isMember(uint256 friendMarketId, address user) public view returns (bool) {\n        if (friendMarketId >= friendMarketCount) revert InvalidMarketId();\n        FriendMarket storage market = friendMarkets[friendMarketId];\n        \n        for (uint256 i = 0; i < market.members.length; i++) {\n            if (market.members[i] == user) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * @notice Get member count for a market\n     * @param friendMarketId ID of the friend market\n     */\n    function getMemberCount(uint256 friendMarketId) external view returns (uint256) {\n        if (friendMarketId >= friendMarketCount) revert InvalidMarketId();\n        return memberCount[friendMarketId];\n    }\n    \n    /**\n     * @notice Peg an existing friend market to a public market\n     * @param friendMarketId ID of the friend market\n     * @param publicMarketId ID of the public market to peg to\n     */\n    function pegToPublicMarket(uint256 friendMarketId, uint256 publicMarketId) external {\n        if (friendMarketId >= friendMarketCount) revert InvalidMarketId();\n        if (publicMarketId >= marketFactory.marketCount()) revert InvalidMarketId();\n\n        FriendMarket storage market = friendMarkets[friendMarketId];\n        if (!market.active) revert NotActive();\n        if (msg.sender != market.creator) revert NotAuthorized();\n        if (market.autoPegged) revert AlreadyPegged();\n\n        market.peggedPublicMarketId = publicMarketId;\n        market.autoPegged = true;\n        \n        publicMarketToPeggedFriendMarkets[publicMarketId].push(friendMarketId);\n        emit MarketPeggedToPublic(friendMarketId, publicMarketId);\n    }\n    \n    /**\n     * @notice Automatically resolve friend market based on pegged public market\n     * @param friendMarketId ID of the friend market\n     */\n    function autoResolvePeggedMarket(uint256 friendMarketId) external nonReentrant {\n        if (friendMarketId >= friendMarketCount) revert InvalidMarketId();\n\n        FriendMarket storage market = friendMarkets[friendMarketId];\n        if (!market.active) revert NotActive();\n        if (!market.autoPegged) revert NotPegged();\n        if (market.peggedPublicMarketId == 0) revert NotPegged();\n\n        ConditionalMarketFactory.Market memory publicMarket = marketFactory.getMarket(market.peggedPublicMarketId);\n        if (!publicMarket.resolved) revert NotResolved();\n        \n        // Resolve friend market based on public market outcome\n        market.active = false;\n        \n        emit PeggedMarketAutoResolved(\n            friendMarketId,\n            market.peggedPublicMarketId,\n            publicMarket.passValue,\n            publicMarket.failValue\n        );\n        \n        // Also emit standard resolution event\n        bool outcome = publicMarket.passValue > publicMarket.failValue;\n        emit MarketResolved(friendMarketId, msg.sender, outcome);\n    }\n    \n    /**\n     * @notice Batch resolve all pegged markets for a resolved public market\n     * @param publicMarketId ID of the resolved public market\n     */\n    function batchAutoResolvePeggedMarkets(uint256 publicMarketId) external nonReentrant {\n        if (publicMarketId >= marketFactory.marketCount()) revert InvalidMarketId();\n\n        ConditionalMarketFactory.Market memory publicMarket = marketFactory.getMarket(publicMarketId);\n        if (!publicMarket.resolved) revert NotResolved();\n        \n        uint256[] storage peggedMarkets = publicMarketToPeggedFriendMarkets[publicMarketId];\n        \n        for (uint256 i = 0; i < peggedMarkets.length; i++) {\n            uint256 friendMarketId = peggedMarkets[i];\n            FriendMarket storage market = friendMarkets[friendMarketId];\n            \n            if (market.active && market.autoPegged) {\n                market.active = false;\n                \n                emit PeggedMarketAutoResolved(\n                    friendMarketId,\n                    publicMarketId,\n                    publicMarket.passValue,\n                    publicMarket.failValue\n                );\n                \n                bool outcome = publicMarket.passValue > publicMarket.failValue;\n                emit MarketResolved(friendMarketId, msg.sender, outcome);\n            }\n        }\n    }\n    \n    /**\n     * @notice Resolve a friend market based on resolution type\n     * @param friendMarketId ID of the friend market\n     * @param outcome True for positive outcome, false for negative\n     * @dev NOTE: This simplified implementation emits events only.\n     * In production, this would integrate with OracleResolver to properly\n     * resolve the underlying ConditionalMarketFactory market and enable\n     * token redemption based on the outcome.\n     */\n    function resolveFriendMarket(uint256 friendMarketId, bool outcome) external {\n        if (friendMarketId >= friendMarketCount) revert InvalidMarketId();\n        FriendMarket storage market = friendMarkets[friendMarketId];\n        if (!market.active) revert NotActive();\n        if (market.autoPegged) revert AlreadyPegged();\n\n        bool canResolve = false;\n\n        // Determine resolution authority based on resolutionType\n        if (market.resolutionType == ResolutionType.Either) {\n            // Either creator or opponent can resolve (default behavior)\n            // Also allows arbitrator if set\n            canResolve = msg.sender == market.creator ||\n                         (market.members.length > 1 && msg.sender == market.members[1]) ||\n                         (market.arbitrator != address(0) && msg.sender == market.arbitrator);\n        } else if (market.resolutionType == ResolutionType.Initiator) {\n            // Only creator can resolve\n            canResolve = msg.sender == market.creator;\n        } else if (market.resolutionType == ResolutionType.Receiver) {\n            // Only opponent (second member) can resolve\n            canResolve = market.members.length > 1 && msg.sender == market.members[1];\n        } else if (market.resolutionType == ResolutionType.ThirdParty) {\n            // Only designated arbitrator can resolve\n            canResolve = market.arbitrator != address(0) && msg.sender == market.arbitrator;\n        } else if (market.resolutionType == ResolutionType.AutoPegged) {\n            // Auto-pegged markets should use autoResolvePeggedMarket instead\n            revert NotAuthorized();\n        }\n\n        if (!canResolve) revert NotAuthorized();\n\n        market.active = false;\n        market.status = FriendMarketStatus.Resolved;\n\n        // Resolve underlying market\n        // NOTE: In production, this would call marketFactory.resolveMarket()\n        // or OracleResolver to properly resolve the underlying market and\n        // enable participants to redeem their tokens based on the outcome.\n        // Current implementation emits events for tracking purposes only.\n        emit MarketResolved(friendMarketId, msg.sender, outcome);\n    }\n    \n    /**\n     * @notice Withdraw accumulated fees (owner only)\n     */\n    function withdrawFees() external onlyOwner {\n        uint256 balance = address(this).balance;\n        if (balance == 0) revert InsufficientPayment();\n\n        (bool success, ) = payable(owner()).call{value: balance}(\"\");\n        if (!success) revert TransferFailed();\n    }\n\n    function updateMarketFactory(address _marketFactory) external onlyOwner {\n        if (_marketFactory == address(0)) revert InvalidAddress();\n        marketFactory = ConditionalMarketFactory(_marketFactory);\n    }\n\n    function updateRagequitModule(address payable _ragequitModule) external onlyOwner {\n        if (_ragequitModule == address(0)) revert InvalidAddress();\n        ragequitModule = RagequitModule(_ragequitModule);\n    }\n\n    function getPeggedFriendMarkets(uint256 publicMarketId) external view returns (uint256[] memory) {\n        if (publicMarketId >= marketFactory.marketCount()) revert InvalidMarketId();\n        return publicMarketToPeggedFriendMarkets[publicMarketId];\n    }\n\n    /**\n     * @notice Get list of accepted payment tokens (returns full list, check acceptedPaymentTokens for status)\n     */\n    function getAcceptedTokens() external view returns (address[] memory) {\n        return acceptedTokenList;\n    }\n    \n    receive() external payable {}\n}\n"
    },
    "contracts/markets/FriendGroupMarketLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../security/NullifierRegistry.sol\";\n\n/**\n * @title FriendGroupMarketLib\n * @notice Library for FriendGroupMarketFactory helper functions\n * @dev Extracted to reduce main contract bytecode size below EIP-170 limit\n */\nlibrary FriendGroupMarketLib {\n    using SafeERC20 for IERC20;\n\n    // Custom errors (shared with main contract)\n    error TransferFailed();\n    error InsufficientPayment();\n    error AddressNullified();\n    error InvalidMember();\n    error DuplicateMember();\n\n    /**\n     * @notice Collect stake from a participant\n     * @param from Address to collect from\n     * @param token Token address (address(0) for native)\n     * @param amount Amount to collect\n     */\n    function collectStake(address from, address token, uint256 amount) internal {\n        if (token == address(0)) {\n            if (msg.value < amount) revert InsufficientPayment();\n            if (msg.value > amount) {\n                (bool success, ) = payable(from).call{value: msg.value - amount}(\"\");\n                if (!success) revert TransferFailed();\n            }\n        } else {\n            IERC20(token).safeTransferFrom(from, address(this), amount);\n        }\n    }\n\n    /**\n     * @notice Refund stake to a single participant\n     * @param to Address to refund to\n     * @param token Token address (address(0) for native)\n     * @param amount Amount to refund\n     */\n    function refundStake(address to, address token, uint256 amount) internal {\n        if (token == address(0)) {\n            (bool success, ) = payable(to).call{value: amount}(\"\");\n            if (!success) revert TransferFailed();\n        } else {\n            // Use low-level call for proxy token compatibility\n            (bool success, bytes memory returnData) = token.call(\n                abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\n            );\n            if (!success) revert TransferFailed();\n            if (returnData.length > 0 && !abi.decode(returnData, (bool))) revert TransferFailed();\n        }\n    }\n\n    /**\n     * @notice Check if an address is nullified\n     * @param registry NullifierRegistry contract\n     * @param enforce Whether enforcement is enabled\n     * @param addr Address to check\n     */\n    function checkNullification(\n        NullifierRegistry registry,\n        bool enforce,\n        address addr\n    ) internal view {\n        if (!enforce || address(registry) == address(0)) return;\n        if (registry.isAddressNullified(addr)) revert AddressNullified();\n    }\n\n    /**\n     * @notice Check nullification for multiple addresses\n     * @param registry NullifierRegistry contract\n     * @param enforce Whether enforcement is enabled\n     * @param addresses Array of addresses to check\n     */\n    function checkNullificationBatch(\n        NullifierRegistry registry,\n        bool enforce,\n        address[] memory addresses\n    ) internal view {\n        if (!enforce || address(registry) == address(0)) return;\n        for (uint256 i = 0; i < addresses.length; i++) {\n            if (registry.isAddressNullified(addresses[i])) revert AddressNullified();\n        }\n    }\n\n    /**\n     * @notice Validate member array (no zeros, no duplicates)\n     * @param members Array of member addresses\n     */\n    function validateMembers(address[] memory members) internal pure {\n        for (uint256 i = 0; i < members.length; i++) {\n            if (members[i] == address(0)) revert InvalidMember();\n            for (uint256 j = i + 1; j < members.length; j++) {\n                if (members[i] == members[j]) revert DuplicateMember();\n            }\n        }\n    }\n\n    /**\n     * @notice Validate member array excluding sender\n     * @param members Array of member addresses\n     * @param sender Address to exclude from validation\n     */\n    function validateMembersExcluding(address[] memory members, address sender) internal pure {\n        for (uint256 i = 0; i < members.length; i++) {\n            if (members[i] == address(0) || members[i] == sender) revert InvalidMember();\n            for (uint256 j = i + 1; j < members.length; j++) {\n                if (members[i] == members[j]) revert DuplicateMember();\n            }\n        }\n    }\n}\n"
    },
    "contracts/privacy/ZKKeyManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\n/**\n * @title ZKKeyManager\n * @notice Production-ready ZK key lifecycle management for ClearPath system\n * @dev Manages registration, rotation, and revocation of zero-knowledge public keys\n * \n * Key Lifecycle:\n * 1. Registration - User registers initial ZK public key\n * 2. Active - Key is valid and can be used for ZK proofs\n * 3. Rotation - User can rotate to a new key, invalidating old key\n * 4. Revocation - Admin or user can revoke a key\n * 5. Expired - Keys automatically expire after configured duration\n */\ncontract ZKKeyManager is AccessControl, Pausable {\n    \n    // ========== Role Definitions ==========\n    \n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant CLEARPATH_USER_ROLE = keccak256(\"CLEARPATH_USER_ROLE\");\n    bytes32 public constant DELEGATE_ROLE = keccak256(\"DELEGATE_ROLE\"); // For contracts acting on behalf of users\n    \n    // ========== Key Status ==========\n    \n    enum KeyStatus {\n        NONE,           // Key doesn't exist\n        ACTIVE,         // Key is valid\n        ROTATED,        // Key has been rotated (replaced)\n        REVOKED,        // Key has been revoked\n        EXPIRED         // Key has expired\n    }\n    \n    // ========== Key Metadata ==========\n    \n    struct ZKKey {\n        bytes32 keyHash;        // Hash of the public key for efficient storage\n        string publicKey;       // Full public key string\n        uint256 registeredAt;   // Timestamp of registration\n        uint256 expiresAt;      // Expiration timestamp\n        KeyStatus status;       // Current status\n        uint256 rotationCount;  // Number of times user has rotated\n        bytes32 previousKeyHash; // Hash of previous key (for rotation history)\n    }\n    \n    // ========== Storage ==========\n    \n    // User address => current key hash\n    mapping(address => bytes32) public currentKeyHash;\n    \n    // Key hash => ZKKey metadata\n    mapping(bytes32 => ZKKey) public keys;\n    \n    // User address => all key hashes (history)\n    mapping(address => bytes32[]) public userKeyHistory;\n    \n    // Nonce for key hash generation (prevents predictability)\n    uint256 private keyNonce;\n    \n    // Configuration\n    uint256 public keyExpirationDuration;  // Default: 365 days\n    uint256 public maxRotationsPerYear;     // Rate limiting\n    bool public requireKeyExpiration;       // Toggle expiration requirement\n    \n    // Rate limiting tracking\n    mapping(address => uint256) public rotationsThisYear;\n    mapping(address => uint256) public yearStartTime;\n    \n    // ========== Events ==========\n    \n    event KeyRegistered(\n        address indexed user,\n        bytes32 indexed keyHash,\n        uint256 expiresAt,\n        uint256 timestamp\n    );\n    \n    event KeyRotated(\n        address indexed user,\n        bytes32 indexed oldKeyHash,\n        bytes32 indexed newKeyHash,\n        uint256 timestamp\n    );\n    \n    event KeyRevoked(\n        address indexed user,\n        bytes32 indexed keyHash,\n        address indexed revoker,\n        uint256 timestamp\n    );\n    \n    event KeyExpired(\n        address indexed user,\n        bytes32 indexed keyHash,\n        uint256 timestamp\n    );\n    \n    event ConfigurationUpdated(\n        uint256 keyExpirationDuration,\n        uint256 maxRotationsPerYear,\n        bool requireKeyExpiration\n    );\n    \n    // ========== Errors ==========\n    \n    error KeyAlreadyExists(address user);\n    error NoKeyRegistered(address user);\n    error InvalidKeyFormat(string reason);\n    error KeyNotActive(bytes32 keyHash, KeyStatus status);\n    error RateLimitExceeded(address user, uint256 rotationsThisYear);\n    error UnauthorizedRevocation(address caller, address keyOwner);\n    error KeyExpiredError(bytes32 keyHash);\n    \n    // ========== Constructor ==========\n    \n    constructor() {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN_ROLE, msg.sender);\n        \n        // Default configuration\n        keyExpirationDuration = 365 days;\n        maxRotationsPerYear = 4;  // Once per quarter\n        requireKeyExpiration = true;\n    }\n    \n    // ========== Key Registration ==========\n    \n    /**\n     * @notice Register a new ZK public key\n     * @param publicKey The zero-knowledge public key (base64 or hex encoded)\n     * @dev Validates key format and creates new key entry\n     */\n    function registerKey(string memory publicKey) external whenNotPaused {\n        _registerKeyFor(msg.sender, publicKey);\n    }\n    \n    /**\n     * @notice Register a new ZK public key for a user (delegate call)\n     * @param user The user to register the key for\n     * @param publicKey The zero-knowledge public key\n     * @dev Can only be called by contracts with DELEGATE_ROLE\n     */\n    function registerKeyFor(address user, string memory publicKey) external whenNotPaused {\n        require(hasRole(DELEGATE_ROLE, msg.sender), \"Not authorized delegate\");\n        _registerKeyFor(user, publicKey);\n    }\n    \n    /**\n     * @dev Internal function to register a key for a user\n     */\n    function _registerKeyFor(address user, string memory publicKey) internal {\n        // Check user doesn't already have an active key\n        bytes32 existingKeyHash = currentKeyHash[user];\n        if (existingKeyHash != bytes32(0)) {\n            ZKKey storage existingKey = keys[existingKeyHash];\n            if (existingKey.status == KeyStatus.ACTIVE && !_isExpired(existingKey)) {\n                revert KeyAlreadyExists(user);\n            }\n        }\n        \n        // Validate key format\n        _validateKeyFormat(publicKey);\n        \n        // Create key hash with multiple sources of entropy\n        // Using: user address, public key, block timestamp, and incrementing nonce\n        // This ensures uniqueness and unpredictability without relying on prevrandao\n        bytes32 keyHash = keccak256(abi.encodePacked(\n            user, \n            publicKey, \n            block.timestamp,\n            ++keyNonce\n        ));\n        \n        // Calculate expiration\n        uint256 expiresAt = requireKeyExpiration \n            ? block.timestamp + keyExpirationDuration \n            : type(uint256).max;\n        \n        // Store key metadata\n        keys[keyHash] = ZKKey({\n            keyHash: keyHash,\n            publicKey: publicKey,\n            registeredAt: block.timestamp,\n            expiresAt: expiresAt,\n            status: KeyStatus.ACTIVE,\n            rotationCount: 0,\n            previousKeyHash: bytes32(0)\n        });\n        \n        // Update current key\n        currentKeyHash[user] = keyHash;\n        \n        // Add to history\n        userKeyHistory[user].push(keyHash);\n        \n        // Initialize rate limiting\n        if (yearStartTime[user] == 0) {\n            yearStartTime[user] = block.timestamp;\n        }\n        \n        emit KeyRegistered(user, keyHash, expiresAt, block.timestamp);\n    }\n    \n    // ========== Key Rotation ==========\n    \n    /**\n     * @notice Rotate to a new ZK public key\n     * @param newPublicKey The new zero-knowledge public key\n     * @dev Marks old key as ROTATED and registers new key\n     */\n    function rotateKey(string memory newPublicKey) external whenNotPaused {\n        _rotateKeyFor(msg.sender, newPublicKey);\n    }\n    \n    /**\n     * @notice Rotate to a new ZK public key for a user (delegate call)\n     * @param user The user to rotate the key for\n     * @param newPublicKey The new zero-knowledge public key\n     * @dev Can only be called by contracts with DELEGATE_ROLE\n     */\n    function rotateKeyFor(address user, string memory newPublicKey) external whenNotPaused {\n        require(hasRole(DELEGATE_ROLE, msg.sender), \"Not authorized delegate\");\n        _rotateKeyFor(user, newPublicKey);\n    }\n    \n    /**\n     * @dev Internal function to rotate a key for a user\n     */\n    function _rotateKeyFor(address user, string memory newPublicKey) internal {\n        bytes32 oldKeyHash = currentKeyHash[user];\n        if (oldKeyHash == bytes32(0)) {\n            revert NoKeyRegistered(user);\n        }\n        \n        ZKKey storage oldKey = keys[oldKeyHash];\n        if (oldKey.status != KeyStatus.ACTIVE) {\n            revert KeyNotActive(oldKeyHash, oldKey.status);\n        }\n        \n        // Check rate limiting\n        _checkRotationRateLimit(user);\n        \n        // Validate new key format\n        _validateKeyFormat(newPublicKey);\n        \n        // Create new key hash with multiple sources of entropy\n        bytes32 newKeyHash = keccak256(abi.encodePacked(\n            user, \n            newPublicKey, \n            block.timestamp,\n            ++keyNonce\n        ));\n        \n        // Calculate expiration\n        uint256 expiresAt = requireKeyExpiration \n            ? block.timestamp + keyExpirationDuration \n            : type(uint256).max;\n        \n        // Mark old key as rotated\n        oldKey.status = KeyStatus.ROTATED;\n        \n        // Create new key\n        keys[newKeyHash] = ZKKey({\n            keyHash: newKeyHash,\n            publicKey: newPublicKey,\n            registeredAt: block.timestamp,\n            expiresAt: expiresAt,\n            status: KeyStatus.ACTIVE,\n            rotationCount: oldKey.rotationCount + 1,\n            previousKeyHash: oldKeyHash\n        });\n        \n        // Update current key\n        currentKeyHash[user] = newKeyHash;\n        \n        // Add to history\n        userKeyHistory[user].push(newKeyHash);\n        \n        // Update rate limiting\n        rotationsThisYear[user]++;\n        \n        emit KeyRotated(user, oldKeyHash, newKeyHash, block.timestamp);\n    }\n    \n    // ========== Key Revocation ==========\n    \n    /**\n     * @notice Revoke a ZK public key\n     * @param user Address of the key owner\n     * @dev Can be called by key owner, admin, or delegate (e.g., RoleManager)\n     */\n    function revokeKey(address user) external whenNotPaused {\n        // Check authorization: user themselves, admin, or delegate\n        if (msg.sender != user && !hasRole(ADMIN_ROLE, msg.sender) && !hasRole(DELEGATE_ROLE, msg.sender)) {\n            revert UnauthorizedRevocation(msg.sender, user);\n        }\n        \n        bytes32 keyHash = currentKeyHash[user];\n        if (keyHash == bytes32(0)) {\n            revert NoKeyRegistered(user);\n        }\n        \n        ZKKey storage key = keys[keyHash];\n        if (key.status != KeyStatus.ACTIVE) {\n            revert KeyNotActive(keyHash, key.status);\n        }\n        \n        // Mark as revoked\n        key.status = KeyStatus.REVOKED;\n        \n        emit KeyRevoked(user, keyHash, msg.sender, block.timestamp);\n    }\n    \n    // ========== Key Validation ==========\n    \n    /**\n     * @notice Validate that a user has an active ZK key\n     * @param user Address to check\n     * @return bool True if user has valid active key\n     */\n    function hasValidKey(address user) external view returns (bool) {\n        bytes32 keyHash = currentKeyHash[user];\n        if (keyHash == bytes32(0)) {\n            return false;\n        }\n        \n        ZKKey storage key = keys[keyHash];\n        return key.status == KeyStatus.ACTIVE && !_isExpired(key);\n    }\n    \n    /**\n     * @notice Get user's current public key\n     * @param user Address to query\n     * @return publicKey The current public key string\n     */\n    function getPublicKey(address user) external view returns (string memory) {\n        bytes32 keyHash = currentKeyHash[user];\n        if (keyHash == bytes32(0)) {\n            return \"\";\n        }\n        \n        return keys[keyHash].publicKey;\n    }\n    \n    /**\n     * @notice Get detailed key metadata\n     * @param user Address to query\n     * @return key The ZKKey struct\n     */\n    function getKeyMetadata(address user) external view returns (ZKKey memory) {\n        bytes32 keyHash = currentKeyHash[user];\n        require(keyHash != bytes32(0), \"No key registered\");\n        \n        return keys[keyHash];\n    }\n    \n    /**\n     * @notice Get user's key rotation history\n     * @param user Address to query\n     * @return Array of key hashes in chronological order\n     */\n    function getKeyHistory(address user) external view returns (bytes32[] memory) {\n        return userKeyHistory[user];\n    }\n    \n    /**\n     * @notice Check if a specific key is valid and active\n     * @param keyHash Hash of the key to check\n     * @return bool True if key is active and not expired\n     */\n    function isKeyValid(bytes32 keyHash) external view returns (bool) {\n        ZKKey storage key = keys[keyHash];\n        return key.status == KeyStatus.ACTIVE && !_isExpired(key);\n    }\n    \n    // ========== Internal Functions ==========\n    \n    /**\n     * @dev Validate key format and length\n     */\n    function _validateKeyFormat(string memory publicKey) internal pure {\n        bytes memory keyBytes = bytes(publicKey);\n        \n        // Minimum length check (typical ZK keys are 64+ characters)\n        if (keyBytes.length < 32) {\n            revert InvalidKeyFormat(\"Key too short\");\n        }\n        \n        // Maximum length check (prevent DoS)\n        if (keyBytes.length > 512) {\n            revert InvalidKeyFormat(\"Key too long\");\n        }\n        \n        // Check for empty or only whitespace\n        if (keyBytes.length == 0) {\n            revert InvalidKeyFormat(\"Key is empty\");\n        }\n    }\n    \n    /**\n     * @dev Check if key has expired\n     */\n    function _isExpired(ZKKey storage key) internal view returns (bool) {\n        if (!requireKeyExpiration) {\n            return false;\n        }\n        return block.timestamp >= key.expiresAt;\n    }\n    \n    /**\n     * @dev Check rotation rate limit\n     */\n    function _checkRotationRateLimit(address user) internal {\n        // Reset counter if year has passed\n        if (block.timestamp >= yearStartTime[user] + 365 days) {\n            yearStartTime[user] = block.timestamp;\n            rotationsThisYear[user] = 0;\n        }\n        \n        // Check limit\n        if (rotationsThisYear[user] >= maxRotationsPerYear) {\n            revert RateLimitExceeded(user, rotationsThisYear[user]);\n        }\n    }\n    \n    // ========== Admin Functions ==========\n    \n    /**\n     * @notice Update configuration parameters\n     * @param _keyExpirationDuration New expiration duration in seconds\n     * @param _maxRotationsPerYear New max rotations per year\n     * @param _requireKeyExpiration Whether to enforce expiration\n     */\n    function updateConfiguration(\n        uint256 _keyExpirationDuration,\n        uint256 _maxRotationsPerYear,\n        bool _requireKeyExpiration\n    ) external onlyRole(ADMIN_ROLE) {\n        require(_keyExpirationDuration >= 30 days, \"Expiration too short\");\n        require(_keyExpirationDuration <= 730 days, \"Expiration too long\");\n        require(_maxRotationsPerYear > 0, \"Must allow rotations\");\n        require(_maxRotationsPerYear <= 52, \"Too many rotations\");\n        \n        keyExpirationDuration = _keyExpirationDuration;\n        maxRotationsPerYear = _maxRotationsPerYear;\n        requireKeyExpiration = _requireKeyExpiration;\n        \n        emit ConfigurationUpdated(_keyExpirationDuration, _maxRotationsPerYear, _requireKeyExpiration);\n    }\n    \n    /**\n     * @notice Emergency pause\n     */\n    function pause() external onlyRole(ADMIN_ROLE) {\n        _pause();\n    }\n    \n    /**\n     * @notice Unpause\n     */\n    function unpause() external onlyRole(ADMIN_ROLE) {\n        _unpause();\n    }\n    \n    /**\n     * @notice Manually expire a key (admin only)\n     * @param user Address of key owner\n     */\n    function expireKey(address user) external onlyRole(ADMIN_ROLE) {\n        bytes32 keyHash = currentKeyHash[user];\n        require(keyHash != bytes32(0), \"No key registered\");\n        \n        ZKKey storage key = keys[keyHash];\n        require(key.status == KeyStatus.ACTIVE, \"Key not active\");\n        \n        key.status = KeyStatus.EXPIRED;\n        \n        emit KeyExpired(user, keyHash, block.timestamp);\n    }\n}\n"
    },
    "contracts/security/NullifierRegistry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"../libraries/RSAAccumulator.sol\";\nimport \"../libraries/PrimeMapping.sol\";\n\n/**\n * @title NullifierRegistry\n * @notice Manages nullified markets and addresses using an RSA accumulator\n * @dev Provides efficient set membership management for protecting the platform from malicious markets/actors.\n *\n *      Architecture:\n *      - On-chain: Stores nullification status, accumulator value, and provides verification\n *      - Off-chain: Accumulator updates and witness generation (for gas efficiency)\n *      - Frontend: Validates market/address status before display\n *\n *      RSA Accumulator Benefits:\n *      - O(1) storage regardless of set size (just the accumulator value)\n *      - Compact non-membership proofs (~256 bytes for 2048-bit RSA)\n *      - Privacy: Set contents not revealed, only membership status\n *      - Efficient batch operations for adding/removing elements\n *\n *      Security Model:\n *      - RSA modulus generated via trusted setup (two secret safe primes)\n *      - Admins can nullify markets/addresses but cannot forge membership proofs\n *      - Accumulator updates require admin role\n *      - On-chain verification available for critical operations\n *\n *      Integration:\n *      - Frontend queries nullification status before displaying markets\n *      - ConditionalMarketFactory can optionally check nullification\n *      - Admin panel provides UI for nullification management\n */\ncontract NullifierRegistry is AccessControl, ReentrancyGuard, Pausable {\n    using RSAAccumulator for RSAAccumulator.AccumulatorParams;\n    using PrimeMapping for bytes32;\n\n    // ========== Constants ==========\n\n    /// @notice Role that can manage nullifications\n    bytes32 public constant NULLIFIER_ADMIN_ROLE = keccak256(\"NULLIFIER_ADMIN_ROLE\");\n\n    /// @notice Maximum number of nullifications in a single batch\n    uint256 public constant MAX_BATCH_SIZE = 50;\n\n    /// @notice RSA key size in bytes (2048 bits)\n    uint256 public constant RSA_BYTES = 256;\n\n    // ========== State Variables ==========\n\n    /// @notice RSA accumulator parameters (immutable after initialization)\n    RSAAccumulator.AccumulatorParams public accumulatorParams;\n\n    /// @notice Current accumulator value A = g^(product of all nullified primes) mod n\n    bytes public accumulator;\n\n    /// @notice Whether RSA parameters have been initialized\n    bool public paramsInitialized;\n\n    /// @notice Nullified market hashes (marketHash => nullified)\n    mapping(bytes32 => bool) public nullifiedMarkets;\n\n    /// @notice Nullified addresses (address => nullified)\n    mapping(address => bool) public nullifiedAddresses;\n\n    /// @notice Market hash to nullification timestamp\n    mapping(bytes32 => uint256) public marketNullifiedAt;\n\n    /// @notice Address to nullification timestamp\n    mapping(address => uint256) public addressNullifiedAt;\n\n    /// @notice Market hash to nullifying admin\n    mapping(bytes32 => address) public marketNullifiedBy;\n\n    /// @notice Address to nullifying admin\n    mapping(address => address) public addressNullifiedBy;\n\n    /// @notice Count of nullified markets\n    uint256 public nullifiedMarketCount;\n\n    /// @notice Count of nullified addresses\n    uint256 public nullifiedAddressCount;\n\n    /// @notice Total nullification operations performed\n    uint256 public totalNullifications;\n\n    /// @notice Total reinstatement operations performed\n    uint256 public totalReinstatements;\n\n    /// @notice Last accumulator update timestamp\n    uint256 public lastAccumulatorUpdate;\n\n    /// @notice Array of all nullified market hashes (for enumeration)\n    bytes32[] public nullifiedMarketList;\n\n    /// @notice Array of all nullified addresses (for enumeration)\n    address[] public nullifiedAddressList;\n\n    /// @notice Index lookup for market hashes\n    mapping(bytes32 => uint256) private marketListIndex;\n\n    /// @notice Index lookup for addresses\n    mapping(address => uint256) private addressListIndex;\n\n    // ========== Events ==========\n\n    event RSAParamsInitialized(uint256 timestamp);\n\n    event MarketNullified(\n        bytes32 indexed marketHash,\n        uint256 indexed marketId,\n        address indexed admin,\n        uint256 timestamp,\n        string reason\n    );\n\n    event MarketReinstated(\n        bytes32 indexed marketHash,\n        uint256 indexed marketId,\n        address indexed admin,\n        uint256 timestamp,\n        string reason\n    );\n\n    event AddressNullified(\n        address indexed nullifiedAddr,\n        address indexed admin,\n        uint256 timestamp,\n        string reason\n    );\n\n    event AddressReinstated(\n        address indexed reinstatedAddr,\n        address indexed admin,\n        uint256 timestamp,\n        string reason\n    );\n\n    event AccumulatorUpdated(\n        bytes newAccumulator,\n        uint256 timestamp,\n        address indexed updater\n    );\n\n    event BatchMarketsNullified(\n        bytes32[] marketHashes,\n        address indexed admin,\n        uint256 timestamp\n    );\n\n    event BatchAddressesNullified(\n        address[] addresses,\n        address indexed admin,\n        uint256 timestamp\n    );\n\n    // ========== Errors ==========\n\n    error ParamsAlreadyInitialized();\n    error ParamsNotInitialized();\n    error InvalidRSAModulus();\n    error InvalidGenerator();\n    error InvalidAccumulator();\n    error MarketAlreadyNullified();\n    error MarketNotNullified();\n    error AddressAlreadyNullified();\n    error AddressNotNullified();\n    error InvalidAddress();\n    error BatchTooLarge();\n    error EmptyBatch();\n\n    // ========== Constructor ==========\n\n    constructor() {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setRoleAdmin(NULLIFIER_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\n    }\n\n    // ========== Initialization ==========\n\n    /**\n     * @notice Initialize RSA accumulator parameters\n     * @dev Can only be called once. RSA modulus should be generated via trusted setup.\n     *      The modulus n must be a product of two safe primes p, q where:\n     *      - p = 2p' + 1 and q = 2q' + 1 for primes p' and q'\n     *      - Generator g must be a quadratic residue mod n\n     *\n     * @param n RSA modulus (2048 bits = 256 bytes)\n     * @param g Generator element\n     * @param initialAccumulator Initial accumulator value (typically g)\n     */\n    function initializeParams(\n        bytes calldata n,\n        bytes calldata g,\n        bytes calldata initialAccumulator\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (paramsInitialized) revert ParamsAlreadyInitialized();\n        if (n.length != RSA_BYTES) revert InvalidRSAModulus();\n        if (g.length != RSA_BYTES) revert InvalidGenerator();\n        if (initialAccumulator.length != RSA_BYTES) revert InvalidAccumulator();\n\n        accumulatorParams.n = n;\n        accumulatorParams.g = g;\n        accumulator = initialAccumulator;\n        paramsInitialized = true;\n        lastAccumulatorUpdate = block.timestamp;\n\n        emit RSAParamsInitialized(block.timestamp);\n    }\n\n    // ========== Market Nullification ==========\n\n    /**\n     * @notice Nullify a market, preventing it from being displayed or traded\n     * @param marketHash The keccak256 hash of the market data\n     * @param marketId The market ID (for event logging)\n     * @param reason Human-readable reason for nullification\n     */\n    function nullifyMarket(\n        bytes32 marketHash,\n        uint256 marketId,\n        string calldata reason\n    ) external onlyRole(NULLIFIER_ADMIN_ROLE) whenNotPaused {\n        if (nullifiedMarkets[marketHash]) revert MarketAlreadyNullified();\n\n        nullifiedMarkets[marketHash] = true;\n        marketNullifiedAt[marketHash] = block.timestamp;\n        marketNullifiedBy[marketHash] = msg.sender;\n\n        // Add to enumerable list\n        marketListIndex[marketHash] = nullifiedMarketList.length;\n        nullifiedMarketList.push(marketHash);\n\n        nullifiedMarketCount++;\n        totalNullifications++;\n\n        emit MarketNullified(marketHash, marketId, msg.sender, block.timestamp, reason);\n    }\n\n    /**\n     * @notice Reinstate a previously nullified market\n     * @param marketHash The market hash to reinstate\n     * @param marketId The market ID (for event logging)\n     * @param reason Human-readable reason for reinstatement\n     */\n    function reinstateMarket(\n        bytes32 marketHash,\n        uint256 marketId,\n        string calldata reason\n    ) external onlyRole(NULLIFIER_ADMIN_ROLE) whenNotPaused {\n        if (!nullifiedMarkets[marketHash]) revert MarketNotNullified();\n\n        nullifiedMarkets[marketHash] = false;\n        marketNullifiedAt[marketHash] = 0;\n        marketNullifiedBy[marketHash] = address(0);\n\n        // Remove from enumerable list (swap and pop)\n        _removeFromMarketList(marketHash);\n\n        nullifiedMarketCount--;\n        totalReinstatements++;\n\n        emit MarketReinstated(marketHash, marketId, msg.sender, block.timestamp, reason);\n    }\n\n    /**\n     * @notice Batch nullify multiple markets\n     * @param marketHashes Array of market hashes to nullify\n     * @param marketIds Array of market IDs (for event logging)\n     * @param reason Shared reason for all nullifications\n     */\n    function batchNullifyMarkets(\n        bytes32[] calldata marketHashes,\n        uint256[] calldata marketIds,\n        string calldata reason\n    ) external onlyRole(NULLIFIER_ADMIN_ROLE) whenNotPaused {\n        if (marketHashes.length == 0) revert EmptyBatch();\n        if (marketHashes.length > MAX_BATCH_SIZE) revert BatchTooLarge();\n        if (marketHashes.length != marketIds.length) revert(\"Length mismatch\");\n\n        for (uint256 i = 0; i < marketHashes.length; i++) {\n            bytes32 marketHash = marketHashes[i];\n            if (!nullifiedMarkets[marketHash]) {\n                nullifiedMarkets[marketHash] = true;\n                marketNullifiedAt[marketHash] = block.timestamp;\n                marketNullifiedBy[marketHash] = msg.sender;\n\n                marketListIndex[marketHash] = nullifiedMarketList.length;\n                nullifiedMarketList.push(marketHash);\n\n                nullifiedMarketCount++;\n                totalNullifications++;\n\n                emit MarketNullified(marketHash, marketIds[i], msg.sender, block.timestamp, reason);\n            }\n        }\n\n        emit BatchMarketsNullified(marketHashes, msg.sender, block.timestamp);\n    }\n\n    // ========== Address Nullification ==========\n\n    /**\n     * @notice Nullify an address, preventing it from interacting with the platform\n     * @param addr The address to nullify\n     * @param reason Human-readable reason for nullification\n     */\n    function nullifyAddress(\n        address addr,\n        string calldata reason\n    ) external onlyRole(NULLIFIER_ADMIN_ROLE) whenNotPaused {\n        if (addr == address(0)) revert InvalidAddress();\n        if (nullifiedAddresses[addr]) revert AddressAlreadyNullified();\n\n        nullifiedAddresses[addr] = true;\n        addressNullifiedAt[addr] = block.timestamp;\n        addressNullifiedBy[addr] = msg.sender;\n\n        // Add to enumerable list\n        addressListIndex[addr] = nullifiedAddressList.length;\n        nullifiedAddressList.push(addr);\n\n        nullifiedAddressCount++;\n        totalNullifications++;\n\n        emit AddressNullified(addr, msg.sender, block.timestamp, reason);\n    }\n\n    /**\n     * @notice Reinstate a previously nullified address\n     * @param addr The address to reinstate\n     * @param reason Human-readable reason for reinstatement\n     */\n    function reinstateAddress(\n        address addr,\n        string calldata reason\n    ) external onlyRole(NULLIFIER_ADMIN_ROLE) whenNotPaused {\n        if (!nullifiedAddresses[addr]) revert AddressNotNullified();\n\n        nullifiedAddresses[addr] = false;\n        addressNullifiedAt[addr] = 0;\n        addressNullifiedBy[addr] = address(0);\n\n        // Remove from enumerable list\n        _removeFromAddressList(addr);\n\n        nullifiedAddressCount--;\n        totalReinstatements++;\n\n        emit AddressReinstated(addr, msg.sender, block.timestamp, reason);\n    }\n\n    /**\n     * @notice Batch nullify multiple addresses\n     * @param addrs Array of addresses to nullify\n     * @param reason Shared reason for all nullifications\n     */\n    function batchNullifyAddresses(\n        address[] calldata addrs,\n        string calldata reason\n    ) external onlyRole(NULLIFIER_ADMIN_ROLE) whenNotPaused {\n        if (addrs.length == 0) revert EmptyBatch();\n        if (addrs.length > MAX_BATCH_SIZE) revert BatchTooLarge();\n\n        for (uint256 i = 0; i < addrs.length; i++) {\n            address addr = addrs[i];\n            if (addr != address(0) && !nullifiedAddresses[addr]) {\n                nullifiedAddresses[addr] = true;\n                addressNullifiedAt[addr] = block.timestamp;\n                addressNullifiedBy[addr] = msg.sender;\n\n                addressListIndex[addr] = nullifiedAddressList.length;\n                nullifiedAddressList.push(addr);\n\n                nullifiedAddressCount++;\n                totalNullifications++;\n\n                emit AddressNullified(addr, msg.sender, block.timestamp, reason);\n            }\n        }\n\n        emit BatchAddressesNullified(addrs, msg.sender, block.timestamp);\n    }\n\n    // ========== Accumulator Management ==========\n\n    /**\n     * @notice Update the RSA accumulator value\n     * @dev Called after off-chain computation of new accumulator value\n     *      The new value should be: g^(product of all nullified element primes) mod n\n     *\n     * @param newAccumulator The updated accumulator value\n     */\n    function updateAccumulator(\n        bytes calldata newAccumulator\n    ) external onlyRole(NULLIFIER_ADMIN_ROLE) whenNotPaused {\n        if (!paramsInitialized) revert ParamsNotInitialized();\n        if (newAccumulator.length != RSA_BYTES) revert InvalidAccumulator();\n\n        accumulator = newAccumulator;\n        lastAccumulatorUpdate = block.timestamp;\n\n        emit AccumulatorUpdated(newAccumulator, block.timestamp, msg.sender);\n    }\n\n    // ========== Verification Functions ==========\n\n    /**\n     * @notice Check if a market is nullified (simple lookup)\n     * @param marketHash The market hash to check\n     * @return True if the market is nullified\n     */\n    function isMarketNullified(bytes32 marketHash) external view returns (bool) {\n        return nullifiedMarkets[marketHash];\n    }\n\n    /**\n     * @notice Check if an address is nullified (simple lookup)\n     * @param addr The address to check\n     * @return True if the address is nullified\n     */\n    function isAddressNullified(address addr) external view returns (bool) {\n        return nullifiedAddresses[addr];\n    }\n\n    /**\n     * @notice Verify non-membership using RSA accumulator proof\n     * @dev Verifies that an element is NOT in the nullified set using cryptographic proof\n     *      This is useful for trustless verification without querying contract state\n     *\n     * @param elementHash Hash of the element (market or address)\n     * @param witnessD Bezout coefficient d from the proof\n     * @param witnessB Base component b from the proof\n     * @param dNegative Whether d is negative\n     * @return valid True if the proof verifies (element is NOT nullified)\n     */\n    function verifyNonMembership(\n        bytes32 elementHash,\n        bytes calldata witnessD,\n        bytes calldata witnessB,\n        bool dNegative\n    ) external view returns (bool valid) {\n        if (!paramsInitialized) revert ParamsNotInitialized();\n\n        // Convert element hash to prime\n        (, uint256 primeUint) = RSAAccumulator.hashToPrime(elementHash);\n        bytes memory prime = RSAAccumulator.uint256ToBytes(primeUint, 32);\n\n        // Create witness struct\n        RSAAccumulator.NonMembershipWitness memory witness = RSAAccumulator.NonMembershipWitness({\n            d: witnessD,\n            b: witnessB,\n            dNegative: dNegative\n        });\n\n        // Verify using RSA accumulator library\n        return RSAAccumulator.verifyNonMembership(\n            accumulatorParams,\n            accumulator,\n            prime,\n            witness\n        );\n    }\n\n    /**\n     * @notice Compute the prime representative for a market hash\n     * @param marketHash The market hash\n     * @return prime The prime number representing this market\n     */\n    function computeMarketPrime(bytes32 marketHash) external pure returns (uint256 prime) {\n        return PrimeMapping.hashToPrimeUint(marketHash);\n    }\n\n    /**\n     * @notice Compute the prime representative for an address\n     * @param addr The address\n     * @return prime The prime number representing this address\n     */\n    function computeAddressPrime(address addr) external pure returns (uint256 prime) {\n        return PrimeMapping.addressToPrime(addr);\n    }\n\n    // ========== View Functions ==========\n\n    /**\n     * @notice Get nullification details for a market\n     * @param marketHash The market hash\n     * @return nullified Whether the market is nullified\n     * @return timestamp When it was nullified (0 if not)\n     * @return admin Who nullified it (address(0) if not)\n     */\n    function getMarketNullificationDetails(bytes32 marketHash)\n        external\n        view\n        returns (bool nullified, uint256 timestamp, address admin)\n    {\n        return (\n            nullifiedMarkets[marketHash],\n            marketNullifiedAt[marketHash],\n            marketNullifiedBy[marketHash]\n        );\n    }\n\n    /**\n     * @notice Get nullification details for an address\n     * @param addr The address\n     * @return nullified Whether the address is nullified\n     * @return timestamp When it was nullified (0 if not)\n     * @return admin Who nullified it (address(0) if not)\n     */\n    function getAddressNullificationDetails(address addr)\n        external\n        view\n        returns (bool nullified, uint256 timestamp, address admin)\n    {\n        return (\n            nullifiedAddresses[addr],\n            addressNullifiedAt[addr],\n            addressNullifiedBy[addr]\n        );\n    }\n\n    /**\n     * @notice Get all nullified market hashes with pagination\n     * @param offset Starting index\n     * @param limit Maximum number of results\n     * @return hashes Array of nullified market hashes\n     * @return hasMore Whether more results exist\n     */\n    function getNullifiedMarkets(uint256 offset, uint256 limit)\n        external\n        view\n        returns (bytes32[] memory hashes, bool hasMore)\n    {\n        uint256 total = nullifiedMarketList.length;\n        if (offset >= total) {\n            return (new bytes32[](0), false);\n        }\n\n        uint256 remaining = total - offset;\n        uint256 count = remaining > limit ? limit : remaining;\n        hasMore = remaining > limit;\n\n        hashes = new bytes32[](count);\n        for (uint256 i = 0; i < count; i++) {\n            hashes[i] = nullifiedMarketList[offset + i];\n        }\n    }\n\n    /**\n     * @notice Get all nullified addresses with pagination\n     * @param offset Starting index\n     * @param limit Maximum number of results\n     * @return addrs Array of nullified addresses\n     * @return hasMore Whether more results exist\n     */\n    function getNullifiedAddresses(uint256 offset, uint256 limit)\n        external\n        view\n        returns (address[] memory addrs, bool hasMore)\n    {\n        uint256 total = nullifiedAddressList.length;\n        if (offset >= total) {\n            return (new address[](0), false);\n        }\n\n        uint256 remaining = total - offset;\n        uint256 count = remaining > limit ? limit : remaining;\n        hasMore = remaining > limit;\n\n        addrs = new address[](count);\n        for (uint256 i = 0; i < count; i++) {\n            addrs[i] = nullifiedAddressList[offset + i];\n        }\n    }\n\n    /**\n     * @notice Get current accumulator value\n     * @return The current RSA accumulator value\n     */\n    function getAccumulator() external view returns (bytes memory) {\n        return accumulator;\n    }\n\n    /**\n     * @notice Get RSA parameters\n     * @return n RSA modulus\n     * @return g Generator\n     */\n    function getRSAParams() external view returns (bytes memory n, bytes memory g) {\n        return (accumulatorParams.n, accumulatorParams.g);\n    }\n\n    /**\n     * @notice Get registry statistics\n     * @return markets Number of nullified markets\n     * @return addresses Number of nullified addresses\n     * @return nullifications Total nullification operations\n     * @return reinstatements Total reinstatement operations\n     * @return lastUpdate Last accumulator update timestamp\n     */\n    function getStats()\n        external\n        view\n        returns (\n            uint256 markets,\n            uint256 addresses,\n            uint256 nullifications,\n            uint256 reinstatements,\n            uint256 lastUpdate\n        )\n    {\n        return (\n            nullifiedMarketCount,\n            nullifiedAddressCount,\n            totalNullifications,\n            totalReinstatements,\n            lastAccumulatorUpdate\n        );\n    }\n\n    // ========== Emergency Functions ==========\n\n    /**\n     * @notice Pause the registry\n     */\n    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the registry\n     */\n    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    // ========== Internal Functions ==========\n\n    /**\n     * @notice Remove a market hash from the enumerable list\n     */\n    function _removeFromMarketList(bytes32 marketHash) internal {\n        uint256 index = marketListIndex[marketHash];\n        uint256 lastIndex = nullifiedMarketList.length - 1;\n\n        if (index != lastIndex) {\n            bytes32 lastHash = nullifiedMarketList[lastIndex];\n            nullifiedMarketList[index] = lastHash;\n            marketListIndex[lastHash] = index;\n        }\n\n        nullifiedMarketList.pop();\n        delete marketListIndex[marketHash];\n    }\n\n    /**\n     * @notice Remove an address from the enumerable list\n     */\n    function _removeFromAddressList(address addr) internal {\n        uint256 index = addressListIndex[addr];\n        uint256 lastIndex = nullifiedAddressList.length - 1;\n\n        if (index != lastIndex) {\n            address lastAddr = nullifiedAddressList[lastIndex];\n            nullifiedAddressList[index] = lastAddr;\n            addressListIndex[lastAddr] = index;\n        }\n\n        nullifiedAddressList.pop();\n        delete addressListIndex[addr];\n    }\n}\n"
    },
    "contracts/security/RagequitModule.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../access/TieredRoleManager.sol\";\n\n/**\n * @title RagequitModule\n * @notice Minority exit mechanism with role-aware processing\n * @dev Implements Moloch-style ragequit for treasury protection\n * \n * RBAC INTEGRATION:\n * - Ragequit available to all token holders\n * - Admin functions require OPERATIONS_ADMIN_ROLE\n */\ncontract RagequitModule is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    \n    struct RagequitEligibility {\n        uint256 proposalId;\n        uint256 snapshotTime;\n        uint256 executionTime;\n        bool executed;\n    }\n\n    // Proposal ID => user => eligible\n    mapping(uint256 => mapping(address => bool)) public eligibleToRagequit;\n    \n    // Proposal ID => eligibility details\n    mapping(uint256 => RagequitEligibility) public ragequitWindows;\n    \n    // User => has ragequit for proposal\n    mapping(address => mapping(uint256 => bool)) public hasRagequit;\n\n    address public governanceToken;\n    address public treasuryVault;\n    address public governor; // FutarchyGovernor address\n    \n    uint256 public constant RAGEQUIT_WINDOW = 7 days;\n\n    bool private _initialized;\n    \n    // Role-based access control\n    TieredRoleManager public roleManager;\n\n    event RagequitWindowOpened(uint256 indexed proposalId, uint256 snapshotTime, uint256 executionTime);\n    event RagequitExecuted(\n        address indexed user,\n        uint256 indexed proposalId,\n        uint256 tokenAmount,\n        uint256 treasuryShare\n    );\n    event GovernorSet(address indexed governor);\n\n    modifier onlyOwnerOrGovernor() {\n        if (msg.sender != owner() && msg.sender != governor) {\n            revert OwnableUnauthorizedAccount(msg.sender);\n        }\n        _;\n    }\n\n    constructor() Ownable(msg.sender) {}\n    \n    /**\n     * @notice Set the role manager contract\n     * @param _roleManager Address of TieredRoleManager contract\n     */\n    function setRoleManager(address _roleManager) external onlyOwner {\n        require(_roleManager != address(0), \"Invalid role manager address\");\n        require(address(roleManager) == address(0), \"Role manager already set\");\n        roleManager = TieredRoleManager(_roleManager);\n    }\n\n    /**\n     * @notice Initialize the contract (used for clones)\n     * @param initialOwner Address of the initial owner\n     * @param _governanceToken Address of the governance token\n     * @param _treasuryVault Address of the treasury vault\n     */\n    function initialize(\n        address initialOwner,\n        address _governanceToken,\n        address _treasuryVault\n    ) external {\n        require(!_initialized, \"Already initialized\");\n        require(initialOwner != address(0), \"Invalid owner\");\n        require(_governanceToken != address(0), \"Invalid token\");\n        require(_treasuryVault != address(0), \"Invalid vault\");\n        _initialized = true;\n        governanceToken = _governanceToken;\n        treasuryVault = _treasuryVault;\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @notice Set the governor address that can manage ragequit windows\n     * @param _governor Address of the FutarchyGovernor contract\n     */\n    function setGovernor(address _governor) external onlyOwner {\n        require(_governor != address(0), \"Invalid governor address\");\n        governor = _governor;\n        emit GovernorSet(_governor);\n    }\n\n    /**\n     * @notice Open ragequit window for a proposal\n     * @param proposalId ID of the proposal\n     * @param snapshotTime Time of token snapshot\n     * @param executionTime Scheduled execution time\n     */\n    function openRagequitWindow(\n        uint256 proposalId,\n        uint256 snapshotTime,\n        uint256 executionTime\n    ) external onlyOwnerOrGovernor {\n        require(executionTime > snapshotTime, \"Invalid execution time\");\n        require(ragequitWindows[proposalId].snapshotTime == 0, \"Window already opened\");\n\n        ragequitWindows[proposalId] = RagequitEligibility({\n            proposalId: proposalId,\n            snapshotTime: snapshotTime,\n            executionTime: executionTime,\n            executed: false\n        });\n\n        emit RagequitWindowOpened(proposalId, snapshotTime, executionTime);\n    }\n\n    /**\n     * @notice Mark user as eligible for ragequit\n     * @param proposalId ID of the proposal\n     * @param user Address of the user\n     */\n    function setEligible(uint256 proposalId, address user) external onlyOwner {\n        eligibleToRagequit[proposalId][user] = true;\n    }\n\n    /**\n     * @notice Execute ragequit to exit with proportional treasury share\n     * @param proposalId ID of the proposal\n     * @param tokenAmount Amount of governance tokens to burn\n     */\n    function ragequit(uint256 proposalId, uint256 tokenAmount) external nonReentrant {\n        require(eligibleToRagequit[proposalId][msg.sender], \"Not eligible\");\n        require(!hasRagequit[msg.sender][proposalId], \"Already ragequit\");\n        require(tokenAmount > 0, \"Invalid token amount\");\n\n        RagequitEligibility storage window = ragequitWindows[proposalId];\n        require(window.snapshotTime > 0, \"Window not opened\");\n        require(!window.executed, \"Proposal executed\");\n        require(block.timestamp < window.executionTime, \"Window closed\");\n\n        // Calculate proportional treasury share\n        uint256 treasuryShare = calculateTreasuryShare(tokenAmount);\n        require(treasuryShare > 0, \"No treasury share\");\n\n        hasRagequit[msg.sender][proposalId] = true;\n\n        // Burn governance tokens - using safeTransferFrom for checked transfer\n        IERC20(governanceToken).safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n        // Transfer proportional treasury share\n        // In production, this would interact with the treasury vault\n        // Simplified: transfer ETH\n        (bool success, ) = payable(msg.sender).call{value: treasuryShare}(\"\");\n        require(success, \"Treasury transfer failed\");\n\n        emit RagequitExecuted(msg.sender, proposalId, tokenAmount, treasuryShare);\n    }\n\n    /**\n     * @notice Calculate proportional treasury share for ragequit\n     * @param tokenAmount Amount of tokens to burn\n     * @return uint256 Proportional treasury share\n     */\n    function calculateTreasuryShare(\n        uint256 tokenAmount\n    ) public view returns (uint256) {\n        require(tokenAmount > 0, \"Invalid token amount\");\n\n        // Get total supply of governance token\n        uint256 totalSupply = IERC20(governanceToken).totalSupply();\n        require(totalSupply > 0, \"No total supply\");\n\n        // Get treasury balance (simplified - uses RagequitModule balance for payouts)\n        // In production, this would interact with the treasury vault\n        uint256 treasuryBalance = address(this).balance;\n\n        // Calculate proportional share\n        return (treasuryBalance * tokenAmount) / totalSupply;\n    }\n\n    /**\n     * @notice Mark proposal as executed, closing ragequit window\n     * @param proposalId ID of the proposal\n     */\n    function markProposalExecuted(uint256 proposalId) external onlyOwnerOrGovernor {\n        require(ragequitWindows[proposalId].snapshotTime > 0, \"Window not opened\");\n        ragequitWindows[proposalId].executed = true;\n    }\n\n    /**\n     * @notice Check if user is eligible for ragequit\n     * @param proposalId ID of the proposal\n     * @param user Address of the user\n     * @return bool True if eligible\n     */\n    function isEligible(uint256 proposalId, address user) external view returns (bool) {\n        return eligibleToRagequit[proposalId][user] && !hasRagequit[user][proposalId];\n    }\n\n    /**\n     * @notice Get ragequit window details\n     * @param proposalId ID of the proposal\n     */\n    function getRagequitWindow(uint256 proposalId) external view returns (\n        uint256 snapshotTime,\n        uint256 executionTime,\n        bool executed,\n        bool isOpen\n    ) {\n        RagequitEligibility storage window = ragequitWindows[proposalId];\n        return (\n            window.snapshotTime,\n            window.executionTime,\n            window.executed,\n            window.snapshotTime > 0 && \n            !window.executed && \n            block.timestamp < window.executionTime\n        );\n    }\n\n    /**\n     * @notice Update treasury vault address\n     * @param newVault Address of new vault\n     */\n    function updateTreasuryVault(address newVault) external onlyOwner {\n        require(newVault != address(0), \"Invalid vault\");\n        treasuryVault = newVault;\n    }\n\n    /**\n     * @notice Emergency withdraw (owner only)\n     */\n    function emergencyWithdraw() external onlyOwner {\n        (bool success, ) = payable(owner()).call{value: address(this).balance}(\"\");\n        require(success, \"Withdraw failed\");\n    }\n\n    receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}
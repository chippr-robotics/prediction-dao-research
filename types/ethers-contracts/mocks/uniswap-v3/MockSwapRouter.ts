/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers"
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "../../common.js"
  
export declare namespace ISwapRouter {
      
    export type ExactInputParamsStruct = {path: BytesLike, recipient: AddressLike, deadline: BigNumberish, amountIn: BigNumberish, amountOutMinimum: BigNumberish}

    export type ExactInputParamsStructOutput = [path: string, recipient: string, deadline: bigint, amountIn: bigint, amountOutMinimum: bigint] & {path: string, recipient: string, deadline: bigint, amountIn: bigint, amountOutMinimum: bigint }
  

    export type ExactInputSingleParamsStruct = {tokenIn: AddressLike, tokenOut: AddressLike, fee: BigNumberish, recipient: AddressLike, deadline: BigNumberish, amountIn: BigNumberish, amountOutMinimum: BigNumberish, sqrtPriceLimitX96: BigNumberish}

    export type ExactInputSingleParamsStructOutput = [tokenIn: string, tokenOut: string, fee: bigint, recipient: string, deadline: bigint, amountIn: bigint, amountOutMinimum: bigint, sqrtPriceLimitX96: bigint] & {tokenIn: string, tokenOut: string, fee: bigint, recipient: string, deadline: bigint, amountIn: bigint, amountOutMinimum: bigint, sqrtPriceLimitX96: bigint }
  

    export type ExactOutputParamsStruct = {path: BytesLike, recipient: AddressLike, deadline: BigNumberish, amountOut: BigNumberish, amountInMaximum: BigNumberish}

    export type ExactOutputParamsStructOutput = [path: string, recipient: string, deadline: bigint, amountOut: bigint, amountInMaximum: bigint] & {path: string, recipient: string, deadline: bigint, amountOut: bigint, amountInMaximum: bigint }
  

    export type ExactOutputSingleParamsStruct = {tokenIn: AddressLike, tokenOut: AddressLike, fee: BigNumberish, recipient: AddressLike, deadline: BigNumberish, amountOut: BigNumberish, amountInMaximum: BigNumberish, sqrtPriceLimitX96: BigNumberish}

    export type ExactOutputSingleParamsStructOutput = [tokenIn: string, tokenOut: string, fee: bigint, recipient: string, deadline: bigint, amountOut: bigint, amountInMaximum: bigint, sqrtPriceLimitX96: bigint] & {tokenIn: string, tokenOut: string, fee: bigint, recipient: string, deadline: bigint, amountOut: bigint, amountInMaximum: bigint, sqrtPriceLimitX96: bigint }
  
    }

  export interface MockSwapRouterInterface extends Interface {
    getFunction(nameOrSignature: "exactInput" | "exactInputSingle" | "exactOutput" | "exactOutputSingle" | "factory"): FunctionFragment;

    getEvent(nameOrSignatureOrTopic: "SwapExecuted"): EventFragment;

    encodeFunctionData(functionFragment: 'exactInput', values: [ISwapRouter.ExactInputParamsStruct]): string;
encodeFunctionData(functionFragment: 'exactInputSingle', values: [ISwapRouter.ExactInputSingleParamsStruct]): string;
encodeFunctionData(functionFragment: 'exactOutput', values: [ISwapRouter.ExactOutputParamsStruct]): string;
encodeFunctionData(functionFragment: 'exactOutputSingle', values: [ISwapRouter.ExactOutputSingleParamsStruct]): string;
encodeFunctionData(functionFragment: 'factory', values?: undefined): string;

    decodeFunctionResult(functionFragment: 'exactInput', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'exactInputSingle', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'exactOutput', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'exactOutputSingle', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'factory', data: BytesLike): Result;
  }

  
    export namespace SwapExecutedEvent {
      export type InputTuple = [tokenIn: AddressLike, tokenOut: AddressLike, amountIn: BigNumberish, amountOut: BigNumberish, recipient: AddressLike];
      export type OutputTuple = [tokenIn: string, tokenOut: string, amountIn: bigint, amountOut: bigint, recipient: string];
      export interface OutputObject {tokenIn: string, tokenOut: string, amountIn: bigint, amountOut: bigint, recipient: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

  export interface MockSwapRouter extends BaseContract {
    
    connect(runner?: ContractRunner | null): MockSwapRouter;
    waitForDeployment(): Promise<this>;

    interface: MockSwapRouterInterface;

    
  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>
  
  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>


    
    
    exactInput: TypedContractMethod<
      [arg0: ISwapRouter.ExactInputParamsStruct, ],
      [bigint],
      'payable'
    >
    

    
    exactInputSingle: TypedContractMethod<
      [params: ISwapRouter.ExactInputSingleParamsStruct, ],
      [bigint],
      'payable'
    >
    

    
    exactOutput: TypedContractMethod<
      [arg0: ISwapRouter.ExactOutputParamsStruct, ],
      [bigint],
      'payable'
    >
    

    
    exactOutputSingle: TypedContractMethod<
      [arg0: ISwapRouter.ExactOutputSingleParamsStruct, ],
      [bigint],
      'payable'
    >
    

    
    factory: TypedContractMethod<
      [],
      [string],
      'view'
    >
    


    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(nameOrSignature: 'exactInput'): TypedContractMethod<
      [arg0: ISwapRouter.ExactInputParamsStruct, ],
      [bigint],
      'payable'
    >;
getFunction(nameOrSignature: 'exactInputSingle'): TypedContractMethod<
      [params: ISwapRouter.ExactInputSingleParamsStruct, ],
      [bigint],
      'payable'
    >;
getFunction(nameOrSignature: 'exactOutput'): TypedContractMethod<
      [arg0: ISwapRouter.ExactOutputParamsStruct, ],
      [bigint],
      'payable'
    >;
getFunction(nameOrSignature: 'exactOutputSingle'): TypedContractMethod<
      [arg0: ISwapRouter.ExactOutputSingleParamsStruct, ],
      [bigint],
      'payable'
    >;
getFunction(nameOrSignature: 'factory'): TypedContractMethod<
      [],
      [string],
      'view'
    >;

    getEvent(key: 'SwapExecuted'): TypedContractEvent<SwapExecutedEvent.InputTuple, SwapExecutedEvent.OutputTuple, SwapExecutedEvent.OutputObject>;

    filters: {
      
      'SwapExecuted(address,address,uint256,uint256,address)': TypedContractEvent<SwapExecutedEvent.InputTuple, SwapExecutedEvent.OutputTuple, SwapExecutedEvent.OutputObject>;
      SwapExecuted: TypedContractEvent<SwapExecutedEvent.InputTuple, SwapExecutedEvent.OutputTuple, SwapExecutedEvent.OutputObject>;
    
    };
  }
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers"
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "../../common.js"
  
export declare namespace ConditionalMarketFactory {
      
    export type MarketCreationParamsStruct = {proposalId: BigNumberish, collateralToken: AddressLike, liquidityAmount: BigNumberish, liquidityParameter: BigNumberish, tradingPeriod: BigNumberish, betType: BigNumberish}

    export type MarketCreationParamsStructOutput = [proposalId: bigint, collateralToken: string, liquidityAmount: bigint, liquidityParameter: bigint, tradingPeriod: bigint, betType: bigint] & {proposalId: bigint, collateralToken: string, liquidityAmount: bigint, liquidityParameter: bigint, tradingPeriod: bigint, betType: bigint }
  

    export type MarketResolutionParamsStruct = {marketId: BigNumberish, passValue: BigNumberish, failValue: BigNumberish}

    export type MarketResolutionParamsStructOutput = [marketId: bigint, passValue: bigint, failValue: bigint] & {marketId: bigint, passValue: bigint, failValue: bigint }
  

    export type MarketStruct = {proposalId: BigNumberish, passToken: AddressLike, failToken: AddressLike, collateralToken: AddressLike, tradingEndTime: BigNumberish, liquidityParameter: BigNumberish, totalLiquidity: BigNumberish, resolved: boolean, passValue: BigNumberish, failValue: BigNumberish, status: BigNumberish, betType: BigNumberish, useCTF: boolean, conditionId: BytesLike, questionId: BytesLike, passPositionId: BigNumberish, failPositionId: BigNumberish, passQuantity: BigNumberish, failQuantity: BigNumberish}

    export type MarketStructOutput = [proposalId: bigint, passToken: string, failToken: string, collateralToken: string, tradingEndTime: bigint, liquidityParameter: bigint, totalLiquidity: bigint, resolved: boolean, passValue: bigint, failValue: bigint, status: bigint, betType: bigint, useCTF: boolean, conditionId: string, questionId: string, passPositionId: bigint, failPositionId: bigint, passQuantity: bigint, failQuantity: bigint] & {proposalId: bigint, passToken: string, failToken: string, collateralToken: string, tradingEndTime: bigint, liquidityParameter: bigint, totalLiquidity: bigint, resolved: boolean, passValue: bigint, failValue: bigint, status: bigint, betType: bigint, useCTF: boolean, conditionId: string, questionId: string, passPositionId: bigint, failPositionId: bigint, passQuantity: bigint, failQuantity: bigint }
  
    }

  export interface ConditionalMarketFactoryInterface extends Interface {
    getFunction(nameOrSignature: "DEFAULT_INITIAL_SQRT_PRICE" | "DEFAULT_TRADING_PERIOD" | "MAX_BATCH_SIZE" | "MAX_TRADING_PERIOD" | "MIN_TRADING_PERIOD" | "batchDeployMarkets" | "batchResolveMarkets" | "buyTokens" | "cancelMarket" | "cancelMarketWithReason" | "computeMarketHash" | "createETCSwapPools" | "ctf1155" | "deployMarketPair" | "deployMarketPairWithMetadata" | "endTrading" | "enforceNullificationOnChain" | "etcSwapIntegration" | "getActiveMarkets" | "getMarket" | "getMarketCountByStatus" | "getMarketForProposal" | "getMarketMetadataUri" | "getMarketsByDateRange" | "getMarketsByStatus" | "getOutcomeLabels" | "getPrices" | "getTokenAmount" | "hasMarketForProposal" | "initialize" | "isMarketNullified" | "marketCount" | "markets" | "nullifierRegistry" | "onERC1155BatchReceived" | "onERC1155Received" | "owner" | "renounceOwnership" | "resolveMarket" | "roleManager" | "sellTokens" | "setCTF1155" | "setETCSwapIntegration" | "setMarketMetadataUri" | "setNullificationEnforcement" | "setNullifierRegistry" | "setRoleManager" | "supportsInterface" | "transferOwnership" | "useETCSwap"): FunctionFragment;

    getEvent(nameOrSignatureOrTopic: "BatchMarketsCreated" | "BatchMarketsResolved" | "CTF1155Updated" | "CTFMarketCreated" | "ETCSwapIntegrationUpdated" | "ETCSwapPoolsCreated" | "MarketCancelled" | "MarketCreated" | "MarketResolved" | "MarketStatusChanged" | "NullificationEnforcementUpdated" | "NullifierRegistryUpdated" | "OwnershipTransferred" | "TokensPurchased" | "TokensSold"): EventFragment;

    encodeFunctionData(functionFragment: 'DEFAULT_INITIAL_SQRT_PRICE', values?: undefined): string;
encodeFunctionData(functionFragment: 'DEFAULT_TRADING_PERIOD', values?: undefined): string;
encodeFunctionData(functionFragment: 'MAX_BATCH_SIZE', values?: undefined): string;
encodeFunctionData(functionFragment: 'MAX_TRADING_PERIOD', values?: undefined): string;
encodeFunctionData(functionFragment: 'MIN_TRADING_PERIOD', values?: undefined): string;
encodeFunctionData(functionFragment: 'batchDeployMarkets', values: [ConditionalMarketFactory.MarketCreationParamsStruct[]]): string;
encodeFunctionData(functionFragment: 'batchResolveMarkets', values: [ConditionalMarketFactory.MarketResolutionParamsStruct[]]): string;
encodeFunctionData(functionFragment: 'buyTokens', values: [BigNumberish, boolean, BigNumberish]): string;
encodeFunctionData(functionFragment: 'cancelMarket', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'cancelMarketWithReason', values: [BigNumberish, string]): string;
encodeFunctionData(functionFragment: 'computeMarketHash', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'createETCSwapPools', values: [BigNumberish, BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'ctf1155', values?: undefined): string;
encodeFunctionData(functionFragment: 'deployMarketPair', values: [BigNumberish, AddressLike, BigNumberish, BigNumberish, BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'deployMarketPairWithMetadata', values: [BigNumberish, AddressLike, BigNumberish, BigNumberish, BigNumberish, BigNumberish, string]): string;
encodeFunctionData(functionFragment: 'endTrading', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'enforceNullificationOnChain', values?: undefined): string;
encodeFunctionData(functionFragment: 'etcSwapIntegration', values?: undefined): string;
encodeFunctionData(functionFragment: 'getActiveMarkets', values: [BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'getMarket', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'getMarketCountByStatus', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'getMarketForProposal', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'getMarketMetadataUri', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'getMarketsByDateRange', values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'getMarketsByStatus', values: [BigNumberish, BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'getOutcomeLabels', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'getPrices', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'getTokenAmount', values: [BigNumberish, boolean, BigNumberish]): string;
encodeFunctionData(functionFragment: 'hasMarketForProposal', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'initialize', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'isMarketNullified', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'marketCount', values?: undefined): string;
encodeFunctionData(functionFragment: 'markets', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'nullifierRegistry', values?: undefined): string;
encodeFunctionData(functionFragment: 'onERC1155BatchReceived', values: [AddressLike, AddressLike, BigNumberish[], BigNumberish[], BytesLike]): string;
encodeFunctionData(functionFragment: 'onERC1155Received', values: [AddressLike, AddressLike, BigNumberish, BigNumberish, BytesLike]): string;
encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
encodeFunctionData(functionFragment: 'resolveMarket', values: [BigNumberish, BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'roleManager', values?: undefined): string;
encodeFunctionData(functionFragment: 'sellTokens', values: [BigNumberish, boolean, BigNumberish]): string;
encodeFunctionData(functionFragment: 'setCTF1155', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'setETCSwapIntegration', values: [AddressLike, boolean]): string;
encodeFunctionData(functionFragment: 'setMarketMetadataUri', values: [BigNumberish, string]): string;
encodeFunctionData(functionFragment: 'setNullificationEnforcement', values: [boolean]): string;
encodeFunctionData(functionFragment: 'setNullifierRegistry', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'setRoleManager', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'supportsInterface', values: [BytesLike]): string;
encodeFunctionData(functionFragment: 'transferOwnership', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'useETCSwap', values?: undefined): string;

    decodeFunctionResult(functionFragment: 'DEFAULT_INITIAL_SQRT_PRICE', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'DEFAULT_TRADING_PERIOD', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'MAX_BATCH_SIZE', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'MAX_TRADING_PERIOD', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'MIN_TRADING_PERIOD', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'batchDeployMarkets', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'batchResolveMarkets', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'buyTokens', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'cancelMarket', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'cancelMarketWithReason', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'computeMarketHash', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'createETCSwapPools', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'ctf1155', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'deployMarketPair', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'deployMarketPairWithMetadata', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'endTrading', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'enforceNullificationOnChain', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'etcSwapIntegration', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getActiveMarkets', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getMarket', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getMarketCountByStatus', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getMarketForProposal', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getMarketMetadataUri', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getMarketsByDateRange', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getMarketsByStatus', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getOutcomeLabels', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getPrices', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getTokenAmount', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'hasMarketForProposal', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'isMarketNullified', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'marketCount', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'markets', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'nullifierRegistry', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'onERC1155BatchReceived', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'onERC1155Received', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'resolveMarket', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'roleManager', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'sellTokens', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'setCTF1155', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'setETCSwapIntegration', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'setMarketMetadataUri', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'setNullificationEnforcement', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'setNullifierRegistry', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'setRoleManager', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'supportsInterface', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'useETCSwap', data: BytesLike): Result;
  }

  
    export namespace BatchMarketsCreatedEvent {
      export type InputTuple = [marketIds: BigNumberish[], batchTimestamp: BigNumberish, totalMarketsCreated: BigNumberish];
      export type OutputTuple = [marketIds: bigint[], batchTimestamp: bigint, totalMarketsCreated: bigint];
      export interface OutputObject {marketIds: bigint[], batchTimestamp: bigint, totalMarketsCreated: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace BatchMarketsResolvedEvent {
      export type InputTuple = [marketIds: BigNumberish[], batchTimestamp: BigNumberish, totalMarketsResolved: BigNumberish];
      export type OutputTuple = [marketIds: bigint[], batchTimestamp: bigint, totalMarketsResolved: bigint];
      export interface OutputObject {marketIds: bigint[], batchTimestamp: bigint, totalMarketsResolved: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace CTF1155UpdatedEvent {
      export type InputTuple = [ctf1155: AddressLike];
      export type OutputTuple = [ctf1155: string];
      export interface OutputObject {ctf1155: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace CTFMarketCreatedEvent {
      export type InputTuple = [marketId: BigNumberish, conditionId: BytesLike, passPositionId: BigNumberish, failPositionId: BigNumberish];
      export type OutputTuple = [marketId: bigint, conditionId: string, passPositionId: bigint, failPositionId: bigint];
      export interface OutputObject {marketId: bigint, conditionId: string, passPositionId: bigint, failPositionId: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace ETCSwapIntegrationUpdatedEvent {
      export type InputTuple = [integration: AddressLike, enabled: boolean];
      export type OutputTuple = [integration: string, enabled: boolean];
      export interface OutputObject {integration: string, enabled: boolean };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace ETCSwapPoolsCreatedEvent {
      export type InputTuple = [marketId: BigNumberish, passPool: AddressLike, failPool: AddressLike];
      export type OutputTuple = [marketId: bigint, passPool: string, failPool: string];
      export interface OutputObject {marketId: bigint, passPool: string, failPool: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace MarketCancelledEvent {
      export type InputTuple = [marketId: BigNumberish, proposalId: BigNumberish, reason: string, cancelledAt: BigNumberish];
      export type OutputTuple = [marketId: bigint, proposalId: bigint, reason: string, cancelledAt: bigint];
      export interface OutputObject {marketId: bigint, proposalId: bigint, reason: string, cancelledAt: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace MarketCreatedEvent {
      export type InputTuple = [marketId: BigNumberish, proposalId: BigNumberish, collateralToken: AddressLike, passToken: AddressLike, failToken: AddressLike, tradingEndTime: BigNumberish, liquidityParameter: BigNumberish, createdAt: BigNumberish, creator: AddressLike, betType: BigNumberish];
      export type OutputTuple = [marketId: bigint, proposalId: bigint, collateralToken: string, passToken: string, failToken: string, tradingEndTime: bigint, liquidityParameter: bigint, createdAt: bigint, creator: string, betType: bigint];
      export interface OutputObject {marketId: bigint, proposalId: bigint, collateralToken: string, passToken: string, failToken: string, tradingEndTime: bigint, liquidityParameter: bigint, createdAt: bigint, creator: string, betType: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace MarketResolvedEvent {
      export type InputTuple = [marketId: BigNumberish, proposalId: BigNumberish, passValue: BigNumberish, failValue: BigNumberish, approved: boolean, resolvedAt: BigNumberish];
      export type OutputTuple = [marketId: bigint, proposalId: bigint, passValue: bigint, failValue: bigint, approved: boolean, resolvedAt: bigint];
      export interface OutputObject {marketId: bigint, proposalId: bigint, passValue: bigint, failValue: bigint, approved: boolean, resolvedAt: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace MarketStatusChangedEvent {
      export type InputTuple = [marketId: BigNumberish, previousStatus: BigNumberish, newStatus: BigNumberish, changedAt: BigNumberish];
      export type OutputTuple = [marketId: bigint, previousStatus: bigint, newStatus: bigint, changedAt: bigint];
      export interface OutputObject {marketId: bigint, previousStatus: bigint, newStatus: bigint, changedAt: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace NullificationEnforcementUpdatedEvent {
      export type InputTuple = [enforceOnChain: boolean];
      export type OutputTuple = [enforceOnChain: boolean];
      export interface OutputObject {enforceOnChain: boolean };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace NullifierRegistryUpdatedEvent {
      export type InputTuple = [nullifierRegistry: AddressLike];
      export type OutputTuple = [nullifierRegistry: string];
      export interface OutputObject {nullifierRegistry: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace OwnershipTransferredEvent {
      export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
      export type OutputTuple = [previousOwner: string, newOwner: string];
      export interface OutputObject {previousOwner: string, newOwner: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace TokensPurchasedEvent {
      export type InputTuple = [marketId: BigNumberish, buyer: AddressLike, buyPass: boolean, collateralAmount: BigNumberish, tokenAmount: BigNumberish];
      export type OutputTuple = [marketId: bigint, buyer: string, buyPass: boolean, collateralAmount: bigint, tokenAmount: bigint];
      export interface OutputObject {marketId: bigint, buyer: string, buyPass: boolean, collateralAmount: bigint, tokenAmount: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace TokensSoldEvent {
      export type InputTuple = [marketId: BigNumberish, seller: AddressLike, sellPass: boolean, tokenAmount: BigNumberish, collateralAmount: BigNumberish];
      export type OutputTuple = [marketId: bigint, seller: string, sellPass: boolean, tokenAmount: bigint, collateralAmount: bigint];
      export interface OutputObject {marketId: bigint, seller: string, sellPass: boolean, tokenAmount: bigint, collateralAmount: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

  export interface ConditionalMarketFactory extends BaseContract {
    
    connect(runner?: ContractRunner | null): ConditionalMarketFactory;
    waitForDeployment(): Promise<this>;

    interface: ConditionalMarketFactoryInterface;

    
  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>
  
  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>


    
    
    DEFAULT_INITIAL_SQRT_PRICE: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    DEFAULT_TRADING_PERIOD: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    MAX_BATCH_SIZE: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    MAX_TRADING_PERIOD: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    MIN_TRADING_PERIOD: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    batchDeployMarkets: TypedContractMethod<
      [params: ConditionalMarketFactory.MarketCreationParamsStruct[], ],
      [bigint[]],
      'nonpayable'
    >
    

    
    batchResolveMarkets: TypedContractMethod<
      [params: ConditionalMarketFactory.MarketResolutionParamsStruct[], ],
      [boolean[]],
      'nonpayable'
    >
    

    
    buyTokens: TypedContractMethod<
      [marketId: BigNumberish, buyPass: boolean, amount: BigNumberish, ],
      [bigint],
      'payable'
    >
    

    
    cancelMarket: TypedContractMethod<
      [marketId: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    cancelMarketWithReason: TypedContractMethod<
      [marketId: BigNumberish, reason: string, ],
      [void],
      'nonpayable'
    >
    

    
    computeMarketHash: TypedContractMethod<
      [marketId: BigNumberish, ],
      [string],
      'view'
    >
    

    
    createETCSwapPools: TypedContractMethod<
      [marketId: BigNumberish, initialSqrtPriceX96: BigNumberish, fee: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    ctf1155: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    deployMarketPair: TypedContractMethod<
      [proposalId: BigNumberish, collateralToken: AddressLike, liquidityAmount: BigNumberish, liquidityParameter: BigNumberish, tradingPeriod: BigNumberish, betType: BigNumberish, ],
      [bigint],
      'nonpayable'
    >
    

    
    deployMarketPairWithMetadata: TypedContractMethod<
      [proposalId: BigNumberish, collateralToken: AddressLike, liquidityAmount: BigNumberish, liquidityParameter: BigNumberish, tradingPeriod: BigNumberish, betType: BigNumberish, metadataUri: string, ],
      [bigint],
      'nonpayable'
    >
    

    
    endTrading: TypedContractMethod<
      [marketId: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    enforceNullificationOnChain: TypedContractMethod<
      [],
      [boolean],
      'view'
    >
    

    
    etcSwapIntegration: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    getActiveMarkets: TypedContractMethod<
      [offset: BigNumberish, limit: BigNumberish, ],
      [[bigint[], boolean] & {marketIds: bigint[], hasMore: boolean }],
      'view'
    >
    

    
    getMarket: TypedContractMethod<
      [marketId: BigNumberish, ],
      [ConditionalMarketFactory.MarketStructOutput],
      'view'
    >
    

    
    getMarketCountByStatus: TypedContractMethod<
      [status: BigNumberish, ],
      [bigint],
      'view'
    >
    

    
    getMarketForProposal: TypedContractMethod<
      [proposalId: BigNumberish, ],
      [bigint],
      'view'
    >
    

    
    getMarketMetadataUri: TypedContractMethod<
      [marketId: BigNumberish, ],
      [string],
      'view'
    >
    

    
    getMarketsByDateRange: TypedContractMethod<
      [startTime: BigNumberish, endTime: BigNumberish, offset: BigNumberish, limit: BigNumberish, ],
      [[bigint[], boolean] & {marketIds: bigint[], hasMore: boolean }],
      'view'
    >
    

    
    getMarketsByStatus: TypedContractMethod<
      [status: BigNumberish, offset: BigNumberish, limit: BigNumberish, ],
      [[bigint[], boolean] & {marketIds: bigint[], hasMore: boolean }],
      'view'
    >
    

    
    getOutcomeLabels: TypedContractMethod<
      [betType: BigNumberish, ],
      [[string, string] & {positiveOutcome: string, negativeOutcome: string }],
      'view'
    >
    

    
    getPrices: TypedContractMethod<
      [marketId: BigNumberish, ],
      [[bigint, bigint] & {passPrice: bigint, failPrice: bigint }],
      'view'
    >
    

    
    getTokenAmount: TypedContractMethod<
      [marketId: BigNumberish, buyPass: boolean, collateralAmount: BigNumberish, ],
      [bigint],
      'view'
    >
    

    
    hasMarketForProposal: TypedContractMethod<
      [proposalId: BigNumberish, ],
      [boolean],
      'view'
    >
    

    
    initialize: TypedContractMethod<
      [initialOwner: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    isMarketNullified: TypedContractMethod<
      [marketId: BigNumberish, ],
      [boolean],
      'view'
    >
    

    
    marketCount: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    markets: TypedContractMethod<
      [arg0: BigNumberish, ],
      [[bigint, string, string, string, bigint, bigint, bigint, boolean, bigint, bigint, bigint, bigint, boolean, string, string, bigint, bigint, bigint, bigint] & {proposalId: bigint, passToken: string, failToken: string, collateralToken: string, tradingEndTime: bigint, liquidityParameter: bigint, totalLiquidity: bigint, resolved: boolean, passValue: bigint, failValue: bigint, status: bigint, betType: bigint, useCTF: boolean, conditionId: string, questionId: string, passPositionId: bigint, failPositionId: bigint, passQuantity: bigint, failQuantity: bigint }],
      'view'
    >
    

    
    nullifierRegistry: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    onERC1155BatchReceived: TypedContractMethod<
      [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish[], arg3: BigNumberish[], arg4: BytesLike, ],
      [string],
      'view'
    >
    

    
    onERC1155Received: TypedContractMethod<
      [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish, arg3: BigNumberish, arg4: BytesLike, ],
      [string],
      'view'
    >
    

    
    owner: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    renounceOwnership: TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >
    

    
    resolveMarket: TypedContractMethod<
      [marketId: BigNumberish, passValue: BigNumberish, failValue: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    roleManager: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    sellTokens: TypedContractMethod<
      [marketId: BigNumberish, sellPass: boolean, tokenAmount: BigNumberish, ],
      [bigint],
      'nonpayable'
    >
    

    
    setCTF1155: TypedContractMethod<
      [_ctf1155: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    setETCSwapIntegration: TypedContractMethod<
      [_integration: AddressLike, _enabled: boolean, ],
      [void],
      'nonpayable'
    >
    

    
    setMarketMetadataUri: TypedContractMethod<
      [marketId: BigNumberish, uri: string, ],
      [void],
      'nonpayable'
    >
    

    
    setNullificationEnforcement: TypedContractMethod<
      [_enforce: boolean, ],
      [void],
      'nonpayable'
    >
    

    
    setNullifierRegistry: TypedContractMethod<
      [_nullifierRegistry: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    setRoleManager: TypedContractMethod<
      [_roleManager: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    supportsInterface: TypedContractMethod<
      [interfaceId: BytesLike, ],
      [boolean],
      'view'
    >
    

    
    transferOwnership: TypedContractMethod<
      [newOwner: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    useETCSwap: TypedContractMethod<
      [],
      [boolean],
      'view'
    >
    


    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(nameOrSignature: 'DEFAULT_INITIAL_SQRT_PRICE'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'DEFAULT_TRADING_PERIOD'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'MAX_BATCH_SIZE'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'MAX_TRADING_PERIOD'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'MIN_TRADING_PERIOD'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'batchDeployMarkets'): TypedContractMethod<
      [params: ConditionalMarketFactory.MarketCreationParamsStruct[], ],
      [bigint[]],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'batchResolveMarkets'): TypedContractMethod<
      [params: ConditionalMarketFactory.MarketResolutionParamsStruct[], ],
      [boolean[]],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'buyTokens'): TypedContractMethod<
      [marketId: BigNumberish, buyPass: boolean, amount: BigNumberish, ],
      [bigint],
      'payable'
    >;
getFunction(nameOrSignature: 'cancelMarket'): TypedContractMethod<
      [marketId: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'cancelMarketWithReason'): TypedContractMethod<
      [marketId: BigNumberish, reason: string, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'computeMarketHash'): TypedContractMethod<
      [marketId: BigNumberish, ],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'createETCSwapPools'): TypedContractMethod<
      [marketId: BigNumberish, initialSqrtPriceX96: BigNumberish, fee: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'ctf1155'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'deployMarketPair'): TypedContractMethod<
      [proposalId: BigNumberish, collateralToken: AddressLike, liquidityAmount: BigNumberish, liquidityParameter: BigNumberish, tradingPeriod: BigNumberish, betType: BigNumberish, ],
      [bigint],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'deployMarketPairWithMetadata'): TypedContractMethod<
      [proposalId: BigNumberish, collateralToken: AddressLike, liquidityAmount: BigNumberish, liquidityParameter: BigNumberish, tradingPeriod: BigNumberish, betType: BigNumberish, metadataUri: string, ],
      [bigint],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'endTrading'): TypedContractMethod<
      [marketId: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'enforceNullificationOnChain'): TypedContractMethod<
      [],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'etcSwapIntegration'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'getActiveMarkets'): TypedContractMethod<
      [offset: BigNumberish, limit: BigNumberish, ],
      [[bigint[], boolean] & {marketIds: bigint[], hasMore: boolean }],
      'view'
    >;
getFunction(nameOrSignature: 'getMarket'): TypedContractMethod<
      [marketId: BigNumberish, ],
      [ConditionalMarketFactory.MarketStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'getMarketCountByStatus'): TypedContractMethod<
      [status: BigNumberish, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'getMarketForProposal'): TypedContractMethod<
      [proposalId: BigNumberish, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'getMarketMetadataUri'): TypedContractMethod<
      [marketId: BigNumberish, ],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'getMarketsByDateRange'): TypedContractMethod<
      [startTime: BigNumberish, endTime: BigNumberish, offset: BigNumberish, limit: BigNumberish, ],
      [[bigint[], boolean] & {marketIds: bigint[], hasMore: boolean }],
      'view'
    >;
getFunction(nameOrSignature: 'getMarketsByStatus'): TypedContractMethod<
      [status: BigNumberish, offset: BigNumberish, limit: BigNumberish, ],
      [[bigint[], boolean] & {marketIds: bigint[], hasMore: boolean }],
      'view'
    >;
getFunction(nameOrSignature: 'getOutcomeLabels'): TypedContractMethod<
      [betType: BigNumberish, ],
      [[string, string] & {positiveOutcome: string, negativeOutcome: string }],
      'view'
    >;
getFunction(nameOrSignature: 'getPrices'): TypedContractMethod<
      [marketId: BigNumberish, ],
      [[bigint, bigint] & {passPrice: bigint, failPrice: bigint }],
      'view'
    >;
getFunction(nameOrSignature: 'getTokenAmount'): TypedContractMethod<
      [marketId: BigNumberish, buyPass: boolean, collateralAmount: BigNumberish, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'hasMarketForProposal'): TypedContractMethod<
      [proposalId: BigNumberish, ],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'initialize'): TypedContractMethod<
      [initialOwner: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'isMarketNullified'): TypedContractMethod<
      [marketId: BigNumberish, ],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'marketCount'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'markets'): TypedContractMethod<
      [arg0: BigNumberish, ],
      [[bigint, string, string, string, bigint, bigint, bigint, boolean, bigint, bigint, bigint, bigint, boolean, string, string, bigint, bigint, bigint, bigint] & {proposalId: bigint, passToken: string, failToken: string, collateralToken: string, tradingEndTime: bigint, liquidityParameter: bigint, totalLiquidity: bigint, resolved: boolean, passValue: bigint, failValue: bigint, status: bigint, betType: bigint, useCTF: boolean, conditionId: string, questionId: string, passPositionId: bigint, failPositionId: bigint, passQuantity: bigint, failQuantity: bigint }],
      'view'
    >;
getFunction(nameOrSignature: 'nullifierRegistry'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'onERC1155BatchReceived'): TypedContractMethod<
      [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish[], arg3: BigNumberish[], arg4: BytesLike, ],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'onERC1155Received'): TypedContractMethod<
      [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish, arg3: BigNumberish, arg4: BytesLike, ],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'owner'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'renounceOwnership'): TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'resolveMarket'): TypedContractMethod<
      [marketId: BigNumberish, passValue: BigNumberish, failValue: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'roleManager'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'sellTokens'): TypedContractMethod<
      [marketId: BigNumberish, sellPass: boolean, tokenAmount: BigNumberish, ],
      [bigint],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'setCTF1155'): TypedContractMethod<
      [_ctf1155: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'setETCSwapIntegration'): TypedContractMethod<
      [_integration: AddressLike, _enabled: boolean, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'setMarketMetadataUri'): TypedContractMethod<
      [marketId: BigNumberish, uri: string, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'setNullificationEnforcement'): TypedContractMethod<
      [_enforce: boolean, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'setNullifierRegistry'): TypedContractMethod<
      [_nullifierRegistry: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'setRoleManager'): TypedContractMethod<
      [_roleManager: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'supportsInterface'): TypedContractMethod<
      [interfaceId: BytesLike, ],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'transferOwnership'): TypedContractMethod<
      [newOwner: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'useETCSwap'): TypedContractMethod<
      [],
      [boolean],
      'view'
    >;

    getEvent(key: 'BatchMarketsCreated'): TypedContractEvent<BatchMarketsCreatedEvent.InputTuple, BatchMarketsCreatedEvent.OutputTuple, BatchMarketsCreatedEvent.OutputObject>;
getEvent(key: 'BatchMarketsResolved'): TypedContractEvent<BatchMarketsResolvedEvent.InputTuple, BatchMarketsResolvedEvent.OutputTuple, BatchMarketsResolvedEvent.OutputObject>;
getEvent(key: 'CTF1155Updated'): TypedContractEvent<CTF1155UpdatedEvent.InputTuple, CTF1155UpdatedEvent.OutputTuple, CTF1155UpdatedEvent.OutputObject>;
getEvent(key: 'CTFMarketCreated'): TypedContractEvent<CTFMarketCreatedEvent.InputTuple, CTFMarketCreatedEvent.OutputTuple, CTFMarketCreatedEvent.OutputObject>;
getEvent(key: 'ETCSwapIntegrationUpdated'): TypedContractEvent<ETCSwapIntegrationUpdatedEvent.InputTuple, ETCSwapIntegrationUpdatedEvent.OutputTuple, ETCSwapIntegrationUpdatedEvent.OutputObject>;
getEvent(key: 'ETCSwapPoolsCreated'): TypedContractEvent<ETCSwapPoolsCreatedEvent.InputTuple, ETCSwapPoolsCreatedEvent.OutputTuple, ETCSwapPoolsCreatedEvent.OutputObject>;
getEvent(key: 'MarketCancelled'): TypedContractEvent<MarketCancelledEvent.InputTuple, MarketCancelledEvent.OutputTuple, MarketCancelledEvent.OutputObject>;
getEvent(key: 'MarketCreated'): TypedContractEvent<MarketCreatedEvent.InputTuple, MarketCreatedEvent.OutputTuple, MarketCreatedEvent.OutputObject>;
getEvent(key: 'MarketResolved'): TypedContractEvent<MarketResolvedEvent.InputTuple, MarketResolvedEvent.OutputTuple, MarketResolvedEvent.OutputObject>;
getEvent(key: 'MarketStatusChanged'): TypedContractEvent<MarketStatusChangedEvent.InputTuple, MarketStatusChangedEvent.OutputTuple, MarketStatusChangedEvent.OutputObject>;
getEvent(key: 'NullificationEnforcementUpdated'): TypedContractEvent<NullificationEnforcementUpdatedEvent.InputTuple, NullificationEnforcementUpdatedEvent.OutputTuple, NullificationEnforcementUpdatedEvent.OutputObject>;
getEvent(key: 'NullifierRegistryUpdated'): TypedContractEvent<NullifierRegistryUpdatedEvent.InputTuple, NullifierRegistryUpdatedEvent.OutputTuple, NullifierRegistryUpdatedEvent.OutputObject>;
getEvent(key: 'OwnershipTransferred'): TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
getEvent(key: 'TokensPurchased'): TypedContractEvent<TokensPurchasedEvent.InputTuple, TokensPurchasedEvent.OutputTuple, TokensPurchasedEvent.OutputObject>;
getEvent(key: 'TokensSold'): TypedContractEvent<TokensSoldEvent.InputTuple, TokensSoldEvent.OutputTuple, TokensSoldEvent.OutputObject>;

    filters: {
      
      'BatchMarketsCreated(uint256[],uint256,uint256)': TypedContractEvent<BatchMarketsCreatedEvent.InputTuple, BatchMarketsCreatedEvent.OutputTuple, BatchMarketsCreatedEvent.OutputObject>;
      BatchMarketsCreated: TypedContractEvent<BatchMarketsCreatedEvent.InputTuple, BatchMarketsCreatedEvent.OutputTuple, BatchMarketsCreatedEvent.OutputObject>;
    

      'BatchMarketsResolved(uint256[],uint256,uint256)': TypedContractEvent<BatchMarketsResolvedEvent.InputTuple, BatchMarketsResolvedEvent.OutputTuple, BatchMarketsResolvedEvent.OutputObject>;
      BatchMarketsResolved: TypedContractEvent<BatchMarketsResolvedEvent.InputTuple, BatchMarketsResolvedEvent.OutputTuple, BatchMarketsResolvedEvent.OutputObject>;
    

      'CTF1155Updated(address)': TypedContractEvent<CTF1155UpdatedEvent.InputTuple, CTF1155UpdatedEvent.OutputTuple, CTF1155UpdatedEvent.OutputObject>;
      CTF1155Updated: TypedContractEvent<CTF1155UpdatedEvent.InputTuple, CTF1155UpdatedEvent.OutputTuple, CTF1155UpdatedEvent.OutputObject>;
    

      'CTFMarketCreated(uint256,bytes32,uint256,uint256)': TypedContractEvent<CTFMarketCreatedEvent.InputTuple, CTFMarketCreatedEvent.OutputTuple, CTFMarketCreatedEvent.OutputObject>;
      CTFMarketCreated: TypedContractEvent<CTFMarketCreatedEvent.InputTuple, CTFMarketCreatedEvent.OutputTuple, CTFMarketCreatedEvent.OutputObject>;
    

      'ETCSwapIntegrationUpdated(address,bool)': TypedContractEvent<ETCSwapIntegrationUpdatedEvent.InputTuple, ETCSwapIntegrationUpdatedEvent.OutputTuple, ETCSwapIntegrationUpdatedEvent.OutputObject>;
      ETCSwapIntegrationUpdated: TypedContractEvent<ETCSwapIntegrationUpdatedEvent.InputTuple, ETCSwapIntegrationUpdatedEvent.OutputTuple, ETCSwapIntegrationUpdatedEvent.OutputObject>;
    

      'ETCSwapPoolsCreated(uint256,address,address)': TypedContractEvent<ETCSwapPoolsCreatedEvent.InputTuple, ETCSwapPoolsCreatedEvent.OutputTuple, ETCSwapPoolsCreatedEvent.OutputObject>;
      ETCSwapPoolsCreated: TypedContractEvent<ETCSwapPoolsCreatedEvent.InputTuple, ETCSwapPoolsCreatedEvent.OutputTuple, ETCSwapPoolsCreatedEvent.OutputObject>;
    

      'MarketCancelled(uint256,uint256,string,uint256)': TypedContractEvent<MarketCancelledEvent.InputTuple, MarketCancelledEvent.OutputTuple, MarketCancelledEvent.OutputObject>;
      MarketCancelled: TypedContractEvent<MarketCancelledEvent.InputTuple, MarketCancelledEvent.OutputTuple, MarketCancelledEvent.OutputObject>;
    

      'MarketCreated(uint256,uint256,address,address,address,uint256,uint256,uint256,address,uint8)': TypedContractEvent<MarketCreatedEvent.InputTuple, MarketCreatedEvent.OutputTuple, MarketCreatedEvent.OutputObject>;
      MarketCreated: TypedContractEvent<MarketCreatedEvent.InputTuple, MarketCreatedEvent.OutputTuple, MarketCreatedEvent.OutputObject>;
    

      'MarketResolved(uint256,uint256,uint256,uint256,bool,uint256)': TypedContractEvent<MarketResolvedEvent.InputTuple, MarketResolvedEvent.OutputTuple, MarketResolvedEvent.OutputObject>;
      MarketResolved: TypedContractEvent<MarketResolvedEvent.InputTuple, MarketResolvedEvent.OutputTuple, MarketResolvedEvent.OutputObject>;
    

      'MarketStatusChanged(uint256,uint8,uint8,uint256)': TypedContractEvent<MarketStatusChangedEvent.InputTuple, MarketStatusChangedEvent.OutputTuple, MarketStatusChangedEvent.OutputObject>;
      MarketStatusChanged: TypedContractEvent<MarketStatusChangedEvent.InputTuple, MarketStatusChangedEvent.OutputTuple, MarketStatusChangedEvent.OutputObject>;
    

      'NullificationEnforcementUpdated(bool)': TypedContractEvent<NullificationEnforcementUpdatedEvent.InputTuple, NullificationEnforcementUpdatedEvent.OutputTuple, NullificationEnforcementUpdatedEvent.OutputObject>;
      NullificationEnforcementUpdated: TypedContractEvent<NullificationEnforcementUpdatedEvent.InputTuple, NullificationEnforcementUpdatedEvent.OutputTuple, NullificationEnforcementUpdatedEvent.OutputObject>;
    

      'NullifierRegistryUpdated(address)': TypedContractEvent<NullifierRegistryUpdatedEvent.InputTuple, NullifierRegistryUpdatedEvent.OutputTuple, NullifierRegistryUpdatedEvent.OutputObject>;
      NullifierRegistryUpdated: TypedContractEvent<NullifierRegistryUpdatedEvent.InputTuple, NullifierRegistryUpdatedEvent.OutputTuple, NullifierRegistryUpdatedEvent.OutputObject>;
    

      'OwnershipTransferred(address,address)': TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
      OwnershipTransferred: TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
    

      'TokensPurchased(uint256,address,bool,uint256,uint256)': TypedContractEvent<TokensPurchasedEvent.InputTuple, TokensPurchasedEvent.OutputTuple, TokensPurchasedEvent.OutputObject>;
      TokensPurchased: TypedContractEvent<TokensPurchasedEvent.InputTuple, TokensPurchasedEvent.OutputTuple, TokensPurchasedEvent.OutputObject>;
    

      'TokensSold(uint256,address,bool,uint256,uint256)': TypedContractEvent<TokensSoldEvent.InputTuple, TokensSoldEvent.OutputTuple, TokensSoldEvent.OutputObject>;
      TokensSold: TypedContractEvent<TokensSoldEvent.InputTuple, TokensSoldEvent.OutputTuple, TokensSoldEvent.OutputObject>;
    
    };
  }
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers"
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "../common.js"
  
export declare namespace FriendGroupMarketFactory {
      
    export type AcceptanceRecordStruct = {participant: AddressLike, stakedAmount: BigNumberish, acceptedAt: BigNumberish, hasAccepted: boolean, isArbitrator: boolean}

    export type AcceptanceRecordStructOutput = [participant: string, stakedAmount: bigint, acceptedAt: bigint, hasAccepted: boolean, isArbitrator: boolean] & {participant: string, stakedAmount: bigint, acceptedAt: bigint, hasAccepted: boolean, isArbitrator: boolean }
  
    }

  export interface FriendGroupMarketFactoryInterface extends Interface {
    getFunction(nameOrSignature: "PROPOSAL_ID_OFFSET" | "acceptMarket" | "acceptedParticipantCount" | "acceptedPaymentTokens" | "acceptedTokenList" | "addAcceptedPaymentToken" | "addMember" | "autoResolvePeggedMarket" | "batchAutoResolvePeggedMarkets" | "cancelPendingMarket" | "createBookmakerMarket" | "createOneVsOneMarketPending" | "createSmallGroupMarketPending" | "defaultCollateralToken" | "enforceNullification" | "friendMarketCount" | "friendMarketFee" | "friendMarkets" | "getAcceptanceStatus" | "getAcceptedTokens" | "getFriendMarket" | "getFriendMarketWithStatus" | "getMemberCount" | "getParticipantAcceptance" | "getPeggedFriendMarkets" | "getStakeRequirements" | "getUserMarkets" | "hasAccepted" | "isMember" | "manager" | "marketAcceptances" | "marketFactory" | "marketTotalStaked" | "maxEventTrackingMembers" | "maxOneVsOneMembers" | "maxSmallGroupMembers" | "memberCount" | "minEventTrackingMembers" | "nullifierRegistry" | "oneVsOneFee" | "owner" | "paymentManager" | "pegToPublicMarket" | "processExpiredDeadline" | "publicMarketFee" | "publicMarketToPeggedFriendMarkets" | "ragequitModule" | "removeAcceptedPaymentToken" | "removeSelf" | "renounceOwnership" | "resolveFriendMarket" | "setDefaultCollateralToken" | "setNullificationEnforcement" | "setNullifierRegistry" | "setTieredRoleManager" | "tieredRoleManager" | "transferOwnership" | "updateFees" | "updateManager" | "updateMarketFactory" | "updateMemberLimits" | "updateRagequitModule" | "userMarkets" | "withdrawFees"): FunctionFragment;

    getEvent(nameOrSignatureOrTopic: "AcceptanceDeadlinePassed" | "ArbitratorAccepted" | "ArbitratorSet" | "BatchResolution" | "FeesUpdated" | "FriendMarketCreated" | "ManagerUpdated" | "MarketActivated" | "MarketCancelledByCreator" | "MarketCreatedPending" | "MarketPegged" | "MarketPeggedToPublic" | "MarketResolved" | "MemberAdded" | "MemberLimitsUpdated" | "MemberRemoved" | "NullificationEnforcementUpdated" | "NullifierRegistryUpdated" | "OwnershipTransferred" | "ParticipantAccepted" | "PaymentTokenAdded" | "PaymentTokenRemoved" | "PeggedMarketAutoResolved" | "StakeRefunded"): EventFragment;

    encodeFunctionData(functionFragment: 'PROPOSAL_ID_OFFSET', values?: undefined): string;
encodeFunctionData(functionFragment: 'acceptMarket', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'acceptedParticipantCount', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'acceptedPaymentTokens', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'acceptedTokenList', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'addAcceptedPaymentToken', values: [AddressLike, boolean]): string;
encodeFunctionData(functionFragment: 'addMember', values: [BigNumberish, AddressLike]): string;
encodeFunctionData(functionFragment: 'autoResolvePeggedMarket', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'batchAutoResolvePeggedMarkets', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'cancelPendingMarket', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'createBookmakerMarket', values: [AddressLike, string, BigNumberish, BigNumberish, BigNumberish, BigNumberish, AddressLike, BigNumberish, AddressLike]): string;
encodeFunctionData(functionFragment: 'createOneVsOneMarketPending', values: [AddressLike, string, BigNumberish, AddressLike, BigNumberish, BigNumberish, AddressLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'createSmallGroupMarketPending', values: [string, AddressLike[], BigNumberish, BigNumberish, AddressLike, BigNumberish, BigNumberish, BigNumberish, AddressLike]): string;
encodeFunctionData(functionFragment: 'defaultCollateralToken', values?: undefined): string;
encodeFunctionData(functionFragment: 'enforceNullification', values?: undefined): string;
encodeFunctionData(functionFragment: 'friendMarketCount', values?: undefined): string;
encodeFunctionData(functionFragment: 'friendMarketFee', values?: undefined): string;
encodeFunctionData(functionFragment: 'friendMarkets', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'getAcceptanceStatus', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'getAcceptedTokens', values?: undefined): string;
encodeFunctionData(functionFragment: 'getFriendMarket', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'getFriendMarketWithStatus', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'getMemberCount', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'getParticipantAcceptance', values: [BigNumberish, AddressLike]): string;
encodeFunctionData(functionFragment: 'getPeggedFriendMarkets', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'getStakeRequirements', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'getUserMarkets', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'hasAccepted', values: [BigNumberish, AddressLike]): string;
encodeFunctionData(functionFragment: 'isMember', values: [BigNumberish, AddressLike]): string;
encodeFunctionData(functionFragment: 'manager', values?: undefined): string;
encodeFunctionData(functionFragment: 'marketAcceptances', values: [BigNumberish, AddressLike]): string;
encodeFunctionData(functionFragment: 'marketFactory', values?: undefined): string;
encodeFunctionData(functionFragment: 'marketTotalStaked', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'maxEventTrackingMembers', values?: undefined): string;
encodeFunctionData(functionFragment: 'maxOneVsOneMembers', values?: undefined): string;
encodeFunctionData(functionFragment: 'maxSmallGroupMembers', values?: undefined): string;
encodeFunctionData(functionFragment: 'memberCount', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'minEventTrackingMembers', values?: undefined): string;
encodeFunctionData(functionFragment: 'nullifierRegistry', values?: undefined): string;
encodeFunctionData(functionFragment: 'oneVsOneFee', values?: undefined): string;
encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
encodeFunctionData(functionFragment: 'paymentManager', values?: undefined): string;
encodeFunctionData(functionFragment: 'pegToPublicMarket', values: [BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'processExpiredDeadline', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'publicMarketFee', values?: undefined): string;
encodeFunctionData(functionFragment: 'publicMarketToPeggedFriendMarkets', values: [BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'ragequitModule', values?: undefined): string;
encodeFunctionData(functionFragment: 'removeAcceptedPaymentToken', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'removeSelf', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
encodeFunctionData(functionFragment: 'resolveFriendMarket', values: [BigNumberish, boolean]): string;
encodeFunctionData(functionFragment: 'setDefaultCollateralToken', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'setNullificationEnforcement', values: [boolean]): string;
encodeFunctionData(functionFragment: 'setNullifierRegistry', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'setTieredRoleManager', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'tieredRoleManager', values?: undefined): string;
encodeFunctionData(functionFragment: 'transferOwnership', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'updateFees', values: [BigNumberish, BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'updateManager', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'updateMarketFactory', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'updateMemberLimits', values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'updateRagequitModule', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'userMarkets', values: [AddressLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'withdrawFees', values?: undefined): string;

    decodeFunctionResult(functionFragment: 'PROPOSAL_ID_OFFSET', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'acceptMarket', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'acceptedParticipantCount', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'acceptedPaymentTokens', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'acceptedTokenList', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'addAcceptedPaymentToken', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'addMember', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'autoResolvePeggedMarket', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'batchAutoResolvePeggedMarkets', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'cancelPendingMarket', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'createBookmakerMarket', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'createOneVsOneMarketPending', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'createSmallGroupMarketPending', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'defaultCollateralToken', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'enforceNullification', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'friendMarketCount', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'friendMarketFee', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'friendMarkets', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getAcceptanceStatus', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getAcceptedTokens', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getFriendMarket', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getFriendMarketWithStatus', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getMemberCount', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getParticipantAcceptance', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getPeggedFriendMarkets', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getStakeRequirements', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getUserMarkets', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'hasAccepted', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'isMember', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'manager', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'marketAcceptances', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'marketFactory', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'marketTotalStaked', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'maxEventTrackingMembers', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'maxOneVsOneMembers', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'maxSmallGroupMembers', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'memberCount', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'minEventTrackingMembers', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'nullifierRegistry', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'oneVsOneFee', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'paymentManager', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'pegToPublicMarket', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'processExpiredDeadline', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'publicMarketFee', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'publicMarketToPeggedFriendMarkets', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'ragequitModule', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'removeAcceptedPaymentToken', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'removeSelf', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'resolveFriendMarket', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'setDefaultCollateralToken', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'setNullificationEnforcement', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'setNullifierRegistry', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'setTieredRoleManager', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'tieredRoleManager', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'updateFees', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'updateManager', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'updateMarketFactory', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'updateMemberLimits', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'updateRagequitModule', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'userMarkets', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'withdrawFees', data: BytesLike): Result;
  }

  
    export namespace AcceptanceDeadlinePassedEvent {
      export type InputTuple = [friendMarketId: BigNumberish, deadline: BigNumberish, acceptedCount: BigNumberish, requiredCount: BigNumberish];
      export type OutputTuple = [friendMarketId: bigint, deadline: bigint, acceptedCount: bigint, requiredCount: bigint];
      export interface OutputObject {friendMarketId: bigint, deadline: bigint, acceptedCount: bigint, requiredCount: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace ArbitratorAcceptedEvent {
      export type InputTuple = [friendMarketId: BigNumberish, arbitrator: AddressLike, acceptedAt: BigNumberish];
      export type OutputTuple = [friendMarketId: bigint, arbitrator: string, acceptedAt: bigint];
      export interface OutputObject {friendMarketId: bigint, arbitrator: string, acceptedAt: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace ArbitratorSetEvent {
      export type InputTuple = [friendMarketId: BigNumberish, arbitrator: AddressLike];
      export type OutputTuple = [friendMarketId: bigint, arbitrator: string];
      export interface OutputObject {friendMarketId: bigint, arbitrator: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace BatchResolutionEvent {
      export type InputTuple = [publicMarketId: BigNumberish, friendMarketIds: BigNumberish[], outcome: BigNumberish];
      export type OutputTuple = [publicMarketId: bigint, friendMarketIds: bigint[], outcome: bigint];
      export interface OutputObject {publicMarketId: bigint, friendMarketIds: bigint[], outcome: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace FeesUpdatedEvent {
      export type InputTuple = [publicFee: BigNumberish, friendFee: BigNumberish, oneVsOneFee: BigNumberish];
      export type OutputTuple = [publicFee: bigint, friendFee: bigint, oneVsOneFee: bigint];
      export interface OutputObject {publicFee: bigint, friendFee: bigint, oneVsOneFee: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace FriendMarketCreatedEvent {
      export type InputTuple = [friendMarketId: BigNumberish, underlyingMarketId: BigNumberish, marketType: BigNumberish, creator: AddressLike, memberLimit: BigNumberish, creationFee: BigNumberish, paymentToken: AddressLike];
      export type OutputTuple = [friendMarketId: bigint, underlyingMarketId: bigint, marketType: bigint, creator: string, memberLimit: bigint, creationFee: bigint, paymentToken: string];
      export interface OutputObject {friendMarketId: bigint, underlyingMarketId: bigint, marketType: bigint, creator: string, memberLimit: bigint, creationFee: bigint, paymentToken: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace ManagerUpdatedEvent {
      export type InputTuple = [oldManager: AddressLike, newManager: AddressLike];
      export type OutputTuple = [oldManager: string, newManager: string];
      export interface OutputObject {oldManager: string, newManager: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace MarketActivatedEvent {
      export type InputTuple = [friendMarketId: BigNumberish, underlyingMarketId: BigNumberish, activatedAt: BigNumberish, totalStaked: BigNumberish, participantCount: BigNumberish];
      export type OutputTuple = [friendMarketId: bigint, underlyingMarketId: bigint, activatedAt: bigint, totalStaked: bigint, participantCount: bigint];
      export interface OutputObject {friendMarketId: bigint, underlyingMarketId: bigint, activatedAt: bigint, totalStaked: bigint, participantCount: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace MarketCancelledByCreatorEvent {
      export type InputTuple = [friendMarketId: BigNumberish, creator: AddressLike, cancelledAt: BigNumberish];
      export type OutputTuple = [friendMarketId: bigint, creator: string, cancelledAt: bigint];
      export interface OutputObject {friendMarketId: bigint, creator: string, cancelledAt: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace MarketCreatedPendingEvent {
      export type InputTuple = [friendMarketId: BigNumberish, creator: AddressLike, acceptanceDeadline: BigNumberish, stakePerParticipant: BigNumberish, opponentOddsMultiplier: BigNumberish, stakeToken: AddressLike, invitedParticipants: AddressLike[], arbitrator: AddressLike];
      export type OutputTuple = [friendMarketId: bigint, creator: string, acceptanceDeadline: bigint, stakePerParticipant: bigint, opponentOddsMultiplier: bigint, stakeToken: string, invitedParticipants: string[], arbitrator: string];
      export interface OutputObject {friendMarketId: bigint, creator: string, acceptanceDeadline: bigint, stakePerParticipant: bigint, opponentOddsMultiplier: bigint, stakeToken: string, invitedParticipants: string[], arbitrator: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace MarketPeggedEvent {
      export type InputTuple = [friendMarketId: BigNumberish, publicMarketId: BigNumberish];
      export type OutputTuple = [friendMarketId: bigint, publicMarketId: bigint];
      export interface OutputObject {friendMarketId: bigint, publicMarketId: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace MarketPeggedToPublicEvent {
      export type InputTuple = [friendMarketId: BigNumberish, publicMarketId: BigNumberish];
      export type OutputTuple = [friendMarketId: bigint, publicMarketId: bigint];
      export interface OutputObject {friendMarketId: bigint, publicMarketId: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace MarketResolvedEvent {
      export type InputTuple = [friendMarketId: BigNumberish, resolver: AddressLike, outcome: boolean];
      export type OutputTuple = [friendMarketId: bigint, resolver: string, outcome: boolean];
      export interface OutputObject {friendMarketId: bigint, resolver: string, outcome: boolean };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace MemberAddedEvent {
      export type InputTuple = [friendMarketId: BigNumberish, member: AddressLike];
      export type OutputTuple = [friendMarketId: bigint, member: string];
      export interface OutputObject {friendMarketId: bigint, member: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace MemberLimitsUpdatedEvent {
      export type InputTuple = [maxSmallGroup: BigNumberish, maxOneVsOne: BigNumberish, minEventTracking: BigNumberish, maxEventTracking: BigNumberish];
      export type OutputTuple = [maxSmallGroup: bigint, maxOneVsOne: bigint, minEventTracking: bigint, maxEventTracking: bigint];
      export interface OutputObject {maxSmallGroup: bigint, maxOneVsOne: bigint, minEventTracking: bigint, maxEventTracking: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace MemberRemovedEvent {
      export type InputTuple = [friendMarketId: BigNumberish, member: AddressLike];
      export type OutputTuple = [friendMarketId: bigint, member: string];
      export interface OutputObject {friendMarketId: bigint, member: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace NullificationEnforcementUpdatedEvent {
      export type InputTuple = [enforce: boolean];
      export type OutputTuple = [enforce: boolean];
      export interface OutputObject {enforce: boolean };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace NullifierRegistryUpdatedEvent {
      export type InputTuple = [nullifierRegistry: AddressLike];
      export type OutputTuple = [nullifierRegistry: string];
      export interface OutputObject {nullifierRegistry: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace OwnershipTransferredEvent {
      export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
      export type OutputTuple = [previousOwner: string, newOwner: string];
      export interface OutputObject {previousOwner: string, newOwner: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace ParticipantAcceptedEvent {
      export type InputTuple = [friendMarketId: BigNumberish, participant: AddressLike, stakedAmount: BigNumberish, acceptedAt: BigNumberish];
      export type OutputTuple = [friendMarketId: bigint, participant: string, stakedAmount: bigint, acceptedAt: bigint];
      export interface OutputObject {friendMarketId: bigint, participant: string, stakedAmount: bigint, acceptedAt: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace PaymentTokenAddedEvent {
      export type InputTuple = [token: AddressLike];
      export type OutputTuple = [token: string];
      export interface OutputObject {token: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace PaymentTokenRemovedEvent {
      export type InputTuple = [token: AddressLike];
      export type OutputTuple = [token: string];
      export interface OutputObject {token: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace PeggedMarketAutoResolvedEvent {
      export type InputTuple = [friendMarketId: BigNumberish, publicMarketId: BigNumberish, passValue: BigNumberish, failValue: BigNumberish];
      export type OutputTuple = [friendMarketId: bigint, publicMarketId: bigint, passValue: bigint, failValue: bigint];
      export interface OutputObject {friendMarketId: bigint, publicMarketId: bigint, passValue: bigint, failValue: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace StakeRefundedEvent {
      export type InputTuple = [friendMarketId: BigNumberish, participant: AddressLike, amount: BigNumberish];
      export type OutputTuple = [friendMarketId: bigint, participant: string, amount: bigint];
      export interface OutputObject {friendMarketId: bigint, participant: string, amount: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

  export interface FriendGroupMarketFactory extends BaseContract {
    
    connect(runner?: ContractRunner | null): FriendGroupMarketFactory;
    waitForDeployment(): Promise<this>;

    interface: FriendGroupMarketFactoryInterface;

    
  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>
  
  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>


    
    
    PROPOSAL_ID_OFFSET: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    acceptMarket: TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [void],
      'payable'
    >
    

    
    acceptedParticipantCount: TypedContractMethod<
      [arg0: BigNumberish, ],
      [bigint],
      'view'
    >
    

    
    acceptedPaymentTokens: TypedContractMethod<
      [arg0: AddressLike, ],
      [boolean],
      'view'
    >
    

    
    acceptedTokenList: TypedContractMethod<
      [arg0: BigNumberish, ],
      [string],
      'view'
    >
    

    
    addAcceptedPaymentToken: TypedContractMethod<
      [token: AddressLike, active: boolean, ],
      [void],
      'nonpayable'
    >
    

    
    addMember: TypedContractMethod<
      [friendMarketId: BigNumberish, newMember: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    autoResolvePeggedMarket: TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    batchAutoResolvePeggedMarkets: TypedContractMethod<
      [publicMarketId: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    cancelPendingMarket: TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    createBookmakerMarket: TypedContractMethod<
      [opponent: AddressLike, description: string, tradingPeriod: BigNumberish, acceptanceDeadline: BigNumberish, opponentStakeAmount: BigNumberish, opponentOddsMultiplier: BigNumberish, stakeToken: AddressLike, resolutionType: BigNumberish, arbitrator: AddressLike, ],
      [bigint],
      'payable'
    >
    

    
    createOneVsOneMarketPending: TypedContractMethod<
      [opponent: AddressLike, description: string, tradingPeriod: BigNumberish, arbitrator: AddressLike, acceptanceDeadline: BigNumberish, stakeAmount: BigNumberish, stakeToken: AddressLike, resolutionType: BigNumberish, ],
      [bigint],
      'payable'
    >
    

    
    createSmallGroupMarketPending: TypedContractMethod<
      [description: string, invitedMembers: AddressLike[], memberLimit: BigNumberish, tradingPeriod: BigNumberish, arbitrator: AddressLike, acceptanceDeadline: BigNumberish, minAcceptanceThreshold: BigNumberish, stakeAmount: BigNumberish, stakeToken: AddressLike, ],
      [bigint],
      'payable'
    >
    

    
    defaultCollateralToken: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    enforceNullification: TypedContractMethod<
      [],
      [boolean],
      'view'
    >
    

    
    friendMarketCount: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    friendMarketFee: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    friendMarkets: TypedContractMethod<
      [arg0: BigNumberish, ],
      [[bigint, bigint, string, string, bigint, bigint, bigint, boolean, string, bigint, boolean, string, bigint, bigint, bigint, bigint, bigint, string, bigint, bigint, bigint] & {marketId: bigint, marketType: bigint, creator: string, arbitrator: string, memberLimit: bigint, creationFee: bigint, createdAt: bigint, active: boolean, description: string, peggedPublicMarketId: bigint, autoPegged: boolean, paymentToken: string, liquidityAmount: bigint, status: bigint, acceptanceDeadline: bigint, minAcceptanceThreshold: bigint, stakePerParticipant: bigint, stakeToken: string, tradingPeriodSeconds: bigint, opponentOddsMultiplier: bigint, resolutionType: bigint }],
      'view'
    >
    

    
    getAcceptanceStatus: TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [[bigint, bigint, bigint, boolean, boolean, bigint] & {accepted: bigint, required: bigint, deadline: bigint, arbitratorRequired: boolean, arbitratorAccepted: boolean, status: bigint }],
      'view'
    >
    

    
    getAcceptedTokens: TypedContractMethod<
      [],
      [string[]],
      'view'
    >
    

    
    getFriendMarket: TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [[bigint, bigint, string, string[], string, bigint, bigint, bigint, boolean, string, bigint, boolean, string, bigint] & {marketId: bigint, marketType: bigint, creator: string, members: string[], arbitrator: string, memberLimit: bigint, creationFee: bigint, createdAt: bigint, active: boolean, description: string, peggedPublicMarketId: bigint, autoPegged: boolean, paymentToken: string, liquidityAmount: bigint }],
      'view'
    >
    

    
    getFriendMarketWithStatus: TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [[bigint, bigint, string, string[], string, bigint, bigint, bigint, string, bigint, bigint, bigint, string, bigint] & {marketId: bigint, marketType: bigint, creator: string, members: string[], arbitrator: string, status: bigint, acceptanceDeadline: bigint, stakePerParticipant: bigint, stakeToken: string, acceptedCount: bigint, minThreshold: bigint, opponentOddsMultiplier: bigint, description: string, resolutionType: bigint }],
      'view'
    >
    

    
    getMemberCount: TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [bigint],
      'view'
    >
    

    
    getParticipantAcceptance: TypedContractMethod<
      [friendMarketId: BigNumberish, participant: AddressLike, ],
      [FriendGroupMarketFactory.AcceptanceRecordStructOutput],
      'view'
    >
    

    
    getPeggedFriendMarkets: TypedContractMethod<
      [publicMarketId: BigNumberish, ],
      [bigint[]],
      'view'
    >
    

    
    getStakeRequirements: TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [[bigint, bigint, bigint, bigint] & {opponentStake: bigint, creatorStake: bigint, totalPot: bigint, oddsMultiplier: bigint }],
      'view'
    >
    

    
    getUserMarkets: TypedContractMethod<
      [user: AddressLike, ],
      [bigint[]],
      'view'
    >
    

    
    hasAccepted: TypedContractMethod<
      [friendMarketId: BigNumberish, participant: AddressLike, ],
      [boolean],
      'view'
    >
    

    
    isMember: TypedContractMethod<
      [friendMarketId: BigNumberish, user: AddressLike, ],
      [boolean],
      'view'
    >
    

    
    manager: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    marketAcceptances: TypedContractMethod<
      [arg0: BigNumberish, arg1: AddressLike, ],
      [[string, bigint, bigint, boolean, boolean] & {participant: string, stakedAmount: bigint, acceptedAt: bigint, hasAccepted: boolean, isArbitrator: boolean }],
      'view'
    >
    

    
    marketFactory: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    marketTotalStaked: TypedContractMethod<
      [arg0: BigNumberish, ],
      [bigint],
      'view'
    >
    

    
    maxEventTrackingMembers: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    maxOneVsOneMembers: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    maxSmallGroupMembers: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    memberCount: TypedContractMethod<
      [arg0: BigNumberish, ],
      [bigint],
      'view'
    >
    

    
    minEventTrackingMembers: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    nullifierRegistry: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    oneVsOneFee: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    owner: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    paymentManager: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    pegToPublicMarket: TypedContractMethod<
      [friendMarketId: BigNumberish, publicMarketId: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    processExpiredDeadline: TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    publicMarketFee: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    publicMarketToPeggedFriendMarkets: TypedContractMethod<
      [arg0: BigNumberish, arg1: BigNumberish, ],
      [bigint],
      'view'
    >
    

    
    ragequitModule: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    removeAcceptedPaymentToken: TypedContractMethod<
      [token: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    removeSelf: TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    renounceOwnership: TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >
    

    
    resolveFriendMarket: TypedContractMethod<
      [friendMarketId: BigNumberish, outcome: boolean, ],
      [void],
      'nonpayable'
    >
    

    
    setDefaultCollateralToken: TypedContractMethod<
      [_collateralToken: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    setNullificationEnforcement: TypedContractMethod<
      [_enforce: boolean, ],
      [void],
      'nonpayable'
    >
    

    
    setNullifierRegistry: TypedContractMethod<
      [_nullifierRegistry: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    setTieredRoleManager: TypedContractMethod<
      [_tieredRoleManager: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    tieredRoleManager: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    transferOwnership: TypedContractMethod<
      [newOwner: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    updateFees: TypedContractMethod<
      [_publicFee: BigNumberish, _friendFee: BigNumberish, _oneVsOneFee: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    updateManager: TypedContractMethod<
      [newManager: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    updateMarketFactory: TypedContractMethod<
      [_marketFactory: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    updateMemberLimits: TypedContractMethod<
      [_maxSmallGroup: BigNumberish, _maxOneVsOne: BigNumberish, _minEventTracking: BigNumberish, _maxEventTracking: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    updateRagequitModule: TypedContractMethod<
      [_ragequitModule: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    userMarkets: TypedContractMethod<
      [arg0: AddressLike, arg1: BigNumberish, ],
      [bigint],
      'view'
    >
    

    
    withdrawFees: TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >
    


    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(nameOrSignature: 'PROPOSAL_ID_OFFSET'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'acceptMarket'): TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [void],
      'payable'
    >;
getFunction(nameOrSignature: 'acceptedParticipantCount'): TypedContractMethod<
      [arg0: BigNumberish, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'acceptedPaymentTokens'): TypedContractMethod<
      [arg0: AddressLike, ],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'acceptedTokenList'): TypedContractMethod<
      [arg0: BigNumberish, ],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'addAcceptedPaymentToken'): TypedContractMethod<
      [token: AddressLike, active: boolean, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'addMember'): TypedContractMethod<
      [friendMarketId: BigNumberish, newMember: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'autoResolvePeggedMarket'): TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'batchAutoResolvePeggedMarkets'): TypedContractMethod<
      [publicMarketId: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'cancelPendingMarket'): TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'createBookmakerMarket'): TypedContractMethod<
      [opponent: AddressLike, description: string, tradingPeriod: BigNumberish, acceptanceDeadline: BigNumberish, opponentStakeAmount: BigNumberish, opponentOddsMultiplier: BigNumberish, stakeToken: AddressLike, resolutionType: BigNumberish, arbitrator: AddressLike, ],
      [bigint],
      'payable'
    >;
getFunction(nameOrSignature: 'createOneVsOneMarketPending'): TypedContractMethod<
      [opponent: AddressLike, description: string, tradingPeriod: BigNumberish, arbitrator: AddressLike, acceptanceDeadline: BigNumberish, stakeAmount: BigNumberish, stakeToken: AddressLike, resolutionType: BigNumberish, ],
      [bigint],
      'payable'
    >;
getFunction(nameOrSignature: 'createSmallGroupMarketPending'): TypedContractMethod<
      [description: string, invitedMembers: AddressLike[], memberLimit: BigNumberish, tradingPeriod: BigNumberish, arbitrator: AddressLike, acceptanceDeadline: BigNumberish, minAcceptanceThreshold: BigNumberish, stakeAmount: BigNumberish, stakeToken: AddressLike, ],
      [bigint],
      'payable'
    >;
getFunction(nameOrSignature: 'defaultCollateralToken'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'enforceNullification'): TypedContractMethod<
      [],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'friendMarketCount'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'friendMarketFee'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'friendMarkets'): TypedContractMethod<
      [arg0: BigNumberish, ],
      [[bigint, bigint, string, string, bigint, bigint, bigint, boolean, string, bigint, boolean, string, bigint, bigint, bigint, bigint, bigint, string, bigint, bigint, bigint] & {marketId: bigint, marketType: bigint, creator: string, arbitrator: string, memberLimit: bigint, creationFee: bigint, createdAt: bigint, active: boolean, description: string, peggedPublicMarketId: bigint, autoPegged: boolean, paymentToken: string, liquidityAmount: bigint, status: bigint, acceptanceDeadline: bigint, minAcceptanceThreshold: bigint, stakePerParticipant: bigint, stakeToken: string, tradingPeriodSeconds: bigint, opponentOddsMultiplier: bigint, resolutionType: bigint }],
      'view'
    >;
getFunction(nameOrSignature: 'getAcceptanceStatus'): TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [[bigint, bigint, bigint, boolean, boolean, bigint] & {accepted: bigint, required: bigint, deadline: bigint, arbitratorRequired: boolean, arbitratorAccepted: boolean, status: bigint }],
      'view'
    >;
getFunction(nameOrSignature: 'getAcceptedTokens'): TypedContractMethod<
      [],
      [string[]],
      'view'
    >;
getFunction(nameOrSignature: 'getFriendMarket'): TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [[bigint, bigint, string, string[], string, bigint, bigint, bigint, boolean, string, bigint, boolean, string, bigint] & {marketId: bigint, marketType: bigint, creator: string, members: string[], arbitrator: string, memberLimit: bigint, creationFee: bigint, createdAt: bigint, active: boolean, description: string, peggedPublicMarketId: bigint, autoPegged: boolean, paymentToken: string, liquidityAmount: bigint }],
      'view'
    >;
getFunction(nameOrSignature: 'getFriendMarketWithStatus'): TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [[bigint, bigint, string, string[], string, bigint, bigint, bigint, string, bigint, bigint, bigint, string, bigint] & {marketId: bigint, marketType: bigint, creator: string, members: string[], arbitrator: string, status: bigint, acceptanceDeadline: bigint, stakePerParticipant: bigint, stakeToken: string, acceptedCount: bigint, minThreshold: bigint, opponentOddsMultiplier: bigint, description: string, resolutionType: bigint }],
      'view'
    >;
getFunction(nameOrSignature: 'getMemberCount'): TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'getParticipantAcceptance'): TypedContractMethod<
      [friendMarketId: BigNumberish, participant: AddressLike, ],
      [FriendGroupMarketFactory.AcceptanceRecordStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'getPeggedFriendMarkets'): TypedContractMethod<
      [publicMarketId: BigNumberish, ],
      [bigint[]],
      'view'
    >;
getFunction(nameOrSignature: 'getStakeRequirements'): TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [[bigint, bigint, bigint, bigint] & {opponentStake: bigint, creatorStake: bigint, totalPot: bigint, oddsMultiplier: bigint }],
      'view'
    >;
getFunction(nameOrSignature: 'getUserMarkets'): TypedContractMethod<
      [user: AddressLike, ],
      [bigint[]],
      'view'
    >;
getFunction(nameOrSignature: 'hasAccepted'): TypedContractMethod<
      [friendMarketId: BigNumberish, participant: AddressLike, ],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'isMember'): TypedContractMethod<
      [friendMarketId: BigNumberish, user: AddressLike, ],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'manager'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'marketAcceptances'): TypedContractMethod<
      [arg0: BigNumberish, arg1: AddressLike, ],
      [[string, bigint, bigint, boolean, boolean] & {participant: string, stakedAmount: bigint, acceptedAt: bigint, hasAccepted: boolean, isArbitrator: boolean }],
      'view'
    >;
getFunction(nameOrSignature: 'marketFactory'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'marketTotalStaked'): TypedContractMethod<
      [arg0: BigNumberish, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'maxEventTrackingMembers'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'maxOneVsOneMembers'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'maxSmallGroupMembers'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'memberCount'): TypedContractMethod<
      [arg0: BigNumberish, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'minEventTrackingMembers'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'nullifierRegistry'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'oneVsOneFee'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'owner'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'paymentManager'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'pegToPublicMarket'): TypedContractMethod<
      [friendMarketId: BigNumberish, publicMarketId: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'processExpiredDeadline'): TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'publicMarketFee'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'publicMarketToPeggedFriendMarkets'): TypedContractMethod<
      [arg0: BigNumberish, arg1: BigNumberish, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'ragequitModule'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'removeAcceptedPaymentToken'): TypedContractMethod<
      [token: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'removeSelf'): TypedContractMethod<
      [friendMarketId: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'renounceOwnership'): TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'resolveFriendMarket'): TypedContractMethod<
      [friendMarketId: BigNumberish, outcome: boolean, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'setDefaultCollateralToken'): TypedContractMethod<
      [_collateralToken: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'setNullificationEnforcement'): TypedContractMethod<
      [_enforce: boolean, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'setNullifierRegistry'): TypedContractMethod<
      [_nullifierRegistry: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'setTieredRoleManager'): TypedContractMethod<
      [_tieredRoleManager: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'tieredRoleManager'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'transferOwnership'): TypedContractMethod<
      [newOwner: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'updateFees'): TypedContractMethod<
      [_publicFee: BigNumberish, _friendFee: BigNumberish, _oneVsOneFee: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'updateManager'): TypedContractMethod<
      [newManager: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'updateMarketFactory'): TypedContractMethod<
      [_marketFactory: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'updateMemberLimits'): TypedContractMethod<
      [_maxSmallGroup: BigNumberish, _maxOneVsOne: BigNumberish, _minEventTracking: BigNumberish, _maxEventTracking: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'updateRagequitModule'): TypedContractMethod<
      [_ragequitModule: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'userMarkets'): TypedContractMethod<
      [arg0: AddressLike, arg1: BigNumberish, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'withdrawFees'): TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >;

    getEvent(key: 'AcceptanceDeadlinePassed'): TypedContractEvent<AcceptanceDeadlinePassedEvent.InputTuple, AcceptanceDeadlinePassedEvent.OutputTuple, AcceptanceDeadlinePassedEvent.OutputObject>;
getEvent(key: 'ArbitratorAccepted'): TypedContractEvent<ArbitratorAcceptedEvent.InputTuple, ArbitratorAcceptedEvent.OutputTuple, ArbitratorAcceptedEvent.OutputObject>;
getEvent(key: 'ArbitratorSet'): TypedContractEvent<ArbitratorSetEvent.InputTuple, ArbitratorSetEvent.OutputTuple, ArbitratorSetEvent.OutputObject>;
getEvent(key: 'BatchResolution'): TypedContractEvent<BatchResolutionEvent.InputTuple, BatchResolutionEvent.OutputTuple, BatchResolutionEvent.OutputObject>;
getEvent(key: 'FeesUpdated'): TypedContractEvent<FeesUpdatedEvent.InputTuple, FeesUpdatedEvent.OutputTuple, FeesUpdatedEvent.OutputObject>;
getEvent(key: 'FriendMarketCreated'): TypedContractEvent<FriendMarketCreatedEvent.InputTuple, FriendMarketCreatedEvent.OutputTuple, FriendMarketCreatedEvent.OutputObject>;
getEvent(key: 'ManagerUpdated'): TypedContractEvent<ManagerUpdatedEvent.InputTuple, ManagerUpdatedEvent.OutputTuple, ManagerUpdatedEvent.OutputObject>;
getEvent(key: 'MarketActivated'): TypedContractEvent<MarketActivatedEvent.InputTuple, MarketActivatedEvent.OutputTuple, MarketActivatedEvent.OutputObject>;
getEvent(key: 'MarketCancelledByCreator'): TypedContractEvent<MarketCancelledByCreatorEvent.InputTuple, MarketCancelledByCreatorEvent.OutputTuple, MarketCancelledByCreatorEvent.OutputObject>;
getEvent(key: 'MarketCreatedPending'): TypedContractEvent<MarketCreatedPendingEvent.InputTuple, MarketCreatedPendingEvent.OutputTuple, MarketCreatedPendingEvent.OutputObject>;
getEvent(key: 'MarketPegged'): TypedContractEvent<MarketPeggedEvent.InputTuple, MarketPeggedEvent.OutputTuple, MarketPeggedEvent.OutputObject>;
getEvent(key: 'MarketPeggedToPublic'): TypedContractEvent<MarketPeggedToPublicEvent.InputTuple, MarketPeggedToPublicEvent.OutputTuple, MarketPeggedToPublicEvent.OutputObject>;
getEvent(key: 'MarketResolved'): TypedContractEvent<MarketResolvedEvent.InputTuple, MarketResolvedEvent.OutputTuple, MarketResolvedEvent.OutputObject>;
getEvent(key: 'MemberAdded'): TypedContractEvent<MemberAddedEvent.InputTuple, MemberAddedEvent.OutputTuple, MemberAddedEvent.OutputObject>;
getEvent(key: 'MemberLimitsUpdated'): TypedContractEvent<MemberLimitsUpdatedEvent.InputTuple, MemberLimitsUpdatedEvent.OutputTuple, MemberLimitsUpdatedEvent.OutputObject>;
getEvent(key: 'MemberRemoved'): TypedContractEvent<MemberRemovedEvent.InputTuple, MemberRemovedEvent.OutputTuple, MemberRemovedEvent.OutputObject>;
getEvent(key: 'NullificationEnforcementUpdated'): TypedContractEvent<NullificationEnforcementUpdatedEvent.InputTuple, NullificationEnforcementUpdatedEvent.OutputTuple, NullificationEnforcementUpdatedEvent.OutputObject>;
getEvent(key: 'NullifierRegistryUpdated'): TypedContractEvent<NullifierRegistryUpdatedEvent.InputTuple, NullifierRegistryUpdatedEvent.OutputTuple, NullifierRegistryUpdatedEvent.OutputObject>;
getEvent(key: 'OwnershipTransferred'): TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
getEvent(key: 'ParticipantAccepted'): TypedContractEvent<ParticipantAcceptedEvent.InputTuple, ParticipantAcceptedEvent.OutputTuple, ParticipantAcceptedEvent.OutputObject>;
getEvent(key: 'PaymentTokenAdded'): TypedContractEvent<PaymentTokenAddedEvent.InputTuple, PaymentTokenAddedEvent.OutputTuple, PaymentTokenAddedEvent.OutputObject>;
getEvent(key: 'PaymentTokenRemoved'): TypedContractEvent<PaymentTokenRemovedEvent.InputTuple, PaymentTokenRemovedEvent.OutputTuple, PaymentTokenRemovedEvent.OutputObject>;
getEvent(key: 'PeggedMarketAutoResolved'): TypedContractEvent<PeggedMarketAutoResolvedEvent.InputTuple, PeggedMarketAutoResolvedEvent.OutputTuple, PeggedMarketAutoResolvedEvent.OutputObject>;
getEvent(key: 'StakeRefunded'): TypedContractEvent<StakeRefundedEvent.InputTuple, StakeRefundedEvent.OutputTuple, StakeRefundedEvent.OutputObject>;

    filters: {
      
      'AcceptanceDeadlinePassed(uint256,uint256,uint256,uint256)': TypedContractEvent<AcceptanceDeadlinePassedEvent.InputTuple, AcceptanceDeadlinePassedEvent.OutputTuple, AcceptanceDeadlinePassedEvent.OutputObject>;
      AcceptanceDeadlinePassed: TypedContractEvent<AcceptanceDeadlinePassedEvent.InputTuple, AcceptanceDeadlinePassedEvent.OutputTuple, AcceptanceDeadlinePassedEvent.OutputObject>;
    

      'ArbitratorAccepted(uint256,address,uint256)': TypedContractEvent<ArbitratorAcceptedEvent.InputTuple, ArbitratorAcceptedEvent.OutputTuple, ArbitratorAcceptedEvent.OutputObject>;
      ArbitratorAccepted: TypedContractEvent<ArbitratorAcceptedEvent.InputTuple, ArbitratorAcceptedEvent.OutputTuple, ArbitratorAcceptedEvent.OutputObject>;
    

      'ArbitratorSet(uint256,address)': TypedContractEvent<ArbitratorSetEvent.InputTuple, ArbitratorSetEvent.OutputTuple, ArbitratorSetEvent.OutputObject>;
      ArbitratorSet: TypedContractEvent<ArbitratorSetEvent.InputTuple, ArbitratorSetEvent.OutputTuple, ArbitratorSetEvent.OutputObject>;
    

      'BatchResolution(uint256,uint256[],uint256)': TypedContractEvent<BatchResolutionEvent.InputTuple, BatchResolutionEvent.OutputTuple, BatchResolutionEvent.OutputObject>;
      BatchResolution: TypedContractEvent<BatchResolutionEvent.InputTuple, BatchResolutionEvent.OutputTuple, BatchResolutionEvent.OutputObject>;
    

      'FeesUpdated(uint256,uint256,uint256)': TypedContractEvent<FeesUpdatedEvent.InputTuple, FeesUpdatedEvent.OutputTuple, FeesUpdatedEvent.OutputObject>;
      FeesUpdated: TypedContractEvent<FeesUpdatedEvent.InputTuple, FeesUpdatedEvent.OutputTuple, FeesUpdatedEvent.OutputObject>;
    

      'FriendMarketCreated(uint256,uint256,uint8,address,uint256,uint256,address)': TypedContractEvent<FriendMarketCreatedEvent.InputTuple, FriendMarketCreatedEvent.OutputTuple, FriendMarketCreatedEvent.OutputObject>;
      FriendMarketCreated: TypedContractEvent<FriendMarketCreatedEvent.InputTuple, FriendMarketCreatedEvent.OutputTuple, FriendMarketCreatedEvent.OutputObject>;
    

      'ManagerUpdated(address,address)': TypedContractEvent<ManagerUpdatedEvent.InputTuple, ManagerUpdatedEvent.OutputTuple, ManagerUpdatedEvent.OutputObject>;
      ManagerUpdated: TypedContractEvent<ManagerUpdatedEvent.InputTuple, ManagerUpdatedEvent.OutputTuple, ManagerUpdatedEvent.OutputObject>;
    

      'MarketActivated(uint256,uint256,uint256,uint256,uint256)': TypedContractEvent<MarketActivatedEvent.InputTuple, MarketActivatedEvent.OutputTuple, MarketActivatedEvent.OutputObject>;
      MarketActivated: TypedContractEvent<MarketActivatedEvent.InputTuple, MarketActivatedEvent.OutputTuple, MarketActivatedEvent.OutputObject>;
    

      'MarketCancelledByCreator(uint256,address,uint256)': TypedContractEvent<MarketCancelledByCreatorEvent.InputTuple, MarketCancelledByCreatorEvent.OutputTuple, MarketCancelledByCreatorEvent.OutputObject>;
      MarketCancelledByCreator: TypedContractEvent<MarketCancelledByCreatorEvent.InputTuple, MarketCancelledByCreatorEvent.OutputTuple, MarketCancelledByCreatorEvent.OutputObject>;
    

      'MarketCreatedPending(uint256,address,uint256,uint256,uint16,address,address[],address)': TypedContractEvent<MarketCreatedPendingEvent.InputTuple, MarketCreatedPendingEvent.OutputTuple, MarketCreatedPendingEvent.OutputObject>;
      MarketCreatedPending: TypedContractEvent<MarketCreatedPendingEvent.InputTuple, MarketCreatedPendingEvent.OutputTuple, MarketCreatedPendingEvent.OutputObject>;
    

      'MarketPegged(uint256,uint256)': TypedContractEvent<MarketPeggedEvent.InputTuple, MarketPeggedEvent.OutputTuple, MarketPeggedEvent.OutputObject>;
      MarketPegged: TypedContractEvent<MarketPeggedEvent.InputTuple, MarketPeggedEvent.OutputTuple, MarketPeggedEvent.OutputObject>;
    

      'MarketPeggedToPublic(uint256,uint256)': TypedContractEvent<MarketPeggedToPublicEvent.InputTuple, MarketPeggedToPublicEvent.OutputTuple, MarketPeggedToPublicEvent.OutputObject>;
      MarketPeggedToPublic: TypedContractEvent<MarketPeggedToPublicEvent.InputTuple, MarketPeggedToPublicEvent.OutputTuple, MarketPeggedToPublicEvent.OutputObject>;
    

      'MarketResolved(uint256,address,bool)': TypedContractEvent<MarketResolvedEvent.InputTuple, MarketResolvedEvent.OutputTuple, MarketResolvedEvent.OutputObject>;
      MarketResolved: TypedContractEvent<MarketResolvedEvent.InputTuple, MarketResolvedEvent.OutputTuple, MarketResolvedEvent.OutputObject>;
    

      'MemberAdded(uint256,address)': TypedContractEvent<MemberAddedEvent.InputTuple, MemberAddedEvent.OutputTuple, MemberAddedEvent.OutputObject>;
      MemberAdded: TypedContractEvent<MemberAddedEvent.InputTuple, MemberAddedEvent.OutputTuple, MemberAddedEvent.OutputObject>;
    

      'MemberLimitsUpdated(uint256,uint256,uint256,uint256)': TypedContractEvent<MemberLimitsUpdatedEvent.InputTuple, MemberLimitsUpdatedEvent.OutputTuple, MemberLimitsUpdatedEvent.OutputObject>;
      MemberLimitsUpdated: TypedContractEvent<MemberLimitsUpdatedEvent.InputTuple, MemberLimitsUpdatedEvent.OutputTuple, MemberLimitsUpdatedEvent.OutputObject>;
    

      'MemberRemoved(uint256,address)': TypedContractEvent<MemberRemovedEvent.InputTuple, MemberRemovedEvent.OutputTuple, MemberRemovedEvent.OutputObject>;
      MemberRemoved: TypedContractEvent<MemberRemovedEvent.InputTuple, MemberRemovedEvent.OutputTuple, MemberRemovedEvent.OutputObject>;
    

      'NullificationEnforcementUpdated(bool)': TypedContractEvent<NullificationEnforcementUpdatedEvent.InputTuple, NullificationEnforcementUpdatedEvent.OutputTuple, NullificationEnforcementUpdatedEvent.OutputObject>;
      NullificationEnforcementUpdated: TypedContractEvent<NullificationEnforcementUpdatedEvent.InputTuple, NullificationEnforcementUpdatedEvent.OutputTuple, NullificationEnforcementUpdatedEvent.OutputObject>;
    

      'NullifierRegistryUpdated(address)': TypedContractEvent<NullifierRegistryUpdatedEvent.InputTuple, NullifierRegistryUpdatedEvent.OutputTuple, NullifierRegistryUpdatedEvent.OutputObject>;
      NullifierRegistryUpdated: TypedContractEvent<NullifierRegistryUpdatedEvent.InputTuple, NullifierRegistryUpdatedEvent.OutputTuple, NullifierRegistryUpdatedEvent.OutputObject>;
    

      'OwnershipTransferred(address,address)': TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
      OwnershipTransferred: TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
    

      'ParticipantAccepted(uint256,address,uint256,uint256)': TypedContractEvent<ParticipantAcceptedEvent.InputTuple, ParticipantAcceptedEvent.OutputTuple, ParticipantAcceptedEvent.OutputObject>;
      ParticipantAccepted: TypedContractEvent<ParticipantAcceptedEvent.InputTuple, ParticipantAcceptedEvent.OutputTuple, ParticipantAcceptedEvent.OutputObject>;
    

      'PaymentTokenAdded(address)': TypedContractEvent<PaymentTokenAddedEvent.InputTuple, PaymentTokenAddedEvent.OutputTuple, PaymentTokenAddedEvent.OutputObject>;
      PaymentTokenAdded: TypedContractEvent<PaymentTokenAddedEvent.InputTuple, PaymentTokenAddedEvent.OutputTuple, PaymentTokenAddedEvent.OutputObject>;
    

      'PaymentTokenRemoved(address)': TypedContractEvent<PaymentTokenRemovedEvent.InputTuple, PaymentTokenRemovedEvent.OutputTuple, PaymentTokenRemovedEvent.OutputObject>;
      PaymentTokenRemoved: TypedContractEvent<PaymentTokenRemovedEvent.InputTuple, PaymentTokenRemovedEvent.OutputTuple, PaymentTokenRemovedEvent.OutputObject>;
    

      'PeggedMarketAutoResolved(uint256,uint256,uint256,uint256)': TypedContractEvent<PeggedMarketAutoResolvedEvent.InputTuple, PeggedMarketAutoResolvedEvent.OutputTuple, PeggedMarketAutoResolvedEvent.OutputObject>;
      PeggedMarketAutoResolved: TypedContractEvent<PeggedMarketAutoResolvedEvent.InputTuple, PeggedMarketAutoResolvedEvent.OutputTuple, PeggedMarketAutoResolvedEvent.OutputObject>;
    

      'StakeRefunded(uint256,address,uint256)': TypedContractEvent<StakeRefundedEvent.InputTuple, StakeRefundedEvent.OutputTuple, StakeRefundedEvent.OutputObject>;
      StakeRefunded: TypedContractEvent<StakeRefundedEvent.InputTuple, StakeRefundedEvent.OutputTuple, StakeRefundedEvent.OutputObject>;
    
    };
  }